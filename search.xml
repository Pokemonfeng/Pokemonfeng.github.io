<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>搭载阿里云图床 + typora配置实现对象存储</title>
      <link href="/2023/03/08/%E6%90%AD%E8%BD%BD%E9%98%BF%E9%87%8C%E4%BA%91%E5%9B%BE%E5%BA%8A-typora%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/"/>
      <url>/2023/03/08/%E6%90%AD%E8%BD%BD%E9%98%BF%E9%87%8C%E4%BA%91%E5%9B%BE%E5%BA%8A-typora%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="搭载阿里云图床-typora配置实现对象存储"><a href="#搭载阿里云图床-typora配置实现对象存储" class="headerlink" title="搭载阿里云图床 + typora配置实现对象存储"></a>搭载阿里云图床 + typora配置实现对象存储</h1><h2 id="首先创建对象储存OSS"><a href="#首先创建对象储存OSS" class="headerlink" title="首先创建对象储存OSS"></a>首先创建对象储存OSS</h2><ol><li>打开阿里云官网 -&gt; 点击控制台 -&gt; 选择对象储存OSS</li></ol><p><img src="https://pikaxg.oss-cn-hongkong.aliyuncs.com/images/image-20230308162659877.png" alt="image-20230308162659877"></p><ol start="2"><li>创建Bucket</li></ol><p><img src="https://pikaxg.oss-cn-hongkong.aliyuncs.com/images/image-20230308162754201.png" alt="image-20230308162754201"></p><ol start="3"><li>填写Bucket相关信息</li></ol><p><img src="https://pikaxg.oss-cn-hongkong.aliyuncs.com/images/image-20230308163009266.png" alt="image-20230308163009266"></p><p>注意：读写权限选择公共读写，然后点击确定</p><p><img src="https://pikaxg.oss-cn-hongkong.aliyuncs.com/images/image-20230308163143798.png" alt="image-20230308163143798"></p><ol start="4"><li>开通完后购买资源包（很便宜半年5块钱）</li></ol><p><img src="https://pikaxg.oss-cn-hongkong.aliyuncs.com/images/image-20230308163427273.png" alt="image-20230308163427273"></p><ol start="5"><li>下载typroa</li></ol><ol start="6"><li>下载完成后打开软件，点击文件-&gt;偏好设置-&gt;图像-&gt;然后如下图所示操作</li></ol><p><img src="https://pikaxg.oss-cn-hongkong.aliyuncs.com/images/image-20230308164007916.png" alt="image-20230308164007916"></p><ol start="7"><li>设置配置文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;picBed&quot;: &#123;</span><br><span class="line">      &quot;uploader&quot;: &quot;aliyun&quot;,</span><br><span class="line">      &quot;aliyun&quot;: &#123;</span><br><span class="line">      &quot;accessKeyId&quot;: &quot;&quot;, //ram的accessKey</span><br><span class="line">      &quot;accessKeySecret&quot;: &quot;&quot;, //ram的accessKey</span><br><span class="line">      &quot;bucket&quot;: &quot;&quot;, // bucket名</span><br><span class="line">      &quot;area&quot;: &quot;&quot;, // 地域节点（.aliyuncs.com前面的部分）</span><br><span class="line">      &quot;path&quot;: &quot;img/&quot;, // 存储路径</span><br><span class="line">       &quot;customUrl&quot;: &quot;&quot;, // Bucket域名，注意要加 http://或者 https://</span><br><span class="line">       &quot;options&quot;: &quot;&quot; // 针对图片的一些后缀处理参数 PicGo 2.2.0+ PicGo-Core 1.4.0+</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;picgoPlugins&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>首先是配置accessKey</li></ul><p><img src="https://pikaxg.oss-cn-hongkong.aliyuncs.com/images/image-20230308164554856.png" alt="image-20230308164554856"></p><p><img src="/2023/03/08/%E6%90%AD%E8%BD%BD%E9%98%BF%E9%87%8C%E4%BA%91%E5%9B%BE%E5%BA%8A-typora%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/Users\14359\AppData\Roaming\Typora\typora-user-images\image-20230308170105181.png" alt="image-20230308170105181"></p><ul><li>然后是配置bucket、area、customUrl</li></ul><p><img src="https://pikaxg.oss-cn-hongkong.aliyuncs.com/images/image-20230308164443397.png" alt="image-20230308164443397"></p><ol start="8"><li>验证配置，点击验证图片上传选项，验证成功后可以上阿里云控制台查看是否多出两张图片</li></ol><p><img src="https://pikaxg.oss-cn-hongkong.aliyuncs.com/images/image-20230308165518060.png" alt="image-20230308165518060"></p><ol start="9"><li>上传图片</li></ol><p>​    配置成功后就可以通过新建typora文档，使用复制粘贴或者上拉图片的方式上传到阿里云图床啦！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 阿里云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css3学习</title>
      <link href="/2023/03/07/Css3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/03/07/Css3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS3简介"><a href="#CSS3简介" class="headerlink" title="CSS3简介"></a>CSS3简介</h1><h2 id="浏览器私有前缀"><a href="#浏览器私有前缀" class="headerlink" title="浏览器私有前缀"></a>浏览器私有前缀</h2><table><thead><tr><th>私有前缀</th><th>对应的浏览器</th></tr></thead><tbody><tr><td>-webkit-</td><td>Chrome和Safari</td></tr><tr><td>-moz-</td><td>Firefox</td></tr><tr><td>-ms-</td><td>IE</td></tr><tr><td>-o-</td><td>Opera</td></tr></tbody></table><h1 id="CSS3选择器"><a href="#CSS3选择器" class="headerlink" title="CSS3选择器"></a>CSS3选择器</h1><h2 id="css3属性选择器"><a href="#css3属性选择器" class="headerlink" title="css3属性选择器*"></a>css3属性选择器*</h2><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>E[attr^=“xxx”]</td><td>选择元素E，其中E元素的attr属性是以xxx开头的任何字符</td></tr><tr><td>E[attr$=“xxx”]</td><td>选择元素E，其中E元素的attr属性是以xxx结尾的任何字符</td></tr><tr><td>E[attr*=“xxx”]</td><td>选择元素E，其中E元素的attr属性是包含xxx的任何字符</td></tr></tbody></table><p>例子<br>a[href$=”doc”]::before { content:url(“img/1.png”); }<br>使用CSS3属性选择器来匹配a标签中href属性值中最后几个字符（也就是文件后缀名），然后分别添加不同&gt;的图标就可以了。<br>此外，::before是伪元素，常配合content属性使用，实现为元素插入内容</p><h2 id="子元素伪类选择器（第一类）"><a href="#子元素伪类选择器（第一类）" class="headerlink" title="子元素伪类选择器（第一类）"></a>子元素伪类选择器（第一类）</h2><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>E:first-child</td><td>选择父元素下的第一个子元素（该子元素类型为E，以下类同）</td></tr><tr><td>E:last-child</td><td>选择父元素下的最后一个子元素</td></tr><tr><td>E:nth-child(n)</td><td>选择父元素下的第n个子元素或奇偶元素，n取值有3种：数字、odd和even，其中n从1开始</td></tr><tr><td>E:only-child</td><td>选择父元素下唯一的子元素，该父元素只有一个子元素</td></tr></tbody></table><p><strong>子类伪类选择器（第二类）</strong></p><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>E:first-of-type</td><td>选择父元素下的第一个E类型的子元素</td></tr><tr><td>E:last-of-type</td><td>选择父元素下的最后一个E类型的子元素</td></tr><tr><td>E:nth-of-type(n)</td><td>选择父元素下的第n个E类型的子元素或奇偶元素，n取值有3种：数字、odd和even，n从1开始</td></tr><tr><td>E:only-of-type</td><td>选择父元素下唯一的E类型的子元素，该父元素可以有多个子元素</td></tr></tbody></table><p>两者对比： <strong>前者在父元素的所有子元素中查找符合的子元素,后者在父类中同类子元素中查找;</strong><br><strong>:first-child在选择父元素下的子元素时，不仅要区分元素类型，还要求是第一个子元素。<br>:first-of-type在选择父元素下的子元素时，只需要区分元素类型，不要求是第一个子元素</strong></p><h2 id="UI伪类选择器"><a href="#UI伪类选择器" class="headerlink" title="UI伪类选择器"></a>UI伪类选择器</h2><ul><li>  （1）:focus ：获取焦点时使用的样式；</li><li>  （2）::selection ：定义页面中被选中文本的样式；</li><li>  （3）:checked ：定义单选框或复选框被选中时的样式；</li><li>  （4）:enabled和:disabled ：定义表单元素可用时和不可用时的样式；</li><li>（5）:read-write和:read-only ：定义表单的可读写性和只读性；</li></ul><h2 id="其他伪类选择器"><a href="#其他伪类选择器" class="headerlink" title="其他伪类选择器"></a>其他伪类选择器</h2><ul><li>  （1）:root ：选择HTML页面的根元素</li><li>  （2）:empty ：选择一个“不包含任何子元素和内容”的元素，也就是选择一个空元素</li><li>  （3）:target ：选取页面中的某一个target元素。所谓的target元素，指的是id被当成页面的锚点链接来使用的元素</li><li>（4）:not() ：选取某一个元素之外的所有元素</li></ul><h1 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h1><p>文本样式属性</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>text-shadow</td><td>文本阴影</td></tr><tr><td>text-stroke</td><td>文本描边</td></tr><tr><td>text-overflow</td><td>文本溢出</td></tr><tr><td>word-wrap</td><td>强制换行</td></tr><tr><td><a href="/font-face%20">@font-face</a></td><td>嵌入字体</td></tr></tbody></table><h2 id="文本溢出样式"><a href="#文本溢出样式" class="headerlink" title="文本溢出样式"></a>文本溢出样式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-overflow:取值;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>ellipsis</td><td>当文本溢出时，显示省略号，并且隐藏多余的文字</td></tr><tr><td>clip</td><td>当文本溢出时，不显示省略号，而是将溢出的文字裁切掉</td></tr></tbody></table><p>单独使用text-overflow属性是无法得到省略号效果的。要想实现文本溢出时就显示省略号效果，我们还需要结合white-space和overflow这两个属性来实现;<br>overflow:hidden;<br>white-space:nowrap;<br>text-overflow:ellipsis;</p><h2 id="强制换行：word-wrap、word-break"><a href="#强制换行：word-wrap、word-break" class="headerlink" title="强制换行：word-wrap、word-break"></a>强制换行：word-wrap、word-break</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">word-wrap:取值;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>normal</td><td>自动换行（默认值）</td></tr><tr><td>break-word</td><td>强制换行</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">word-break:取值;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>normal</td><td>自动换行（默认值）</td></tr><tr><td>break-all</td><td>允许在单词内换行</td></tr><tr><td>keep-all</td><td>只能在半角空格或连字符处换行</td></tr></tbody></table><h2 id="嵌入字体：-font-face"><a href="#嵌入字体：-font-face" class="headerlink" title="嵌入字体：@font-face"></a>嵌入字体：<a href="/font-face%20">@font-face</a></h2><p>语法：<a href="/font-face%20">@font-face </a>{ font-family: 字体名称; src:url(文件路径); }</p><h1 id="颜色样式"><a href="#颜色样式" class="headerlink" title="颜色样式"></a>颜色样式</h1><h2 id="opacity透明度"><a href="#opacity透明度" class="headerlink" title="opacity透明度"></a>opacity透明度</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opacity:数值;</span><br></pre></td></tr></table></figure><p>opacity属性取值是一个数值，取值范围为0.0~1.0。其中0.0表示完全透明，1.0表示完全不透明</p><h2 id="RGBA颜色"><a href="#RGBA颜色" class="headerlink" title="RGBA颜色"></a>RGBA颜色</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rgba(R, G, B, A)</span><br></pre></td></tr></table></figure><p>R，指的是红色值（Red）；G，指的是绿色值（Green）；B，指的是蓝色值（Blue）；A，指的是透明度（Alpha）。</p><p>R、G、B这三个可以为整数，取值范围为0255，也可以为百分比，取值范围为0%100%。参数A为透明度，跟opacity属性是一样的，取值范围为0.0~1.0</p><p>RGBA中的透明度只会针对当前设置的属性起作用</p><h2 id="CSS3渐变"><a href="#CSS3渐变" class="headerlink" title="CSS3渐变"></a>CSS3渐变</h2><p>线性渐变<br>background:linear-gradient(方向, 开始颜色, 结束颜色)</p><table><thead><tr><th>属性值</th><th>对应角度</th><th>说明</th></tr></thead><tbody><tr><td>to top</td><td>0deg</td><td>从下到上</td></tr><tr><td>to bottom</td><td>180deg</td><td>从上到下（默认值）</td></tr><tr><td>to left</td><td>270deg</td><td>从右到左</td></tr><tr><td>to right</td><td>90deg</td><td>从左到右</td></tr><tr><td>to top left</td><td>无</td><td>从右下角到左上角（斜对角）</td></tr><tr><td>to top right</td><td>无</td><td>从左下角到右上角（斜对角）</td></tr></tbody></table><p>特别注意一点，线性渐变使用的是background属性，而不是background-color属性。如果使用background-color属性，则无效</p><p>径向渐变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background:radial-gradient(position, shape size, start-color, stop-color)</span><br></pre></td></tr></table></figure><p>position用于定义圆心位置。shape size用于定义形状大小，由两部分组成，shape定义形状，size定义大小。start-color和stop-color分别用于定义开始颜色和结束颜色。</p><p>其中，position和shape size都是可选参数。如果省略，则表示采用默认值。start-color和stop-color都是必选参数，可以有多个颜色值</p><p>圆心位置position</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>center</td><td>中部（默认值）</td></tr><tr><td>top</td><td>顶部</td></tr><tr><td>bottom</td><td>底部</td></tr><tr><td>left</td><td>左部</td></tr><tr><td>right</td><td>右部</td></tr><tr><td>top center</td><td>靠上居中</td></tr><tr><td>top left</td><td>左上</td></tr><tr><td>top right</td><td>右上</td></tr><tr><td>left center</td><td>靠左居中</td></tr><tr><td>center center</td><td>正中</td></tr><tr><td>right center</td><td>靠右居中</td></tr><tr><td>bottom left</td><td>左下</td></tr><tr><td>bottom center</td><td>靠下居中</td></tr><tr><td>bottom right</td><td>右下</td></tr></tbody></table><p>shape size<br>参数shape用于定义径向渐变的“形状”，而参数size用于定义径向渐变的“大小”，如下表所示</p><p>参数shape取值</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>ellipse</td><td>椭圆形（默认值）</td></tr><tr><td>circle</td><td>圆形</td></tr></tbody></table><p>参数size取值</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>closest-side</td><td>指定径向渐变的半径长度为从圆心到离圆心最近的边</td></tr><tr><td>closest-corner</td><td>指定径向渐变的半径长度为从圆心到离圆心最近的角</td></tr><tr><td>farthest-side</td><td>指定径向渐变的半径长度为从圆心到离圆心最远的边</td></tr><tr><td>farthest-corner</td><td>指定径向渐变的半径长度为从圆心到离圆心最远的角</td></tr></tbody></table><p>start-color和stop-color</p><p>参数start-color用于定义径向渐变的“开始颜色”，而参数stop-color用于定义径向渐变的“结束颜色”。此外，径向渐变也可以接受一个“值列表”，用于同时定义多种颜色的径向渐变</p><h1 id="边框样式"><a href="#边框样式" class="headerlink" title="边框样式"></a>边框样式</h1><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>border-radius</td><td>圆角效果</td></tr><tr><td>box-shadow</td><td>边框阴影</td></tr><tr><td>border-colors</td><td>多色边框</td></tr><tr><td>border-image</td><td>边框背景</td></tr></tbody></table><p>border-radius属性可以分别为4个角设置相应的圆角值，这4个角的属性如下。</p><ul><li>  （1）border-top-right-radius：右上角</li><li>  （2）border-bottom-right-radius：右下角</li><li>  （3）border-bottom-left-radius：左下角</li><li>（4）border-top-left-radius：左上角</li></ul><h2 id="box-shadow属性简介"><a href="#box-shadow属性简介" class="headerlink" title="box-shadow属性简介"></a>box-shadow属性简介</h2><p><strong>box-shadow:x-offset y-offset blur spread color style;</strong></p><ul><li>  （1）x-offset：定义水平阴影的偏移距离，可以使用负值。由于CSS3采用的是W3C坐标系，因此x-offset取值为正时，向右偏移；取值为负时，向左偏移。</li><li>  （2）y-offset：定义垂直阴影的偏移距离，可以使用负值。由于CSS3采用的是W3C坐标系，因此y-offset取值为正时，向下偏移；取值为负时，向上偏移。</li><li>  （3）blur：定义阴影的模糊半径，只能为正值。</li><li>  （4）spread：定义阴影的大小。</li><li>  （5）color：定义阴影的颜色。</li><li>（6）style：定义是外阴影还是内阴影</li></ul><p>box-shadow:5px 5px 8px 0px red;表示阴影的水平偏移距离为5px，垂直偏移距离为5px，模糊半径为8px，阴影大小为0px，阴影颜色为red;</p><p>x-offset用于定义水平阴影的偏移距离，y-offset用于定义垂直阴影的偏移距离</p><p>模糊半径：blur<br>对于box-shadow属性来说，blur用于定义阴影的模糊半径</p><p>阴影大小：spread<br>对于box-shadow属性来说，spread用于定义阴影的尺寸大小</p><p>内外阴影：style<br>对于box-shadow属性来说，参数style用于定义是内阴影还是外阴影。其中，style取值有两种：outset和inset。当取值为outset时（默认值），表示外阴影；当取值为inset时，表示内阴影</p><h2 id="多色边框：border-colors"><a href="#多色边框：border-colors" class="headerlink" title="多色边框：border-colors"></a>多色边框：border-colors</h2><p>**border-top-colors:颜色值;<br>****border-right-colors:颜色值;<br>****border-bottom-colors:颜色值;<br>**<strong>border-left-colors:颜色值;</strong></p><h2 id="边框背景：border-image"><a href="#边框背景：border-image" class="headerlink" title="边框背景：border-image"></a>边框背景：border-image</h2><p><strong>border-image属性的平铺方式有3种：repeat、round、stretch。</strong></p><ul><li>  （1）取值为repeat时，表示4条边的小方块会不断重复，超出元素部分将会被剪切掉。</li><li>  （2）取值为round时，表示4条边的小方块会铺满。为了铺满，边框图片会压缩或拉伸。</li><li>（3）取值为stretch时，表示4条边的小方块会拉伸，边长有多长就拉多长。</li></ul><p><strong>border-image的派生子属性</strong></p><table><thead><tr><th>子属性</th><th>说明</th></tr></thead><tbody><tr><td>border-top-image</td><td>定义上边框背景图片</td></tr><tr><td>border-bottom-image</td><td>定义下边框背景图片</td></tr><tr><td>border-left-image</td><td>定义左边框背景图片</td></tr><tr><td>border-right-image</td><td>定义右边框背景图片</td></tr></tbody></table><h1 id="背景样式简介"><a href="#背景样式简介" class="headerlink" title="背景样式简介"></a>背景样式简介</h1><p><strong>背景样式属性</strong></p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>background-size</td><td>背景大小</td></tr><tr><td>background-origin</td><td>背景位置</td></tr><tr><td>background-clip</td><td>背景剪切</td></tr></tbody></table><p><strong>background-size:取值;</strong></p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>cover</td><td>即“覆盖”，表示将背景图片等比缩放来填满整个元素</td></tr><tr><td>contain</td><td>即“容纳”，表示将背景图片等比缩放至某一边紧贴元素边沿为止</td></tr></tbody></table><h2 id="背景位置"><a href="#背景位置" class="headerlink" title="背景位置"></a>背景位置</h2><p><strong>使用background-origin属性来定义背景图片是从什么地方开始平铺的，也就是定义背景图片的位置</strong></p><p>background-origin:取值;</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>border-box</td><td>从边框开始平铺</td></tr><tr><td>padding-box</td><td>从内边距开始平铺（默认值）</td></tr><tr><td>content-box</td><td>从内容区开始平铺</td></tr></tbody></table><h2 id="背景剪切"><a href="#背景剪切" class="headerlink" title="背景剪切"></a>背景剪切</h2><p><strong>使用background-clip属性来剪切背景图片</strong></p><p>background-clip:取值;</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>border-box</td><td>从边框开始剪切（默认值）</td></tr><tr><td>padding-box</td><td>从内边距开始剪切</td></tr><tr><td>content-box</td><td>从内容区开始剪切</td></tr></tbody></table><p>background-clip属性用于指定背景图片在元素盒子模型中的哪些区域被剪切</p><h1 id="CSS3变形简介"><a href="#CSS3变形简介" class="headerlink" title="CSS3变形简介"></a>CSS3变形简介</h1><p>transform属性的变形方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>translate()</td><td>平移</td></tr><tr><td>scale()</td><td>缩放</td></tr><tr><td>skew()</td><td>倾斜</td></tr><tr><td>rotate()</td><td>旋转</td></tr></tbody></table><h2 id="平移translate"><a href="#平移translate" class="headerlink" title="平移translate()"></a>平移translate()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transform: translateX(x); /*沿X轴方向平移*/</span><br><span class="line">transform: translateY(y); /*沿Y轴方向平移*/</span><br><span class="line">transform: translate(x, y); /*沿X轴和Y轴同时平移*/</span><br></pre></td></tr></table></figure><h2 id="缩放scale"><a href="#缩放scale" class="headerlink" title="缩放scale"></a>缩放scale</h2><p>使用transform属性的scale()方法来实现元素的缩放效果。缩放，指的是“缩小”和“放大”的意思</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transform: scaleX(x); /*沿X轴方向缩放*/ </span><br><span class="line">transform: scaleY(y); /*沿Y轴方向缩放*/ </span><br><span class="line">transform: scale(x, y); /*沿X轴和Y轴同时缩放*/</span><br></pre></td></tr></table></figure><p>当x或y取值为0~1之间时，元素进行缩小；当x或y取值大于1时，元素进行放大</p><h2 id="倾斜：skew"><a href="#倾斜：skew" class="headerlink" title="倾斜：skew()"></a>倾斜：skew()</h2><p>使用transform属性的skew()方法来实现元素的倾斜效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transform: skewX(x); /*沿X轴方向倾斜*/ </span><br><span class="line">transform: skewY(y); /*沿Y轴方向倾斜*/ </span><br><span class="line">transform: skew(x, y); /*沿X轴和Y轴同时倾斜*/</span><br></pre></td></tr></table></figure><p>参数x表示元素在x轴方向的倾斜度数，单位为deg（即degree的缩写）。如果度数为正，则表示元素沿x轴方向逆时针倾斜；如果度数为负，则表示元素沿x轴方向顺时针倾斜</p><p>参数y表示元素在y轴方向的倾斜度数，单位为deg。如果度数为正，则表示元素沿y轴方向顺时针倾斜；如果度数为负，则表示元素沿y轴方向逆时针倾斜</p><h2 id="旋转：rotate"><a href="#旋转：rotate" class="headerlink" title="旋转：rotate()"></a>旋转：rotate()</h2><p>使用transform属性的rotate()方法来实现元素的旋转效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: rotate(angle);</span><br></pre></td></tr></table></figure><p>参数angle表示元素相对于中心原点旋转的度数，单位为deg。如果度数为正，则表示顺时针旋转；如果度数为负，则表示逆时针旋转</p><h2 id="中心原点：transform-origin"><a href="#中心原点：transform-origin" class="headerlink" title="中心原点：transform-origin"></a>中心原点：transform-origin</h2><p>在CSS3变形中，任何元素都有一个中心原点。默认情况下，元素的中心原点位于x轴和y轴的50%处，如下图所示</p><p>默认情况下，CSS3的各种变形（平移、缩放、倾斜等）都是以元素的中心原点进行变形的。假如我们想要使得变形的中心原点不是原来的中心位置，该怎么办呢？</p><p>在CSS3中，我们可以使用transform-origin属性来改变元素的中心原点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform-origin: 取值;</span><br></pre></td></tr></table></figure><p>transform-origin属性取值有两种：一种是“长度值”；另外一种是“关键字”。当取值为长度值时，单位可以为px、em和百分比等。当取值为关键字时，这个跟background-position属性取值是相似的，如下表所示。</p><table><thead><tr><th>关键字</th><th>百分比</th><th>说明</th></tr></thead><tbody><tr><td>top left</td><td>0 0</td><td>左上</td></tr><tr><td>top center</td><td>50% 0</td><td>靠上居中</td></tr><tr><td>top right</td><td>100% 0</td><td>右上</td></tr><tr><td>left center</td><td>0 50%</td><td>靠左居中</td></tr><tr><td>center center</td><td>50% 50%</td><td>正中</td></tr><tr><td>right center</td><td>100% 50%</td><td>靠右居中</td></tr><tr><td>bottom left</td><td>0 100%</td><td>左下</td></tr><tr><td>bottom center</td><td>50% 100%</td><td>靠下居中</td></tr><tr><td>bottom right</td><td>100% 100%</td><td>右下</td></tr></tbody></table><h1 id="CSS3过渡简介"><a href="#CSS3过渡简介" class="headerlink" title="CSS3过渡简介"></a>CSS3过渡简介</h1><p>使用transition属性来将元素的某一个属性从“<strong>一个属性值</strong>”在指定的时间内平滑地过渡到“<strong>另一个属性值</strong>”，从而来实现动画效果</p><p>CSS变形（transform）呈现的仅仅是一个“结果”，而CSS过渡（transition）呈现的是一个“<strong>过程</strong>”。这个所谓的“过程”，通俗来说就是一种动画变化过程，如渐渐显示、渐渐隐藏、动画快慢等。绿叶学习网中很多地方都用到了CSS3过渡，当鼠标移到元素上时，都会有一定的过渡效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition: 过渡属性 过渡时间 过渡方式 延迟时间;</span><br></pre></td></tr></table></figure><p>transition是一个复合属性，主要包括4个子属性，如下表所示。</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>transition-property</td><td>对元素的哪一个属性进行操作</td></tr><tr><td>transition-duration</td><td>过渡的持续时间</td></tr><tr><td>transition-timing-function</td><td>过渡的速率方式</td></tr><tr><td>transition-delay</td><td>过渡的延迟时间（可选参数）</td></tr></tbody></table><h2 id="过渡属性：transition-property"><a href="#过渡属性：transition-property" class="headerlink" title="过渡属性：transition-property"></a>过渡属性：transition-property</h2><p>使用transition-property属性来定义过渡效果操作的是哪一个属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition-property: 取值;</span><br></pre></td></tr></table></figure><p>transition-property属性取值是“CSS属性”</p><p>可以使用 all 使所有属性一起变化；</p><h2 id="过渡时间：transition-duration"><a href="#过渡时间：transition-duration" class="headerlink" title="过渡时间：transition-duration"></a>过渡时间：transition-duration</h2><p>使用transition-duration属性来定义过渡的持续时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition-duration: 时间;</span><br></pre></td></tr></table></figure><p>transition-duration属性取值是一个时间，单位为秒（s），可以取小数</p><h2 id="过渡方式：transition-timing-function"><a href="#过渡方式：transition-timing-function" class="headerlink" title="过渡方式：transition-timing-function"></a>过渡方式：transition-timing-function</h2><p>使用transition-timing-function属性来定义过渡方式。所谓“过渡方式”，指的是动画在过渡时间内的速率变化方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition-timing-function: 取值;</span><br></pre></td></tr></table></figure><p>transition-timing-function属性取值共有5种，如下表所示</p><table><thead><tr><th>ease</th><th>默认值，由快到慢，逐渐变慢</th></tr></thead></table><table><thead><tr><th>linear</th><th>匀速</th></tr></thead></table><table><thead><tr><th>ease-in</th><th>速度越来越快（即渐显效果）</th></tr></thead></table><table><thead><tr><th>ease-out</th><th>速度越来越慢（即渐隐效果）</th></tr></thead></table><table><thead><tr><th>ease-in-out</th><th>先加速后减速（即渐显渐隐效果）</th></tr></thead></table><h2 id="延迟时间：transition-delay"><a href="#延迟时间：transition-delay" class="headerlink" title="延迟时间：transition-delay"></a>延迟时间：transition-delay</h2><p>使用transition-delay属性来定义过渡效果的延迟时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition-delay: 时间;</span><br></pre></td></tr></table></figure><p>transition-delay属性取值是一个时间，单位为秒（s），可以是小数，默认值为0s。也就是说，当我们没有定义transition-delay时，过渡效果就没有延迟时间</p><p><strong>技巧</strong></p><ol><li> transition-property取值为all</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transition-property:border-radius,background-color; </span><br><span class="line">transition-duration:1s; </span><br><span class="line">transition-timing-function:linear; </span><br><span class="line">transition-delay: 0s;</span><br><span class="line">等价于</span><br><span class="line">transition:all 1s linear 0s;</span><br></pre></td></tr></table></figure><p>分析：</p><p>我们尝试把transition属性分别写在“普通状态”和“悬浮状态”内，然后对比两种方式，就可以很直观地知道两者的不同了：<strong>移入时效果两者没有区别，但是如果把transition属性写在普通状态内的话，移出时会有过渡效果；如果把transition属性写在悬浮状态内的话，移出时没有过渡效果</strong></p><h1 id="CSS3动画简介"><a href="#CSS3动画简介" class="headerlink" title="CSS3动画简介"></a>CSS3动画简介</h1><ul><li>  （1）对于transition属性来说，它只能将元素的某一个属性从一个属性值过渡到另一个属性值。</li><li>（2）对于animation属性来说，它可以将元素的某一个属性从第1个属性值过渡到第2个属性值，然后还可以继续过渡到第3个属性值，以此类推。</li></ul><p>从上面我们可以清楚地知道：<strong>transition属性（即CSS3过渡）只能实现一次性的动画效果，而animation属性（即CSS3动画）可以实现连续性的动画效果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation: 动画名称 持续时间 动画方式 延迟时间 动画次数 动画方向;</span><br></pre></td></tr></table></figure><p>animation是一个复合属性，主要包括6个子属性，如下表所示</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>animation-name</td><td>对哪一个CSS属性进行操作</td></tr><tr><td>animation-duration</td><td>动画的持续时间</td></tr><tr><td>animation-timing-function</td><td>动画的速率方式</td></tr><tr><td>animation-delay</td><td>动画的延迟时间</td></tr><tr><td>animation-iteration-count</td><td>动画的播放次数</td></tr><tr><td>animation-direction</td><td>动画的播放方向，正向还是反向</td></tr></tbody></table><h2 id="keyframes"><a href="#keyframes" class="headerlink" title="@keyframes"></a><a href="/keyframes%20">@keyframes</a></h2><ul><li>  （1）定义动画。</li><li>  （2）调用动画。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@keyframes 动画名 &#123; </span><br><span class="line">0%&#123;&#125; </span><br><span class="line">…… </span><br><span class="line">100%&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>0%表示动画的开始，100%表示动画的结束，0%和100%是必须的。不过在一个@keyframes规则中，可以由多个百分比组成，每一个百分比都可以定义自身的CSS样式，从而形成一系列的动画效果。</p><p>在使用@keyframes规则时，如果仅仅只有0%和100%这两个百分比的话，此时0%和100%可以使用关键字from和to来代替，其中0%对应from，100%对应to。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@keyframes mycolor &#123; </span><br><span class="line">0%&#123;color:red;&#125; </span><br><span class="line">100%&#123;color:green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"></span><br><span class="line">@keyframes mycolor &#123; </span><br><span class="line">from&#123;color:red;&#125; </span><br><span class="line">to&#123;color:green;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动画名称：animation-name"><a href="#动画名称：animation-name" class="headerlink" title="动画名称：animation-name"></a>动画名称：animation-name</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation-name: 动画名;</span><br></pre></td></tr></table></figure><p>注意，animation-name调用的动画名需要和@keyframes规则定义的动画名完全一致（区分大小写），如果不一致将不会产生任何动画效果</p><h2 id="持续时间：animation-duration"><a href="#持续时间：animation-duration" class="headerlink" title="持续时间：animation-duration"></a>持续时间：animation-duration</h2><p>使用animation-duration属性来定义动画的持续时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation-duration: 时间;</span><br></pre></td></tr></table></figure><p>animation-duration属性取值是一个时间，单位为秒（s），可以是小数</p><h2 id="动画方式：animation-timing-function"><a href="#动画方式：animation-timing-function" class="headerlink" title="动画方式：animation-timing-function"></a>动画方式：animation-timing-function</h2><p>使用animation-timing-function属性来定义动画的动画方式。所谓“动画方式”，指的是动画在过渡时间内的速率变化方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation-timing-function: 取值;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>说明</th><th>速率</th></tr></thead><tbody><tr><td>ease</td><td>默认值，由快到慢，逐渐变慢</td><td><img src></td></tr><tr><td>linear</td><td>匀速</td><td><img src></td></tr><tr><td>ease-in</td><td>速度越来越快（即渐显效果）</td><td><img src></td></tr><tr><td>ease-out</td><td>速度越来越慢（即渐隐效果）</td><td><img src></td></tr><tr><td>ease-in-out</td><td>先加速后减速（即渐显渐隐效果）</td><td><img src></td></tr></tbody></table><h2 id="延迟时间：animation-delay"><a href="#延迟时间：animation-delay" class="headerlink" title="延迟时间：animation-delay"></a>延迟时间：animation-delay</h2><p>使用animation-delay属性来定义动画的延迟时间。CSS3动画的animation-delay属性跟CSS3过渡的transition-delay属性是相似的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation-delay: 时间;</span><br></pre></td></tr></table></figure><p>animation-delay属性取值是一个时间，单位为秒（s），可以为小数，其中默认值为0s。也就是说，当我们没有定义animation-delay时，动画就没有延迟时间</p><h2 id="播放次数：animation-iteration-count"><a href="#播放次数：animation-iteration-count" class="headerlink" title="播放次数：animation-iteration-count"></a>播放次数：animation-iteration-count</h2><p>使用animation-iteration-count属性来定义动画的播放次数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation-iteration-count: 取值;</span><br></pre></td></tr></table></figure><p>animation-iteration-count属性取值有两种：一种是“<strong>正整数</strong>”；另外一种是“<strong>infinite</strong>”。当取值是n（正整数）时，表示动画播放<strong>n</strong>次；当取值为infinite时，表示动画播放<strong>无数次</strong>，也就是循环播放</p><h2 id="播放方向：animation-direction"><a href="#播放方向：animation-direction" class="headerlink" title="播放方向：animation-direction"></a>播放方向：animation-direction</h2><p>使用animation-direction属性来定义动画的播放方向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation-direction: 取值;</span><br></pre></td></tr></table></figure><p>animation-direction属性取值有3个，如下表所示</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>normal</td><td>正方向播放（默认值）</td></tr><tr><td>reverse</td><td>反方向播放</td></tr><tr><td>alternate</td><td>播放次数是奇数时，动画正方向播放；播放次数是偶数时，动画反方向播放</td></tr></tbody></table><h2 id="播放状态：animation-play-state"><a href="#播放状态：animation-play-state" class="headerlink" title="播放状态：animation-play-state"></a>播放状态：animation-play-state</h2><p>使用animation-play-state属性来定义动画的播放状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation-play-state: 取值;</span><br></pre></td></tr></table></figure><p>animation-play-state属性只有2个取值，如下表所示</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>running</td><td>播放（默认值）</td></tr><tr><td>paused</td><td>暂停</td></tr></tbody></table><p>配合js使用实现动画的播放和暂停</p><h1 id="多列布局简介"><a href="#多列布局简介" class="headerlink" title="多列布局简介"></a>多列布局简介</h1><p>多列布局的属性</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>column-count</td><td>列数</td></tr><tr><td>column-width</td><td>每一列的宽度</td></tr><tr><td>column-gap</td><td>两列之间的距离</td></tr><tr><td>column-rule</td><td>两列之间的边框样式</td></tr><tr><td>column-span</td><td>定义跨列样式</td></tr></tbody></table><h2 id="列数：column-count"><a href="#列数：column-count" class="headerlink" title="列数：column-count"></a>列数：column-count</h2><p>使用column-count属性来定义多列布局的列数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column-count: 取值;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>auto</td><td>列数由column-width属性决定（默认值）</td></tr><tr><td>n（正整数）</td><td>自动划分为n列</td></tr></tbody></table><h2 id="列宽：column-width"><a href="#列宽：column-width" class="headerlink" title="列宽：column-width"></a>列宽：column-width</h2><p>使用column-width属性来定义多列布局中每一列的宽度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column-width: 取值：</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>auto</td><td>列数由column-count属性决定（默认值）</td></tr><tr><td>长度值</td><td>单位可以为px、em和百分比等</td></tr></tbody></table><h2 id="间距：column-gap"><a href="#间距：column-gap" class="headerlink" title="间距：column-gap"></a>间距：column-gap</h2><p>使用column-gap属性来定义列与列之间的间距</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column-gap: 取值;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>normal</td><td>浏览器默认长度值</td></tr><tr><td>长度值</td><td>单位可以为px、em和百分比等</td></tr></tbody></table><h2 id="边框：column-rule"><a href="#边框：column-rule" class="headerlink" title="边框：column-rule"></a>边框：column-rule</h2><p>使用column-rule属性来定义列与列之间的边框样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column-rule: width style color;</span><br></pre></td></tr></table></figure><p>column-rule属性跟border属性是非常相似的，它也是一个复合属性，由3个子属性组成。</p><ul><li>  （1）column-rule-width：定义边框的宽度。</li><li>  （2）column-rule-style：定义边框的样式。</li><li>（3）column-rule-color：定义边框的颜色。</li></ul><h2 id="跨列：column-span"><a href="#跨列：column-span" class="headerlink" title="跨列：column-span"></a>跨列：column-span</h2><p>使用column-span属性来实现多列布局的跨列效果。这个属性跟表格中的colspan属性类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column-span: 取值;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>none</td><td>不跨列</td></tr><tr><td>all</td><td>跨所有列（跟none相反）</td></tr></tbody></table><h1 id="滤镜效果简介"><a href="#滤镜效果简介" class="headerlink" title="滤镜效果简介"></a>滤镜效果简介</h1><p>在CSS3中，所有的滤镜效果都是使用filter属性来实现的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter: 取值;</span><br></pre></td></tr></table></figure><p>其中filter属性取值有10种，每一种方法对应一种滤镜效果，如下表所示</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>brightness()</td><td>亮度</td></tr><tr><td>grayscale()</td><td>灰度</td></tr><tr><td>sepia()</td><td>复古</td></tr><tr><td>invert()</td><td>反色</td></tr><tr><td>hue-rotate()</td><td>旋转（色相）</td></tr><tr><td>drop-shadow()</td><td>阴影</td></tr><tr><td>opacity()</td><td>透明度</td></tr><tr><td>blur()</td><td>模糊度</td></tr><tr><td>contrast()</td><td>对比度</td></tr><tr><td>saturate()</td><td>饱和度</td></tr></tbody></table><h2 id="亮度：brightness"><a href="#亮度：brightness" class="headerlink" title="亮度：brightness()"></a>亮度：brightness()</h2><p>使用brightness()方法来实现亮度滤镜效果。亮度滤镜可以减弱或增强图片的亮度.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter: brightness(百分比);</span><br></pre></td></tr></table></figure><p>brightness()方法的取值是一个百分比，其中0%~100%表示减弱图片的亮度，例如0%就是完全黑色。100%以上表示增强图片的亮度，例如200%就是将亮度提高2倍</p><h2 id="灰度：grayscale"><a href="#灰度：grayscale" class="headerlink" title="灰度：grayscale()"></a>灰度：grayscale()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter: grayscale(百分比)</span><br></pre></td></tr></table></figure><p>grayscale()方法的取值是一个百分比，其中0%表示不做任何修改，100%表示完全灰度（即黑白图片）</p><h2 id="复古：sepia"><a href="#复古：sepia" class="headerlink" title="复古：sepia()"></a>复古：sepia()</h2><p>使用sepia()方法用来实现复古滤镜效果。复古滤镜，也叫褐色滤镜</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter: sepia(百分比)</span><br></pre></td></tr></table></figure><p>sepia()方法的取值是一个百分比，取值范围为0%~100%。其中，0%表示没有转换，100%表示复古效果</p><h2 id="反色：invert"><a href="#反色：invert" class="headerlink" title="反色：invert()"></a>反色：invert()</h2><p>invert()方法，是用来实现反色滤镜效果的。反色，指的是将红、绿、蓝3个通道的像素取各自的相反值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter: invert(百分比)</span><br></pre></td></tr></table></figure><p>invert()方法的取值是一个百分比，取值范围为0%~100%。其中，0%表示没有转换，100%表示反转所有颜色</p><h2 id="旋转：hue-rotate"><a href="#旋转：hue-rotate" class="headerlink" title="旋转：hue-rotate()"></a>旋转：hue-rotate()</h2><p>使用hue-rotate()方法来实现色相旋转的滤镜效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter: hue-rotate(度数)</span><br></pre></td></tr></table></figure><p>hue-rotate()方法的取值是一个度数，单位为deg（即degree的缩写）。其中，0deg表示不旋转，360deg表示旋转360°，也就是相当于一个循环</p><h2 id="阴影：drop-shadow"><a href="#阴影：drop-shadow" class="headerlink" title="阴影：drop-shadow()"></a>阴影：drop-shadow()</h2><p>drop-shadow()方法，用来实现阴影滤镜效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter: drop-shadow(x-offset y-offset blur color)</span><br></pre></td></tr></table></figure><p>drop-shadow()方法的参数有4个，每一个参数说明如下。</p><ul><li>  （1）x-offset：定义水平阴影的偏移距离，可以使用负值。由于CSS3采用的是W3C坐标系，因此x-offset取值为正时，向右偏移；取值为负时，向左偏移。</li><li>  （2）y-offset：定义垂直阴影的偏移距离，可以使用负值。由于CSS3采用的是W3C坐标系，因此y-offset取值为正时，向下偏移；取值为负时，向上偏移。</li><li>  （3）blur：定义阴影的模糊半径，只能为正值。</li><li>（4）color：定义阴影的颜色。</li></ul><h2 id="透明度：opacity"><a href="#透明度：opacity" class="headerlink" title="透明度：opacity()"></a>透明度：opacity()</h2><p>使用opacity()方法来实现透明度滤镜效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter: opacity(百分比)</span><br></pre></td></tr></table></figure><p>opacity()方法的取值是一个百分比，取值范围为0%~100%。其中，0%表示完全透明，100%表示完全不透明</p><h2 id="模糊度：blur"><a href="#模糊度：blur" class="headerlink" title="模糊度：blur()"></a>模糊度：blur()</h2><p>使用blur()方法来实现模糊度滤镜效果，也就是“马赛克”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter: blur(像素)</span><br></pre></td></tr></table></figure><h2 id="对比度：contrast"><a href="#对比度：contrast" class="headerlink" title="对比度：contrast()"></a>对比度：contrast()</h2><p>使用contrast()方法来实现对比度滤镜效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter: contrast(百分比)</span><br></pre></td></tr></table></figure><p>contrast()方法的取值是一个百分比。其中，0%~100%表示减弱对比度，例如0%则是灰度图片。100%以上表示增强对比度，例如200%表示增强对比度为原来的2倍</p><h2 id="饱和度：saturate"><a href="#饱和度：saturate" class="headerlink" title="饱和度：saturate()"></a>饱和度：saturate()</h2><p>saturate()方法可以实现饱和度滤镜效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter: saturate(百分比)</span><br></pre></td></tr></table></figure><p>saturate()方法的取值是一个百分比。其中，0%~100%表示减弱饱和度，100%以上表示增强饱和度</p><h2 id="多种滤镜"><a href="#多种滤镜" class="headerlink" title="多种滤镜"></a>多种滤镜</h2><p>在CSS3中，如果想要为某个元素同时定义多种滤镜效果，我们可以将filter属性的取值设置为一个“值列表”的形式来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter: 值列表;</span><br></pre></td></tr></table></figure><p>在值列表中，两个值之间需要用空格隔开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">列子</span><br><span class="line">filter:brightness(120%) contrast(200%) blur(1px);</span><br></pre></td></tr></table></figure><h1 id="弹性盒子模型简介"><a href="#弹性盒子模型简介" class="headerlink" title="弹性盒子模型简介"></a>弹性盒子模型简介</h1><p>为了解决传统布局的死板以及不足，CSS3新增了一种新型的弹性盒子模型。通过弹性盒子模型，我们可以轻松地创建自适应浏览器窗口的“流动布局”以及自适应字体大小的弹性布局，使得响应式布局的实现更加容易</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>flex-grow</td><td>定义子元素的放大比例</td></tr><tr><td>flex-shrink</td><td>定义子元素的缩小比例</td></tr><tr><td>flex-basis</td><td>定义子元素的宽度</td></tr><tr><td>flex</td><td>flex-grow、flex-shrink、flex-basis的复合属性</td></tr><tr><td>flex-direction</td><td>定义子元素的排列方向</td></tr><tr><td>flex-wrap</td><td>定义子元素是单行显示，还是多行显示</td></tr><tr><td>flex-flow</td><td>flex-direction、flex-wrap的复合属性</td></tr><tr><td>order</td><td>定义子元素的排列顺序</td></tr><tr><td>justify-content</td><td>定义子元素在“横轴”上的对齐方式</td></tr><tr><td>align-items</td><td>定义子元素在“纵轴”上的对齐方式</td></tr></tbody></table><h2 id="放大比例：flex-grow"><a href="#放大比例：flex-grow" class="headerlink" title="放大比例：flex-grow"></a>放大比例：flex-grow</h2><p>使用flex-grow属性来定义弹性盒子内部子元素的放大比例。也就是当所有子元素宽度之和小于父元素的宽度时，子元素如何分配父元素的剩余空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-grow: 数值;</span><br></pre></td></tr></table></figure><p>flex-grow属性取值是一个数值，默认值为0。当取值为0时，表示不索取父元素的剩余空间。当取值大于0时，表示索取父元素的剩余空间（即子元素放大）。取值越大，索取得越多。</p><p>举个例子，父元素下有两个子元素：A和 B。其中父元素宽400px，A宽为100px，B宽为200px。那么父元素的剩余空间为400-100-200=100px。</p><ul><li>  （1）如果A和B都不索取，也就是A和B的flex-grow为0，则父元素的剩余空间为100px。</li><li>  （2）如果A索取，B不索取。其中A设置flex-grow:1，那么最终A的宽为100+100=200px，B的宽不变还是200px。</li><li>  （3）·如果A和B同时索取剩余空间，其中A设置flex-grow:1，B设置flex-grow:1，那么最终A的宽为100+100×1/(1+1)=150px，B的宽为200+100×1/(1+1)=250px。</li><li>（4）如果A和B同时索取剩余空间，其中A设置flex-grow:1，B设置flex-grow:3，那么最终A的宽为100+100×1/(1+3)=125px，B的宽为200+100×3/(1+3)=275px。</li></ul><h2 id="缩小比例：flex-shrink"><a href="#缩小比例：flex-shrink" class="headerlink" title="缩小比例：flex-shrink"></a>缩小比例：flex-shrink</h2><p>在CSS3中， flex-shrink属性用于定义弹性盒子内部子元素的缩小比例。也就是当所有子元素宽度之和大于父元素的宽度时，子元素如何缩小自己的宽度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-shrink: 数值;</span><br></pre></td></tr></table></figure><p>flex-shrink属性取值是一个数值，默认值为1。当取值为0时，表示子元素不缩小。当取值大于1时，表示子元素按一定的比例缩小。取值越大，缩小得越厉害。</p><p>举个例子，父元素下有两个子元素：A和 B。其中父元素宽400px，A宽为200px，B宽为300px。那么A和B宽度之和超出父元素宽度为：200+300-400=100px。</p><ul><li>  （1）如果A和B都不缩小，也就是A和B都设置flex-shrink:0，那么会有100px的宽度超出父元素。</li><li>  （2）如果A不缩小，B缩小。其中A设置flex-shrink:0;，B设置flex-shrink:1;（默认值）。那么最终A的宽不变还是200px，B的宽为300-100=200px（自身宽度-超出父元素的宽度）。</li><li>  （3）如果A和B同时缩小，其中A设置flex-shrink:1，B设置flex-shrink:1，那么最终A的宽为200-100×(200×1)/(200×1+300×1)=160px（A自身宽度-A减小的宽度），B的宽为300-100×(300×1)/(200×1+300×1)=240px（B自身宽度-B减小的宽度）。</li><li>（4）如果A和B同时缩小，其中A设置flex-shrink:3，B设置flex-shrink:2，那么最终A的宽为200-100×(200×3)/(200×3+300×2)=150px（A自身宽度-A减小的宽度），B的宽为300-100×(300×2)/(200×3+300×2)=250px（B自身宽度-B减小的宽度）。</li></ul><p>只有当所有子元素宽度之和小于弹性盒子的宽度时，flex-grow才会生效，而此时flex-shrink无效；只有当所有子元素宽度之和大于弹性盒子的宽度时，flex-shrink属性才会生效，而此时flex-grow无效。也就是说，flex-grow和flex-shrink是互斥的，不可能同时生效。</p><ul><li>  （1）对于定义了flex-grow:0或者flex-shrink:0;的子元素，宽度为原来定义的宽度，并且不会参与划分。</li><li>（2）flex-grow的默认值为0，而flex-shrink的默认值为1。</li></ul><p>最后还有一点要特别跟大家说一下，在实际开发中，我们更多的是使用flex-grow属性，很少会用flex-shrink属性</p><h2 id="元素宽度：flex-basis"><a href="#元素宽度：flex-basis" class="headerlink" title="元素宽度：flex-basis"></a>元素宽度：flex-basis</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-basis: 取值;</span><br></pre></td></tr></table></figure><p>flex-basis是针对弹性盒子（父元素）下的子元素而已的，不能用于设置弹性盒子的宽度</p><p>flex-basis等价于width。只不过呢，在使用弹性布局时，虽然flex-basis和width都可以用来设置子元素的宽度，但是我们应该使用flex-basis而不是width，这也是为了更好的语义化</p><h2 id="复合属性：flex"><a href="#复合属性：flex" class="headerlink" title="复合属性：flex"></a>复合属性：flex</h2><p>使用flex属性来同时设置flex-grow、flex-shrink、flex-basis这3个属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex: grow shrink basis;</span><br></pre></td></tr></table></figure><p>参数grow是flex-grow的取值，参数shrink是flex-shrink的取值，参数basis是flex-basis的取值。因此，flex属性的默认值为“0 1 auto”。</p><p>在实际开发中，优先使用flex属性，而不是单独写flex-grow、flex-shrink、flex-basis这3个属性</p><h2 id="排列顺序：order"><a href="#排列顺序：order" class="headerlink" title="排列顺序：order"></a>排列顺序：order</h2><p>使用order属性来定义弹性盒子内部“子元素”的排列顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order:整数</span><br></pre></td></tr></table></figure><p>例如将<br>div1为 order：2<br>div2为 order：3<br>div3为 order：1</p><p><img src></p><h2 id="水平对齐：justify-content"><a href="#水平对齐：justify-content" class="headerlink" title="水平对齐：justify-content"></a>水平对齐：justify-content</h2><p>使用justify-content属性来定义弹性盒子内部子元素在“横轴”上的对齐方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content: 取值;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>flex-start</td><td>所有子元素在左边（默认值）</td></tr><tr><td>center</td><td>所有子元素在中间</td></tr><tr><td>flex-end</td><td>所有子元素在右边</td></tr><tr><td>space-between</td><td>所有子元素平均分布</td></tr><tr><td>space-around</td><td>所有子元素平均分布，但两边留有一定间距</td></tr></tbody></table><h2 id="垂直对齐：align-items"><a href="#垂直对齐：align-items" class="headerlink" title="垂直对齐：align-items"></a>垂直对齐：align-items</h2><p>使用align-items属性来定义弹性盒子内部子元素在“纵轴”上的对齐方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items: 取值;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>flex-start</td><td>所有子元素在上边（默认值）</td></tr><tr><td>center</td><td>所有子元素在中部</td></tr><tr><td>flex-end</td><td>所有子元素在下边</td></tr><tr><td>baseline</td><td>所有子元素在父元素的基线上</td></tr><tr><td>strecth</td><td>拉伸子元素以适应父元素高度</td></tr></tbody></table><h2 id="水平居中和垂直居中"><a href="#水平居中和垂直居中" class="headerlink" title="水平居中和垂直居中"></a>水平居中和垂直居中</h2><p>实现块元素在其父元素的水平居中和垂直居中很简单，只需要在其父元素添加以下代码即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display: flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">align-items: center;</span><br></pre></td></tr></table></figure><h1 id="其他样式"><a href="#其他样式" class="headerlink" title="其他样式"></a>其他样式</h1><h2 id="outline属性"><a href="#outline属性" class="headerlink" title="outline属性"></a>outline属性</h2><p>使用outline属性来定义表单中文本框的轮廓线样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outline: width style color;</span><br></pre></td></tr></table></figure><p>第1个值指的是轮廓线宽度（outline-width），第2个值指的是轮廓线样式（outline-sytle），第3个值指的是轮廓线颜色（outline-color）。</p><p>outline属性跟border属性很相似，我们可以把轮廓线看成是一条特殊的边框来理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">input[type=&quot;text&quot;]:focus</span><br><span class="line">&#123; </span><br><span class="line">outline:1px solid red; </span><br><span class="line">&#125; </span><br><span class="line">&lt;/style&gt; </span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input id=&quot;txt&quot; type=&quot;text&quot;&gt; </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>默认情况下，预览效果如下图所示。</p><p>当我们点击文本框后，此时预览效果如下图所示.</p><p>input[type=“text”]:focus表示定义文本框获取焦点时的样式</p><h2 id="initial取值"><a href="#initial取值" class="headerlink" title="initial取值"></a>initial取值</h2><p>在实际开发中，我们有时需要将某个CSS属性重新设置为它的默认值。大多数情况下，我们都是采用直接给一个值的方式来实现。例如浏览器默认字体颜色为黑色，如果重置color属性为默认值，我们大多数都是使用color:black;。但是很多时候，我们对元素的默认样式并不是特别清楚的，例如p元素默认会有一定的margin，但是我们并不知道默认的margin是多少。</p><p>在CSS3中，我们可以使用“initial”这个值来直接将某个CSS属性重置为它的默认值，并不需要事先这个CSS属性的默认值是多少，因为浏览器会自动设置的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">property: initial;</span><br></pre></td></tr></table></figure><p>property是一个CSS属性名，“property:initial;”表示设置property这个属性的取值为默认值。此外，initial取值可以用于任何HTML元素上的任何CSS属性</p><h2 id="calc-函数"><a href="#calc-函数" class="headerlink" title="calc()函数"></a>calc()函数</h2><p>使用calc()函数通过“计算”的方式来定义某一个属性的取值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">属性: calc(表达式)</span><br></pre></td></tr></table></figure><p>其中，我们可以使用calc()函数以计算的方式给元素的width、margin、padding、font-size等来定义属性值。对于calc()函数，有以下5条运算规则。</p><ul><li>  （1）只能使用加（+）、减（-）、乘（*）和除（/）这4种运算。</li><li>  （2）可以使用px、em、rem、百分比等单位。</li><li>  （3）可以混合使用各种单位进行运算。</li><li>  （4）表达式中有加号（+）和减号（-）时，其前后必须有空格。</li><li>（5）表达式中有乘号（*）和除号（/）时，其前后可以没有空格，但建议保留。</li></ul><p>例：</p><p>设置俩个divwidth都为50%时会出现以下情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.box-left</span><br><span class="line">&#123; </span><br><span class="line">float: left; </span><br><span class="line">width: calc((100% - 1px) / 2); </span><br><span class="line">height: 100%; </span><br><span class="line">border-right:1px solid black;</span><br><span class="line">background-color: lightskyblue; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-right</span><br><span class="line">&#123; </span><br><span class="line">float: right;</span><br><span class="line">width: calc((100% - 1px) / 2);</span><br><span class="line">height: 100%;</span><br><span class="line">background-color: hotpink; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="overflow-x和overflow-y"><a href="#overflow-x和overflow-y" class="headerlink" title="overflow-x和overflow-y"></a>overflow-x和overflow-y</h2><p>overflow-x属性用来定义内容超出元素“宽度”时应该如何处理，而overflow-y属性用来定义内容超出元素“高度”时应该如何处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">overflow-x: 取值;</span><br><span class="line">overflow-y: 取值;</span><br></pre></td></tr></table></figure><p>overflow-x和overflow-y这两个属性都有4种取值，如下表所示。</p><p>overflow-x 属性取值</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>visible</td><td>内容超出时，不剪切内容，也不添加滚动条</td></tr><tr><td>hidden</td><td>内容超出时，剪切内容，但只显示y轴滚动条而不显示x轴滚动条</td></tr><tr><td>scroll</td><td>内容超出时，显示所有滚动条</td></tr><tr><td>auto</td><td>跟scroll效果一样</td></tr></tbody></table><p>overflow-y属性取值</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>visible</td><td>内容超出时，不剪切内容，也不添加滚动条</td></tr><tr><td>hidden</td><td>内容超出时，剪切内容，但只显示x轴滚动条而不显示y轴滚动条</td></tr><tr><td>scroll</td><td>内容超出时，显示所有滚动条</td></tr><tr><td>auto</td><td>跟scroll效果一样</td></tr></tbody></table><p>overflow-x和overflow-y这两个属性的取值效果都是大同小异的，只是在取值为hidden时有细微的区别。</p><p>浏览器预览效果如下图所示。</p><p>当overflow-x取值为hidden时，预览效果如下图所示。</p><p>当overflow-x取值为scroll时，预览效果如下图所示。</p><p>当overflow-x取值为auto时，预览效果如下图所示。</p><h2 id="pointer-events属性"><a href="#pointer-events属性" class="headerlink" title="pointer-events属性"></a>pointer-events属性</h2><p>使用pointer-events属性来定义元素是否禁用鼠标单击事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer-events: 取值;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>auto</td><td>不禁用鼠标单击事件（默认值）</td></tr><tr><td>none</td><td>禁用鼠标单击事件</td></tr></tbody></table><p>在实际开发中，我们可以使用pointer-events: none;来禁用元素的鼠标单击事件，比较常见的用法是获取验证码。当用户单击【获取验证码】按钮后，需要等待若干秒才能再次单击【重发验证码】按钮，如下图所示。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习</title>
      <link href="/2023/03/07/JavaScript%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/03/07/JavaScript%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="负责行为，功能实现"><a href="#负责行为，功能实现" class="headerlink" title="负责行为，功能实现"></a>负责行为，功能实现</h3><p>引入方式</p><ol><li><ol><li> 外部引入</li><li> 内部引入</li></ol></li></ol><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><ol><li><p>document.write（）： 在页面输出一个内容</p></li><li><p>alert（）：弹出一个对话框；</p></li><li><p>window.onload： 页面刷新时执行</p></li><li><p>window.onbeforeunload： 页面关闭是执行： <code>window.onbeforeunload = function(event) &#123; var e = event || window.event; e.returnValue = &quot;要接着学哦！&quot;; &#125;</code></p></li><li><p>.split(“”) 以双引号内的字符为分割，若双引号内无内容，则分割单个字符,split(“分隔符”,n(分割前几个元素));</p></li><li><p>indexOf(“”): 查找某个字符首次出现的位置(返回下标)；</p></li><li><p>lastIndexOf(“”)：某个字符最后一次出现的位置(返回下标);</p></li><li><p>charAt(): 获取字符串中的某一个字符；</p></li><li><p>inNaN(): 非数返回true；</p></li><li><p>.replace(“”,””)：将字符替换为””（只替换第一个）; 若格式为.replace(/字符/g,””)则替换全部改字符; 数组</p></li><li><p>unshift(): 在数组开头添加元素：数组名.unshift(新元素1,…,新元素n)</p></li><li><p>push(): 在数组结尾添加元素；</p></li><li><p>shift(): 删除数组第一个元素；</p></li><li><p>pop(): 删除数组最后一个元素；</p></li><li><p>arr.sort(up)数值按升序排列、sort（down）数组按降序排列；</p></li><li><p>reverse():数组反序；</p></li><li><p>join(“连接符”): 元素之间的连接符;</p></li><li><ol><li> 元素事件绑定</li></ol></li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在javascri中，变量指的是一个可以改变的量。也就是说，变量的值在程序运行过程中是可以改变的。</p><p>命名规制：</p><ol><li><p>变量由字母、下划线、$或数字组成，并且第一个字母必须是“字母、下划线或$”。</p></li><li><p>变量不能是系统关键字和保留字。</p></li></ol><p>变量使用：</p><ol><li><p>变量的声明</p></li><li><p>变量的赋值（var 变量名 = 值 ）</p></li></ol><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>在JavaScript中，常量指的是一个不能改变的量。也就是说， 常量调度指从定义到开始就是固定的，一直到程序结束都不会改变。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>五种：数字、字符串、布尔值、未定义值和空值</p><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><ol><li><p>getElementById(): 通过id来选中元素</p></li><li><p>getElementsByTagName()： 通过标签名来选中元素</p></li><li><p>getElementsByClassName(): 通过class来选中元素</p></li><li><p>querySelector()和querySeleccctorAll(): 前者选中满足条件的第一个元素，后者选中所有满足条件的所有元素; 5. getElementsByName(): 选中name属性相同的元素;</p></li><li><p>document.title和document.body: .</p></li></ol><h3 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h3><ol><li><p>创建元素节点： createElement()</p></li><li><p>创建文本节点: createTextNode()</p></li><li><p>把文本节点插入元素节点（插入到元素末尾）：appendChild()</p></li><li><p>把组装好的元素插入到已有的元素中(): appendChild()</p></li></ol><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><ol><li><p>appendChild(): 把一个新元素插入到父元素的末尾</p></li><li><p>inserBefore(): 把一个元素插入到父元素中某一个指定元素之前；例如A.insertBefore(B,ref)表示在A元素的子元素ref前加入B；</p></li></ol><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><ol><li>removeChild(): 删除父元素中某一个子元素</li></ol><h3 id="复制元素"><a href="#复制元素" class="headerlink" title="复制元素"></a>复制元素</h3><ol><li>cloneNode(): ojb.cloneNode()、ojb表示被复制的元素</li></ol><h3 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h3><ol><li>A.replaceChild(new,old): A表示父元素，new表示新元素，old表示旧子元素；</li></ol><h3 id="HTML属性操作"><a href="#HTML属性操作" class="headerlink" title="HTML属性操作"></a>HTML属性操作</h3><ol><li><p>getAttribute(): 获取元素的某一个属性的值（可以获取自定义属性）</p></li><li><p>setAttribute(): 设置元素的某个属性的值：setAttribute(“attr”,”值”)</p></li><li><p>removeAttribute(): 删除元素的某个属性；</p></li><li><p>hasAttribute(): 判断元素是否含有某个属性,返回布尔值;</p></li><li><p>getComputedStyle():获取CSS属性的取值，getComputedStyle(obj).attr, obj表示DOM对象attr表示CSS属性名，采用驼峰型;</p></li><li><p>obj.style.attr = “值” : 设置一个CSS属性的值</p></li><li><p>obj.style.cssText = “值”；可一次性设置多个CSS属性;</p></li><li><p>obj.parentNode(): 获取某个元素的父元素 9.</p></li></ol><h3 id="鼠标点击事件"><a href="#鼠标点击事件" class="headerlink" title="鼠标点击事件"></a>鼠标点击事件</h3><ol><li><p>onclick： 鼠标单击事件</p></li><li><p>onmouseover： 鼠标移入事件</p></li><li><p>onmouseout： 鼠标移出事件</p></li><li><p>onmousedown： 鼠标按下事件</p></li><li><p>onmouseup： 鼠标松开事件</p></li><li><p>onmusemove： 鼠标移动事件</p></li></ol><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><ol><li><p>键盘按下： onkeydown</p></li><li><p>键盘松开： onkeyup （正则表达式：/^[0-9]*$/;0-9的数字）</p></li></ol><h3 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h3><ol><li><p>onfocus： 获取焦点时触发的事件</p></li><li><p>onblur： 失去焦点时触发的事件</p></li><li><p>focus()跟onfocus是不一样的。focus()是一个方法，仅仅用于让元素获取焦点。而onfocus是一个属性，它是用于事件操作的</p></li><li><p>onselect: 当我们选中“单行文本框”或“多行文本框”中的内容时，就会触发onselect事件</p></li><li><p>select()跟onselect是不一样的。select()是一个方法，仅仅用于全选文本。而onselect是一个属性，它是用于事件操作的。select()和onselect的关系，跟focus()和onfocus的关系是相似的</p></li><li><p>onchange: 常用于具有多个选项的表单元素</p></li></ol><h3 id="编辑事件"><a href="#编辑事件" class="headerlink" title="编辑事件"></a>编辑事件</h3><ol><li><p>oncopy：防止页面内容被复制 document.body.oncopy = function () { return false; }</p></li><li><p>onselectstart ：防止页面内容被选取 document.body.onselectstart = function () { return false; }</p></li><li><p>oncontextmenu：禁止鼠标右键</p></li></ol><h3 id="页面事件"><a href="#页面事件" class="headerlink" title="页面事件"></a>页面事件</h3><ol><li><p>onload表示文档加载完成后再执行的一个事件 window.onload = function(){ …… }</p></li><li><p>onbeforeunload表示离开页面之前触发的一个事件</p></li></ol><h3 id="事件监听器"><a href="#事件监听器" class="headerlink" title="事件监听器"></a>事件监听器</h3><ol><li><p>addEventListener()方法来为一个元素添加事件，我们又称之为“绑定事件”</p></li><li><p>removeEventListener()方法为元素解绑（或解除）某个事件。解绑事件与绑定事件是相反的操作</p></li></ol><p>语法：obj.addEventListener(type , fn , false)</p><p>语法：obj.removeEventListener(type , fn , false);</p><p>obj是一个DOM对象，指的是使用getElementById()、getElementsByTagName()等方法获取到的元素节点。 type是一个字符串，指的是事件类型。例如单击事件用click，鼠标移入用mouseover等。一定要注意，这个事件类型是不需要加上“on”前缀的。 fn是一个函数名，或者一个匿名函数。 false表示事件冒泡阶段调用。对于事件冒泡，我们在JavaScript进阶教程再详细介绍。这里简单了解即可。</p><h3 id="event对象"><a href="#event对象" class="headerlink" title="event对象"></a>event对象</h3><ol><li>通过event对象来获取一个事件的详细信息</li></ol><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>type</td><td>事件类型</td></tr><tr><td>keyCode</td><td>键码值</td></tr><tr><td>shiftKey</td><td>是否按下shift键</td></tr><tr><td>ctrlKey</td><td>是否按下Ctrl键</td></tr><tr><td>altKey</td><td>是否按下Alt键</td></tr><tr><td>—</td><td>—</td></tr><tr><td></td><td></td></tr></tbody></table><p>event.keyCode返回的是一个数值，常用的按键及对应的键码如表所示。</p><table><thead><tr><th>按键</th><th>键码</th></tr></thead><tbody><tr><td>W（上）</td><td>87</td></tr><tr><td>S（下）</td><td>83</td></tr><tr><td>A（左）</td><td>65</td></tr><tr><td>D（右）</td><td>68</td></tr><tr><td>↑</td><td>38</td></tr><tr><td>↓</td><td>40</td></tr><tr><td>←</td><td>37</td></tr><tr><td>→</td><td>39</td></tr></tbody></table><p><strong>window对象简介</strong></p><table><thead><tr><th>子对象</th><th>说明</th></tr></thead><tbody><tr><td>document</td><td>文档对象，用于操作页面元素</td></tr><tr><td>location</td><td>地址对象，用于操作URL地址</td></tr><tr><td>navigator</td><td>浏览器对象，用于获取浏览器版本信息</td></tr><tr><td>history</td><td>历史对象，用于操作浏览历史</td></tr><tr><td>screen</td><td>屏幕对象，用于操作屏幕宽度高度</td></tr></tbody></table><p><strong>window对象常用方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>alert()</td><td>提示对话框</td></tr><tr><td>confirm()</td><td>判断对话框</td></tr><tr><td>prompt()</td><td>输入对话框</td></tr><tr><td>open()</td><td>打开窗口</td></tr><tr><td>close()</td><td>关闭窗口</td></tr><tr><td>setTimeout()</td><td>开启“一次性”定时器</td></tr><tr><td>clearTimeout()</td><td>关闭“一次性”定时器</td></tr><tr><td>setInterval()</td><td>开启“重复性”定时器</td></tr><tr><td>clearInterval()</td><td>关闭“重复性”定时器</td></tr></tbody></table><p><strong>定时器</strong></p><hr><ol><li><p>setTimeout()方法来“一次性”地调用函数；</p></li><li><p>clearTimeout()来取消执行setTimeout()</p></li></ol><p>语法：setTimeout(code, time);</p><p>参数code可以是一段代码，可以是一个函数，也可以是一个函数名。 参数time是时间，单位为毫秒，表示要过多长时间才执行code中的代码。</p><ol start="3"><li><p>setInterval()方法来“重复性”地调用函数</p></li><li><p>clearInterval()来取消执行setInterval()</p></li></ol><p>语法：setInterval(code, time);</p><p>setInterval()跟setTimeout()语法是一样的，唯一不同的是： setTimeout()只执行一次；而setInterval()可以重复执行无数次 例如实现倒计时就是可以使用setInterval() 使用技巧，在使用函数setTimeout前可以先使用clearTimeout来清除定时器累加的bug</p><p><strong>location对象</strong></p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>href</td><td>当前页面地址</td></tr><tr><td>search</td><td>当前页面地址“？”后面的内容</td></tr><tr><td>hash</td><td>当前页面地址“#”后面的内容</td></tr></tbody></table><ol><li>window.location.href =”url” 实现跳转页面； window.location.href可以获取当前页面地址；</li></ol><p><strong>navigatior对象</strong></p><hr><p>window.navigator.userAgent： 用来获取浏览器类型</p><p><strong>document对象</strong></p><hr><p>document对象常用的属性</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>document.title</td><td>获取文档的title</td></tr><tr><td>document.body</td><td>获取文档的body</td></tr><tr><td>document.forms</td><td>获取所有form元素</td></tr><tr><td>document.images</td><td>获取所有img元素</td></tr><tr><td>document.links</td><td>获取所有a元素</td></tr><tr><td>document.cookie</td><td>文档的cookie</td></tr><tr><td>document.URL</td><td>当前文档的URL</td></tr><tr><td>document.referrer</td><td>返回使浏览者到达当前文档的URL</td></tr></tbody></table><p>document对象常用的方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>document.getElementById()</td><td>通过id获取元素</td></tr><tr><td>document.getElementsByTagName()</td><td>通过标签名获取元素</td></tr><tr><td>document.getElementsByClassName()</td><td>通过class获取元素</td></tr><tr><td>document.getElementsByName()</td><td>通过name获取元素</td></tr><tr><td>document.querySelector()</td><td>通过选择器获取元素，只获取第1个</td></tr><tr><td>document.querySelectorAll()</td><td>通过选择器获取元素，获取所有</td></tr><tr><td>document.createElement()</td><td>创建元素节点</td></tr><tr><td>document.createTextNode()</td><td>创建文本节点</td></tr><tr><td>document.write()</td><td>输出内容</td></tr><tr><td>document.writeln()</td><td>输出内容并换行</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络模块封装</title>
      <link href="/2023/03/07/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85/"/>
      <url>/2023/03/07/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="一、主要内容"><a href="#一、主要内容" class="headerlink" title="一、主要内容"></a>一、主要内容</h1><ul><li>  常见的网络请求模块，以及优缺点对比</li><li>  JSONP的原理和封装</li></ul><!----><ul><li><ul><li>  JSONP原理回顾</li><li>  JDONP请求封装</li></ul></li></ul><!----><ul><li>  axios的内容详解</li></ul><!----><ul><li><ul><li>  认识axios网络模块</li><li>  发送基本请求</li><li>  axios创建实例</li><li>  axios拦截器的使用</li></ul></li></ul><h1 id="二、-选择什么网络模块"><a href="#二、-选择什么网络模块" class="headerlink" title="二、 选择什么网络模块"></a>二、 选择什么网络模块</h1><img src="/2023/03/07/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85/a.png" class title="图片"><h2 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1. JSONP"></a>1. JSONP</h2><img src="/2023/03/07/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85/b.png" class title="图片"><img src="/2023/03/07/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85/c.png" class title="图片"><h2 id="2-axios"><a href="#2-axios" class="headerlink" title="2. axios"></a>2. axios</h2><ul><li>  功能特点</li></ul><!----><ul><li><ul><li>  在浏览器中发送XMLHttpRequests请求</li><li>  在node.js中发送http请求</li><li>  支持Promise API</li><li>  拦截请求和响应</li><li>  转换请求和响应数据</li></ul></li></ul><h1 id="三、axiox"><a href="#三、axiox" class="headerlink" title="三、axiox"></a>三、axiox</h1><ul><li>  <strong>支持多种请求方式</strong></li></ul><!----><ul><li><ul><li>  axios(config)</li><li>  axios.request(config)</li><li>  axios.get(url[,config])</li><li>  axios.delete(url[,config])</li><li>  axios.head(url,[data[,config]])</li><li>  axios.put(url[,data[,config]])</li><li>  axios.put(url[,data[,config]])</li><li>  axios.patch(url[,data[,config]])</li></ul></li></ul><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><ul><li>  <strong>npm install axios –save</strong></li></ul><hr><h2 id="2-发送并发请求"><a href="#2-发送并发请求" class="headerlink" title="2. 发送并发请求"></a>2. 发送并发请求</h2><ul><li>  有时候，我们可能需要同时发送两个请求</li></ul><!----><ul><li><ul><li>  使用axios.all，可以放入多个请求的数组</li><li>  axios.all([])返回的结果时一个数组，使用axios.spread可将数组[res1,res2]展开为res1,res2</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">axios.all([axios(&#123;</span><br><span class="line">  url:&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span><br><span class="line">&#125;),axios(&#123;</span><br><span class="line">  url:&#x27;http://123.207.32.32:8000/home/data&#x27;,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: &#x27;sell&#x27;,</span><br><span class="line">    page: 5</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)]).then(axios.spread((res1, res2) =&gt; &#123;</span><br><span class="line">  console.log(res1);</span><br><span class="line">  console.log(res2);</span><br><span class="line">&#125;))</span><br><span class="line">// .then(results =&gt; &#123;</span><br><span class="line">//   console.log(results)</span><br><span class="line">// &#125;)</span><br></pre></td></tr></table></figure><h2 id="3-全局配置"><a href="#3-全局配置" class="headerlink" title="3.全局配置"></a>3.全局配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL = &#x27;http://123.207.32.32:8000&#x27;</span><br><span class="line">axios.defaults.timeout = 5000</span><br></pre></td></tr></table></figure><h3 id="3-1-常见的配置选项"><a href="#3-1-常见的配置选项" class="headerlink" title="3.1 常见的配置选项"></a>3.1 常见的配置选项</h3><ul><li>  请求地址</li></ul><!----><ul><li><ul><li>  <strong>url:’/user’,</strong></li></ul></li></ul><!----><ul><li>  请求类型</li></ul><!----><ul><li><ul><li>  <strong>method：‘get’</strong></li></ul></li></ul><!----><ul><li>  请根路径</li></ul><!----><ul><li><ul><li>  <strong>baseURL ：’http://……….‘</strong></li></ul></li></ul><!----><ul><li>  请求前的数据处理</li></ul><!----><ul><li><ul><li>  <strong>transformRequest:[function(data){}]</strong></li></ul></li></ul><!----><ul><li>  请求后的数据处理</li></ul><!----><ul><li><ul><li>  <strong>transformResponse:[function(data){}]</strong></li></ul></li></ul><!----><ul><li>  自定义的请求头</li></ul><!----><ul><li><ul><li>  <strong>headers:{‘x-Requested-With’:’XMLHttpRequest’}</strong></li></ul></li></ul><!----><ul><li>  URL查询对象</li></ul><!----><ul><li><ul><li>  <strong>params：{id:12}</strong></li></ul></li></ul><img src="/2023/03/07/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85/d.png" class title="图片"><h2 id="4-axios封装"><a href="#4-axios封装" class="headerlink" title="4. axios封装"></a>4. axios封装</h2><h3 id="1-直接使用"><a href="#1-直接使用" class="headerlink" title="1.直接使用"></a>1.直接使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  url: &#x27;http://123.207.32.32:8000/home/multidata&#x27;,</span><br><span class="line">  method: &#x27;get&#x27;</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">axios(&#123;</span><br><span class="line">  url: &#x27;http://123.207.32.32:8000/home/data&#x27;,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: &#x27;pop&#x27;,</span><br><span class="line">    page: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">3. 使用全局的axios和对应的配置在进行网络请求</span><br><span class="line">axios.defaults.baseURL = &#x27;http://123.207.32.32:8000&#x27;</span><br><span class="line">axios.defaults.timeout = 5000</span><br><span class="line"></span><br><span class="line">// 2.axios发送并请求</span><br><span class="line">axios.all([axios(&#123;</span><br><span class="line">  url:&#x27;/home/multidata&#x27;</span><br><span class="line">&#125;),axios(&#123;</span><br><span class="line">  url:&#x27;/home/data&#x27;,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: &#x27;sell&#x27;,</span><br><span class="line">    page: 5</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)]).then(axios.spread((res1, res2) =&gt; &#123;</span><br><span class="line">  console.log(res1);</span><br><span class="line">  console.log(res2);</span><br><span class="line">&#125;))</span><br><span class="line">.then(results =&gt; &#123;</span><br><span class="line">  console.log(results)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">4. 常见对应的axios实例</span><br><span class="line">const instance1 = axios.create(&#123;</span><br><span class="line">  baseURL: &#x27;http://123.207.32.32:8000&#x27;,</span><br><span class="line">  timeout: 5000</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">instance1(&#123;</span><br><span class="line">  url: &#x27;./home/multidata&#x27;,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: &#x27;pop&#x27;,</span><br><span class="line">    page: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const instance2 = axios.create(&#123;</span><br><span class="line">  baseURL: &#x27;http://123.207.32.32:8000&#x27;,</span><br><span class="line">  timeout: 10000,</span><br><span class="line">  // headers:&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">instance2(&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-封装"><a href="#2-封装" class="headerlink" title="2. 封装"></a>2. 封装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line"></span><br><span class="line">// export function request(config, success, failure) &#123;</span><br><span class="line">//   // 1.创建axios的实例</span><br><span class="line">//   const instance = axios.create(&#123;</span><br><span class="line">//     baseURL: &#x27;http://123.207.32.32:8000&#x27;,</span><br><span class="line">//     timeout: 5000,</span><br><span class="line">//   &#125;)</span><br><span class="line"></span><br><span class="line">//   // 发送真正的网络请求</span><br><span class="line">//   instance(config)</span><br><span class="line">//   .then(res =&gt; &#123;</span><br><span class="line">//     // console.log(res)</span><br><span class="line">//     success(res)</span><br><span class="line">//   &#125;)</span><br><span class="line">//   .catch(err =&gt; &#123;</span><br><span class="line">//     // console.log(&#x27;err&#x27;)</span><br><span class="line">//     failure(err)</span><br><span class="line">//   &#125;)</span><br><span class="line">// &#125;</span><br><span class="line">// export function instance1() &#123;</span><br><span class="line"></span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// export function request(config) &#123;</span><br><span class="line">//   return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">//     // 1. 创建axios的实例</span><br><span class="line">//     const instance = axios.create(&#123;</span><br><span class="line">//       baseURL: &#x27;http://123.207.32.32:8000&#x27;,</span><br><span class="line">//       timeout: 5000</span><br><span class="line">//     &#125;)</span><br><span class="line"></span><br><span class="line">//     // 发送真正的网络请求</span><br><span class="line">//     instance(config)</span><br><span class="line">//     .then(res =&gt; &#123;</span><br><span class="line">//       resolve(res)</span><br><span class="line">//     &#125;)</span><br><span class="line">//     .catch(err =&gt; &#123;</span><br><span class="line">//       reject(err)</span><br><span class="line">//     &#125;)</span><br><span class="line">//   &#125;)</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export function request(config) &#123;</span><br><span class="line">    // 1. 创建axios的实例</span><br><span class="line">    const instance = axios.create(&#123;</span><br><span class="line">      baseURL: &#x27;http://123.207.32.32:8000&#x27;,</span><br><span class="line">      timeout: 5000</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 发送真正的网络请求</span><br><span class="line">    return instance(config)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 5.封装request模块</span><br><span class="line">import &#123;request&#125; from &#x27;./network/request&#x27;</span><br><span class="line"></span><br><span class="line">// request(&#123;</span><br><span class="line">//   url: &#x27;/home/multidata&#x27;</span><br><span class="line">// &#125;), res =&gt; &#123;</span><br><span class="line">//   console.log(res);</span><br><span class="line">// &#125;, err =&gt; &#123;</span><br><span class="line">//   console.log(err)</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">  url: &#x27;/home/multidata&#x27;</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">  console.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="5-拦截器"><a href="#5-拦截器" class="headerlink" title="5. 拦截器"></a>5. 拦截器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 2. axios的拦截器</span><br><span class="line">    // 2.1.请求拦截</span><br><span class="line">    instance.interceptors.request.use(config =&gt; &#123;</span><br><span class="line">      console.log(config);</span><br><span class="line">      return config</span><br><span class="line">      // 1.比如config中的一些信息不符合服务器的要求</span><br><span class="line"></span><br><span class="line">      // 2.比如每次发送网络请求时，在页面显示一个请求图标</span><br><span class="line"></span><br><span class="line">      // 3.某些网络请求（比如登录（token）），必须携带一些特殊的信息</span><br><span class="line">    &#125;,err =&gt; &#123;</span><br><span class="line">      console.log(err);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 2.2.响应拦截</span><br><span class="line">    instance.interceptors.response.use(res =&gt; &#123;</span><br><span class="line">      console.log(res);</span><br><span class="line">      return res.data</span><br><span class="line">    &#125;,err =&gt; &#123;</span><br><span class="line">      console.log(err)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Netlify前端自动化部署服务</title>
      <link href="/2023/03/07/Netlify%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/03/07/Netlify%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-首先将项目发布github进行代码管理"><a href="#1-首先将项目发布github进行代码管理" class="headerlink" title="1. 首先将项目发布github进行代码管理"></a>1. 首先将项目发布github进行代码管理</h1><ol start="2"><li>打开Netlify网站</li><li>点击右上方的Log in</li><li>可以通过GitHub账户直接登录</li></ol><ol start="5"><li>登录成功之后来到首页，点击Add new site</li></ol><img src="/2023/03/07/Netlify%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/b.png" class title="图片"><ol start="6"><li>选择Import an existing project</li></ol><img src="/2023/03/07/Netlify%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/c.png" class title="图片"><ol start="7"><li>从GitHub、GitLab或Bitbucket去获取我们的项目代码</li></ol><img src="/2023/03/07/Netlify%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/d.png" class title="图片"><ol start="8"><li>我们以GitHub为例，点击左下角的GitHub，然后选择对应的代码仓库</li></ol><img src="/2023/03/07/Netlify%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/e.png" class title="图片"><ol start="9"><li>接着配置部署设置，配置完成后点击Deploy site</li></ol><img src="/2023/03/07/Netlify%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/f.png" class title="图片"><p>Base directory : 用于链接单存储库或从存储库的子目录构建的站点的可选字段。它指定了我们的构建机器人在开始构建之前更改为的目录。这是我们的构建系统检查依赖项管理文件（如 or ）的地方。如果未设置，则基目录默认为存储库的根目录。package.json.nvmrc</p><p>Build command: 如果您使用的是静态站点生成器或其他构建工具，则应在其中指定要运行的命令以构建站点。例如。构建命令在 Bash shell 中运行，允许您向命令添加与 Bash 兼容的语法。访问框架文档，了解常用工具的典型设置。npm run build</p><p>Publish directory: 包含生成生成的部署就绪 HTML 文件和资产的目录（相对于存储库的根目录）。如果指定了基目录，则应将其包含在发布目录路径中</p><ol start="10"><li>之后返回到该页面，滑到下方可以查看打包进度，待打包完毕，返回上一页，点击网址，即可查看到已经发布的网页了。</li></ol><img src="/2023/03/07/Netlify%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/g.png" class title="图片"><img src="/2023/03/07/Netlify%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/h.png" class title="图片"><p>ps：此时为打包完毕的情况，未打包完毕显示的是Building</p>]]></content>
      
      
      
        <tags>
            
            <tag> Neilify </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack学习</title>
      <link href="/2023/03/06/Webpack%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/03/06/Webpack%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、认识webpack"><a href="#一、认识webpack" class="headerlink" title="一、认识webpack"></a>一、认识webpack</h1><p><strong>从本质上来讲，webpack是一个现代的JavaScript应用的静态</strong> <strong>模块打包</strong> <strong>工具</strong></p><ol><li> webpack其中一个核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系</li><li> 不仅仅是JavaScript文件，CSS、图片、json文件等等再webpack中都可以当作模块来使用。</li></ol><p><strong>打包</strong>：</p><ol><li> 将webpack中的各种资源模块进行打包合并成一个或多个包（Bundle）；</li></ol><!----><ol start="2"><li> 在打包过程中，还可以对资源进行处理，比如压缩图片，将scss转成css，将ES6语法转成ES5语法，将TypeScript转成JavaScript等等。</li></ol><h1 id="二、-和grunt-gulp的对比"><a href="#二、-和grunt-gulp的对比" class="headerlink" title="二、 和grunt/gulp的对比"></a>二、 和grunt/gulp的对比</h1><h2 id="1-grunt-gulp的核心是Task"><a href="#1-grunt-gulp的核心是Task" class="headerlink" title="1. grunt/gulp的核心是Task"></a>1. grunt/gulp的核心是Task</h2><ol><li> 我们可以配置一些列的task，并且定义task要处理的事务（例如ES6、ts转化、图片压缩、scss转成css）</li><li> 之后让grunt/gulp来依次执行这些task，而且让整个流程自动化</li><li> 所以grunt/gulp也被称为前端自动化任务管理工具。</li></ol><h2 id="2-我们来开一个gulo的task"><a href="#2-我们来开一个gulo的task" class="headerlink" title="2. 我们来开一个gulo的task"></a>2. 我们来开一个gulo的task</h2><p>下面的task就是将src下面的所有js文件转成ES5语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const gulp = require(&#x27;gulp&#x27;);</span><br><span class="line">const babel = require(&#x27;gulp-babel&#x27;);</span><br><span class="line"></span><br><span class="line">gulp.task(&#x27;js&#x27;,()=&gt;</span><br><span class="line">          gulp.src(&#x27;src/*.js&#x27;)</span><br><span class="line">            .pipr(babel(&#123;</span><br><span class="line">                presets:[&#x27;es2015&#x27;]</span><br><span class="line">&#125;))</span><br><span class="line">          .pipe(gulp.dest(&#x27;dist&#x27;))</span><br><span class="line">          &#125;;</span><br></pre></td></tr></table></figure><p>并且最终输出到dist文件中</p><h2 id="3-是么时候使用grunt-gulp"><a href="#3-是么时候使用grunt-gulp" class="headerlink" title="3. 是么时候使用grunt/gulp"></a>3. 是么时候使用grunt/gulp</h2><ol><li> 如果你的工程模块依赖非常简单，甚至是没有用到模块化的概念；</li><li> 只需要进行简单的合并、压缩、就使用grunt/gulp即可；</li><li> 但是如果整个项目使用了模块化管理，而且相互依赖非常强，我们就可以使用更加强大的webpack。</li></ol><h2 id="4-grunt-gulp和webpack的不同"><a href="#4-grunt-gulp和webpack的不同" class="headerlink" title="4. grunt/gulp和webpack的不同"></a>4. grunt/gulp和webpack的不同</h2><ol><li> grunt/gulp更加强调的是前端流程的自动化，模块化不是它的核心；</li><li> webpack更加强调模块化开发管理，而文件压缩合并、预处理等功能，就是他附带的功能。</li></ol><h1 id="三、webpack安装"><a href="#三、webpack安装" class="headerlink" title="三、webpack安装"></a>三、webpack安装</h1><ol><li> 依赖node环境</li><li> node环境为了可以正常的执行很多代码，必须其中包含各种依赖各的包</li><li> npm工具：管理这种包</li><li> 安装：npm install webpack@版本 -g （全局）</li><li> 局部安装：npm install webpack@版本 –save-dev</li></ol><h1 id="四、-打包"><a href="#四、-打包" class="headerlink" title="四、 打包"></a>四、 打包</h1><h2 id="1-打包js"><a href="#1-打包js" class="headerlink" title="1. 打包js"></a>1. 打包js</h2><h3 id="1-1基本使用"><a href="#1-1基本使用" class="headerlink" title="1.1基本使用"></a>1.1基本使用</h3><ol><li> webpack会自己处理文件间的依赖</li><li> 配置出口入口</li></ol><p>文件目录  </p><img src="/2023/03/06/Webpack%E5%AD%A6%E4%B9%A0/a.png" class title="文件目录"><ol><li> 创建webpack.config.js文件</li><li> 下载path包：npm install path</li><li> 配置文件webpack.config.js</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#x27;./src/main.js&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">        filename: &#x27;bundle.js&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: /.css$/,</span><br><span class="line">            //css-loader只负着将css文件进行加载</span><br><span class="line">            //style-loader负责将样式添加到DOM中</span><br><span class="line">            use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-ES6转ES5"><a href="#1-2-ES6转ES5" class="headerlink" title="1.2 ES6转ES5"></a>1.2 ES6转ES5</h3><h4 id="1-2-1-ES6语法处理"><a href="#1-2-1-ES6语法处理" class="headerlink" title="1.2.1 ES6语法处理"></a>1.2.1 ES6语法处理</h4><ol><li>使用babel<br> npm install –save-dev babel-loader@版本 babel-core babel-preset-es2015</li><li> 配置webpack,config,js</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /.js$/,</span><br><span class="line">      exclude: /(node_modules|bower_components)/,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: &#x27;babel-loader&#x27;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [&#x27;@babel/preset-env&#x27;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-打包css"><a href="#2-打包css" class="headerlink" title="2. 打包css"></a>2. 打包css</h2><h3 id="2-1-安装loader"><a href="#2-1-安装loader" class="headerlink" title="2.1. 安装loader"></a>2.1. 安装loader</h3><ol><li><ol><li> css-loader: npm install –save-dev css-loader</li><li> style-loader: npm install style-loader –save-dev</li></ol></li></ol><p>删除：npm uninstall style-loader/css-loader</p><h3 id="2-2配置webpack-config-js"><a href="#2-2配置webpack-config-js" class="headerlink" title="2.2配置webpack.config.js"></a>2.2配置webpack.config.js</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /.css$/,</span><br><span class="line">        use: [ &#x27;style-loader&#x27;, &#x27;css-loader&#x27; ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-下载less-loader"><a href="#2-3-下载less-loader" class="headerlink" title="2.3. 下载less-loader"></a>2.3. 下载less-loader</h3><p>安装：npm install –save-dev less-loader less<br>配置：webpack.config.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: /.less$/,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: &quot;style-loader&quot; // creates style nodes from JS strings</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: &quot;css-loader&quot; // translates CSS into CommonJS</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: &quot;less-loader&quot; // compiles Less to CSS</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-打包图片"><a href="#3-打包图片" class="headerlink" title="3. 打包图片"></a>3. 打包图片</h2><h3 id="1-安装url-loader"><a href="#1-安装url-loader" class="headerlink" title="1.安装url-loader"></a>1.安装url-loader</h3><ol><li> 下载对应loader</li><li> 安装：npm install –save-dev url-loader</li><li>用法：url-loader 功能类似于 <a href="https://github.com/webpack-contrib/file-loader">file-loader</a>，但是在文件大小（单位 byte）低于指定的限制时，可以返回一个 DataURL。<br> import img from ‘./image.png’</li><li> 配置webpack.config,js</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /.(png|jpg|gif)$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &#x27;url-loader&#x27;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 8192</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 1. 当加载的图片，小于limit时，会将图片编译成base64字符串形式</p><ol start="2"><li>当加载的图片，大于limit时，需要使用file-loader模块进行加载</li></ol><h3 id="2-file-loader"><a href="#2-file-loader" class="headerlink" title="2. file-loader"></a>2. file-loader</h3><ol><li> 安装：npm install –save-dev file-loader</li><li> 打包后图片打包到dist中，名字、路径改变，加载不出图片</li><li> 解决路径问题</li></ol><p>修改配置：publicPath:’./dist/‘（通过url加载时会在前面加上dist/）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#x27;./src/main.js&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">        filename: &#x27;bundle.js&#x27;,</span><br><span class="line">        publicPath:&#x27;./dist/&#x27;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="3-打包图片路劲和命名"><a href="#3-打包图片路劲和命名" class="headerlink" title="3. 打包图片路劲和命名"></a>3. 打包图片路劲和命名</h3><p>配置webpack.config.js</p><p>1.打包图片命名</p><p>name: ‘img/[name].[hash:8].[ext]’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            test: /.(png|jpg|gif)$/,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: &#x27;url-loader&#x27;,</span><br><span class="line">                //当加载的图片，小于limit时，会将图片编译成base64字符串形式</span><br><span class="line">                //当加载的图片，大于limit时，需要使用file-loader模块进行加载</span><br><span class="line">                options: &#123;</span><br><span class="line">                    limit: 8192,</span><br><span class="line">                    // 打包图片命名</span><br><span class="line">                    name: &#x27;img/[name].[hash:8].[ext]&#x27;</span><br><span class="line">                &#125;,</span><br><span class="line"></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure><h1 id="五、引入vue"><a href="#五、引入vue" class="headerlink" title="五、引入vue"></a>五、引入vue</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//5. 依赖vue文件</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &#x27;你好&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>修改webpack.config,js配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#x27;./src/main.js&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">        filename: &#x27;bundle.js&#x27;,</span><br><span class="line">        publicPath: &#x27;./dist/&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">                test: /.css$/,</span><br><span class="line">                //css-loader只负着将css文件进行加载</span><br><span class="line">                //style-loader负责将样式添加到DOM中</span><br><span class="line">                use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /.less$/,</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: &quot;style-loader&quot; // creates style nodes from JS strings</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;css-loader&quot; // translates CSS into CommonJS</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;less-loader&quot; // compiles Less to CSS</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /.(png|jpg|gif)$/,</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: &#x27;url-loader&#x27;,</span><br><span class="line">                    //当加载的图片，小于limit时，会将图片编译成base64字符串形式</span><br><span class="line">                    //当加载的图片，大于limit时，需要使用file-loader模块进行加载</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        limit: 8192,</span><br><span class="line">                        // 打包图片命名</span><br><span class="line">                        name: &#x27;img/[name].[hash:8].[ext]&#x27;</span><br><span class="line">                    &#125;,</span><br><span class="line"></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /.js$/,</span><br><span class="line">                //exclude:排除</span><br><span class="line">                //include：包含</span><br><span class="line">                exclude: /(node_modules|bower_components)/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &#x27;babel-loader&#x27;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        presets: [&#x27;es2015&#x27;]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        //alias：别名</span><br><span class="line">        //git commit -m &#x27;注释&#x27;</span><br><span class="line">        //git c &#x27;&#x27;</span><br><span class="line">        //给git起别名</span><br><span class="line">        alias: &#123;</span><br><span class="line">            &#x27;vue$&#x27;: &#x27;vue/dist/vue.esm.js&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-vue文件封装处理"><a href="#1-vue文件封装处理" class="headerlink" title="1..vue文件封装处理"></a>1..vue文件封装处理</h2><p>安装：vue-loader以及vue-template-compiler</p><p>npm install vue-loader vue-template-compiler–save-dev</p><p><strong>修改webpack.config.js文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: /.vue$/,</span><br><span class="line">            use: [&#x27;vue-loader&#x27;]</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>创建App.vue文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">    &lt;h2 class=&quot;title&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;Cpn&gt;&lt;/Cpn&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Cpn from &#x27;./Cpn&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name:&quot;App&quot;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        Cpn</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            message: &#x27;你好&#x27;,</span><br><span class="line">            name: &#x27;coderczf&#x27;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        btnClick() &#123;</span><br><span class="line">            this.name = &#x27;我是谁&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    .title&#123;</span><br><span class="line">        color: green;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><strong>修改main.js文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//5. 依赖vue文件</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">//  import App from &#x27;./vue/app.js&#x27;</span><br><span class="line">import App from &#x27;./vue/App.vue&#x27;</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    //有el和tempalte，后者会替换前者</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    template: &#x27;&lt;App/&gt;&#x27;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        App</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>技巧</strong>: 省略后缀</p><p>修改webpack.config.js文件</p><p>extensions: [‘.js’, ‘.vue’, ‘.css’],</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">       extensions: [&#x27;.js&#x27;, &#x27;.vue&#x27;, &#x27;.css&#x27;],</span><br><span class="line">       alias: &#123;</span><br><span class="line">           &#x27;vue$&#x27;: &#x27;vue/dist/vue.esm.js&#x27;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="六、认识plugin"><a href="#六、认识plugin" class="headerlink" title="六、认识plugin"></a>六、认识plugin</h1><h2 id="1-plugin是什么"><a href="#1-plugin是什么" class="headerlink" title="1. plugin是什么"></a>1. plugin是什么</h2><ol><li> plugin是插件的意思，通常是用于对某个现有架构经行扩展</li><li> webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化、文件压缩等等。</li></ol><h2 id="2-loader与plugin的区别"><a href="#2-loader与plugin的区别" class="headerlink" title="2. loader与plugin的区别"></a>2. loader与plugin的区别</h2><ol><li> loader主要用于转换某些类型的模块，它是一个转换器；</li><li> plugin是插件，它是对webpack本身的扩展，是一个扩展器。</li></ol><h2 id="3-plugin的使用过程"><a href="#3-plugin的使用过程" class="headerlink" title="3. plugin的使用过程"></a>3. plugin的使用过程</h2><ol><li> 通过npm安装需要使用的plugin（某些webpack已经内置的插件不需要安装）</li><li> 在webpack.config,js中的plugins中配置插件</li></ol><h2 id="4-添加版权的plugin"><a href="#4-添加版权的plugin" class="headerlink" title="4. 添加版权的plugin"></a>4. 添加版权的plugin</h2><ol><li> 我们先来使用一个简单的插件，为打包的文件添加版权声明</li></ol><!----><ol><li><ol><li> 该插件的名字叫BannerPlugin，属于webpack’自带的插件。</li></ol></li></ol><!----><ol start="2"><li> 按照下面的方式修改webpack.config.js的文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&#x27;webpack&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#x27;./src/main.js&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">        filename: &#x27;bundle.js&#x27;,</span><br><span class="line">        publicPath: &#x27;./dist/&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&#x27;最终版权归czf所有&#x27;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li> 重新打包程序：查看bundle,js文件的头部，看到如下信息</li></ol><h1 id="七、-打包html-js的plugin"><a href="#七、-打包html-js的plugin" class="headerlink" title="七、 打包html/js的plugin"></a>七、 打包html/js的plugin</h1><ol><li> <strong>当需要间index.html文件打包到dist文件中，这个时候就可以使用HtmlWebpackPlugin插件</strong></li></ol><h2 id="7-1-HtmlWebpackPlugin插件作用"><a href="#7-1-HtmlWebpackPlugin插件作用" class="headerlink" title="7.1 HtmlWebpackPlugin插件作用"></a>7.1 HtmlWebpackPlugin插件作用</h2><ol><li> 自动生成一个index.html文件（可以指定模板来生成）</li><li> 将打包的js文件，自动通过script标签插入到body中</li></ol><h2 id="7-2-安装HtmlWebpackPlugin插件"><a href="#7-2-安装HtmlWebpackPlugin插件" class="headerlink" title="7.2 安装HtmlWebpackPlugin插件"></a>7.2 安装HtmlWebpackPlugin插件</h2><p>npm install html-webpack-plugin –save-dev</p><h2 id="7-2-使用"><a href="#7-2-使用" class="headerlink" title="7.2 使用"></a>7.2 使用</h2><ol><li> 修改webpack’.config.js文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line"></span><br><span class="line">   plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&#x27;最终版权归czf所有&#x27;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &#x27;index.html&#x27;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h2 id="7-3-js压缩的plugin"><a href="#7-3-js压缩的plugin" class="headerlink" title="7.3 js压缩的plugin"></a>7.3 js压缩的plugin</h2><ol><li> 对j打包的js文件进行压缩</li><li> 使用第三方插件uglifyjs-webpack-plugin</li></ol><p>npm install uglifyjs-webpack-plugin@版本 –save-dev</p><ol start="3"><li> 修改webpack.config,js文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const uglifyjsPlugin = require(&#x27;uglifyjs-webpack-plugin&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#x27;./src/main.js&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">        filename: &#x27;bundle.js&#x27;,</span><br><span class="line">        // publicPath: &#x27;./dist/&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&#x27;最终版权归czf所有&#x27;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &#x27;index.html&#x27;</span><br><span class="line">        &#125;),</span><br><span class="line">        new uglifyjsPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八、-搭建服务器"><a href="#八、-搭建服务器" class="headerlink" title="八、 搭建服务器"></a>八、 搭建服务器</h1><ol><li> webpack提供了一个可选的本地开发服务器，这个本地服务器基于node,js搭建，内部使用express框架，可以实现我们想要的让浏览器自动刷新显示我们修改后的结果。</li><li> 安装：npm install –save-dev webpack-dev-server</li><li> devserver也是作为webpack中的一个选项，选项本身可以设置如下属性：</li></ol><!----><ol><li><ol><li> contentBase：为哪一个文件夹提供本地服务，默认是根文件夹，</li><li> port：端口号</li><li> inline：页面实时刷新</li><li> historyApiFallback：在SPA页面中，依赖HTML5的history模式</li></ol></li></ol><!----><ol start="4"><li> webpack.config.js文件配置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">  contentBase:&#x27;/dist&#x27;,</span><br><span class="line">    inline:true</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>5.运行执行指令:webpack-dev-server<br>可以修改package-json里设置指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server&quot;</span><br></pre></td></tr></table></figure><h1 id="九、-配置文件分离"><a href="#九、-配置文件分离" class="headerlink" title="九、 配置文件分离"></a>九、 配置文件分离</h1><ol><li> 安装：npm install webpack-merge –save-dev</li><li> 引入依赖</li></ol><p>例：对prod.config,js进行合并</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const uglifyjsPlugin = require(&#x27;uglifyjs-webpack-plugin&#x27;)</span><br><span class="line">const webpackMerge = require(&#x27;webpack-merge&#x27;)</span><br><span class="line">const baseConfig = require(&#x27;./base.config&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = webpackMerge(baseConfig, &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        new uglifyjsPlugin()</span><br><span class="line">    ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="十、打包时出现的一些错误"><a href="#十、打包时出现的一些错误" class="headerlink" title="十、打包时出现的一些错误"></a>十、打包时出现的一些错误</h1><h3 id="1-没有引用对应loader"><a href="#1-没有引用对应loader" class="headerlink" title="1.没有引用对应loader"></a>1.没有引用对应loader</h3><img src="/2023/03/06/Webpack%E5%AD%A6%E4%B9%A0/b.png" class title="没有引用对应loader"><p>解决：下载对应loader包</p><h3 id="2-版本不一致"><a href="#2-版本不一致" class="headerlink" title="2.版本不一致"></a>2.版本不一致</h3><img src="/2023/03/06/Webpack%E5%AD%A6%E4%B9%A0/c.png" class title="版本不一致"><p>解决：安装对应的版本：npm install –save-dev less-loader@版本 less@版本</p><h3 id="3-图片不显示"><a href="#3-图片不显示" class="headerlink" title="3.图片不显示"></a>3.图片不显示</h3><ol><li> 修改路径</li><li> 配置webpack.config.js文件</li></ol><p>publicPath:’./dist/‘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#x27;./src/main.js&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">        filename: &#x27;bundle.js&#x27;,</span><br><span class="line">        publicPath:&#x27;./dist/&#x27;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3初学习</title>
      <link href="/2023/03/06/Vue3%E5%88%9D%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/03/06/Vue3%E5%88%9D%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h2><ul><li><ul><li>  打包大小减少41%</li><li>  初次渲染快55%，更新渲染快133%</li><li>  内存减少54%</li></ul></li></ul><h2 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h2><ul><li><ul><li>  使用Proxy代替defineProperty实现响应式</li><li>  重写虚拟DOM实现和Tree-Shaking（剔除没有用的代码）</li></ul></li></ul><h2 id="3-拥抱TYpeScript"><a href="#3-拥抱TYpeScript" class="headerlink" title="3.拥抱TYpeScript"></a>3.拥抱TYpeScript</h2><ul><li><ul><li>  Vue3可以更好的支持TypeScript</li></ul></li></ul><h2 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h2><ul><li><ul><li>  Composition API（组合API）</li></ul></li></ul><!----><ul><li><ul><li><ul><li>setup配置<ul><li>  ref与reactive</li><li>  watch与watchEffect</li><li>  provide与inject</li><li>  …</li></ul></li></ul></li></ul></li></ul><!----><ul><li><ul><li>  新的内置组件</li></ul></li></ul><!----><ul><li><ul><li><ul><li>Fragment<ul><li>  Teieport</li><li>  Suspense</li></ul></li></ul></li></ul></li></ul><!----><ul><li><ul><li>  其他改变</li></ul></li></ul><!----><ul><li><ul><li><ul><li>新的生命周期钩子<ul><li>  data选项应始终被声明为一个函数</li><li>  移除keyCode支持作为v-on的修饰符</li><li>  …</li></ul></li></ul></li></ul></li></ul><h1 id="二、-创建Vue"><a href="#二、-创建Vue" class="headerlink" title="二、 创建Vue"></a>二、 创建Vue</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//检查版本</span><br><span class="line">vue --version</span><br><span class="line"></span><br><span class="line">//安装</span><br><span class="line">install -g @vue/cli</span><br></pre></td></tr></table></figure><h3 id="1-使用vite创建"><a href="#1-使用vite创建" class="headerlink" title="1. 使用vite创建"></a>1. 使用vite创建</h3><h4 id="1-1简介："><a href="#1-1简介：" class="headerlink" title="1.1简介："></a>1.1简介：</h4><ul><li>  什么式vite？ –新一代前端构建工具</li><li>  优势如下：</li></ul><!----><ul><li><ul><li>  开发环境中，无需打包操作，可快速的冷启动</li><li>  轻量快速的热重载（HMR）</li><li>  真正的按需编译，不再等待整个应用编译完成</li></ul></li></ul><!----><ul><li>  传统构建与vite构建对比图</li></ul><img src="/2023/03/06/Vue3%E5%88%9D%E5%AD%A6%E4%B9%A0/vite1.png" class title="vite构建对比图"><img src="/2023/03/06/Vue3%E5%88%9D%E5%AD%A6%E4%B9%A0/vite2.png" class title="vite构建对比图"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建工程</span><br><span class="line">npm init vite-app &lt;project-name&gt;</span><br><span class="line">// 进入工程目录</span><br><span class="line">cd &lt;project-name&gt;</span><br><span class="line">// 安装依赖</span><br><span class="line">npm i</span><br><span class="line">// 运行</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h1 id="三、常用Composition-Api"><a href="#三、常用Composition-Api" class="headerlink" title="三、常用Composition Api"></a>三、常用Composition Api</h1><h2 id="1-拉开序幕的setup"><a href="#1-拉开序幕的setup" class="headerlink" title="1. 拉开序幕的setup"></a>1. 拉开序幕的setup</h2><ol><li> 理解：Vue3.0中一个新的配置项，值为一个函数；</li><li> setup是所有Composition API（组合API）“表演的舞台”</li><li> 组件中所用到的：数据，方法等等，均要配置在setup中；</li><li> setup函数的两种返回值：</li></ol><!----><ol><li><ol><li> 若放回一个对象，则对象中的属性、方法、在模板中均可直接使用。</li><li> 若放回一个渲染函数：则可以自定义渲染内容</li></ol></li></ol><!----><ol start="5"><li> 注意点：</li></ol><ul><li><ul><li>  尽量不要与Vue2.x配置混用</li></ul></li></ul><!----><ul><li><ul><li><ul><li>Vue2.x配置（data、methods、computed…）中可以访问到setup中的属性、方法。<ul><li>  但在setup中不能访问到Vue2.x配置（data、methods、computed..）</li><li>  如果有重名，setup优先</li></ul></li></ul></li></ul></li></ul><!----><ul><li><ul><li>  setup不能是一个async函数，因为返回值不再是retuen的对象，而是promise，模板看不到return对象中的属性。(后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合)</li></ul></li></ul><h2 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2. ref函数"></a>2. ref函数</h2><ul><li>  作用：定义一个响应式的数据</li><li>  语法：<code>const xxx = ref(initValue)</code></li></ul><!----><ul><li><ul><li>  创建一个包含响应式数据的引用对象（reference对象，简称ref对象）</li><li>  JS中操作数据：<code>xxx.value</code></li><li>  模板中读取数据：不需要.value，直接<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li></ul></li></ul><!----><ul><li>  备注：</li></ul><!----><ul><li><ul><li>  接受的数据可以是：基本类型、也可以是对象类型</li><li>  基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的get与set完成的</li><li>  对象类型的数据：内部“求助”了Vue3.0中的一个函数——<code>reative</code>函数</li></ul></li></ul><h2 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h2><ul><li>  作用：定义一个对象类型的响应式数据（基本类型不要用它，用ref）数组</li><li>  语法：<code>const 代理对象 = reactive（源对象）</code>接收一个对象（或数组），返回一个代理对象（proxy对象）</li><li>  reactive定义的响应式数据是“深层次的”</li><li>  内部基于ES6的Proxy实现，通过代理对象操作源对象内部数据进行操作</li></ul><h2 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h2><ul><li>  从定义数据角度对比：</li></ul><!----><ul><li><ul><li>  ref用来定义： 基本类型数据</li><li>  reactive用来定义：对象（或数组）类型数据</li><li>  备注：ref也可以用来定义对象（或数组）类型数据，它内部会自动通过<code>reactive</code>转为代理对象</li></ul></li></ul><!----><ul><li>  从原理角度对比:</li></ul><!----><ul><li><ul><li>  ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）</li><li>  reactive通过使用Proxy来实现响应式（数据劫持），并通过Reflect操作源对象内部的数据</li></ul></li></ul><!----><ul><li>  从使用角度对比：</li></ul><!----><ul><li><ul><li>  ref定义的数据：操作数据需要<code>.value</code>，读取数据时模板中直接读取不需要<code>.value</code></li><li>  reactive定义的数据：操作数据与读取数据:均不需要<code>.value</code></li></ul></li></ul><h2 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h2><ul><li>  setup执行的时机</li></ul><!----><ul><li><ul><li>  在beforeCreate之前执行一次，this时undefined</li></ul></li></ul><!----><ul><li>  setup的参数</li></ul><!----><ul><li><ul><li>  props：值为对象，包含：组件外部传递过来，且组件内部声明接收了属性</li><li>  context：上下文对象</li></ul></li></ul><!----><ul><li><ul><li><ul><li>attrs：值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性，相当于<code>this.$attrs</code><ul><li>  slots:收到的插槽内容，相当于<code>this.$slots</code></li><li>  emit:分发自定义事件的函数，相当于<code>this.$emit</code></li></ul></li></ul></li></ul></li></ul><h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h3><ul><li>  与Vue2.x中computed配置功能一致</li><li>  写法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reactive, computed &#125; from &#x27;vue&#x27; </span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    let person2 = reactive(&#123;</span><br><span class="line">      firstname: &#x27;张&#x27;,</span><br><span class="line">      lastname:&#x27;三&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    person2.fullname = computed(&#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        return person2.firstname + &#x27;-&#x27; + person2.lastname</span><br><span class="line">      &#125;,</span><br><span class="line">      set(value) &#123;</span><br><span class="line">        const nameArr = value.split(&#x27;-&#x27;)</span><br><span class="line">        person2.firstname = nameArr[0]</span><br><span class="line">        person2.lastname = nameArr[1]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      person2,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h3><ul><li>  与Vue2.x中watch配置功能一致</li><li>  两个小坑“</li></ul><!----><ul><li><ul><li>  监视reactive定义的响应式数据时：oldValue无法准确获取、强制开启了深度监视（deep配置失效）</li><li>  监视reactive定义的响应式数据中某个属性时：deep配置有效</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/watch</span><br><span class="line">  //#region</span><br><span class="line">  let sum = ref(0)</span><br><span class="line">  let msg = ref(&#x27;你好啊&#x27;)</span><br><span class="line">    </span><br><span class="line">  // 情况一：监视ref所定义的一个响应式数据</span><br><span class="line">  // watch(sum,(newValue,oldValue) =&gt; &#123;</span><br><span class="line">  //   console.log(&#x27;sum变了&#x27;,newValue,oldValue)</span><br><span class="line">  // &#125;,&#123;immediate:true&#125;)</span><br><span class="line">  </span><br><span class="line">  // 情况二：监视ref所定义的多个响应式数据</span><br><span class="line">  // watch([sum,msg],(newValue,oldValue) =&gt; &#123;</span><br><span class="line">  //   console.log(&#x27;sum或msg变了&#x27;,newValue,oldValue)</span><br><span class="line">  // &#125;,&#123;immediate:true&#125;)  </span><br><span class="line"></span><br><span class="line">  // 情况三：监视reactive所定义的一个响应式数据，</span><br><span class="line">  // 1.注意：此处无法正确获取oldValue</span><br><span class="line">  // 2.注意：强制开启了深度监视（deep配置无效）</span><br><span class="line"></span><br><span class="line">  // watch(person2,(newValue, oldValue) =&gt; &#123;</span><br><span class="line">  //   console.log(&#x27;person变了&#x27;,newValue,oldValue)</span><br><span class="line">  // &#125;)</span><br><span class="line"></span><br><span class="line">  // 情况四：监视reactive所定义的一个响应式数据中的某个属性</span><br><span class="line">  //   watch(() =&gt; person2.age,(newValue, oldValue) =&gt; &#123;</span><br><span class="line">  //   console.log(&#x27;person的age变了&#x27;,newValue,oldValue)</span><br><span class="line">  // &#125;)</span><br><span class="line"></span><br><span class="line">  // 情况五：监视reactive所定义的一个响应式中的某些属性</span><br><span class="line">  // watch([() =&gt; person2.name,() =&gt; person2.age],(newValue, oldValue) =&gt; &#123;</span><br><span class="line">  //   console.log(&#x27;person的age变了&#x27;,newValue,oldValue)</span><br><span class="line">  // &#125;)</span><br><span class="line"></span><br><span class="line">  //特殊情况： 监视reactive所定义的一个深层次的属性，要开启深度监视</span><br><span class="line">  // watch([() =&gt; person2.name,() =&gt; person2.age],(newValue, oldValue) =&gt; &#123;</span><br><span class="line">  //   console.log(&#x27;person的age变了&#x27;,newValue,oldValue)</span><br><span class="line">  // &#125;)</span><br><span class="line"></span><br><span class="line">  //#endregion</span><br></pre></td></tr></table></figure><h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h3><ul><li>  watch的规则是：既要指明监视的属性，也要指明监视的回调</li><li>  watchEffect的规则是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性</li><li>  watchEffect有点像computed：</li></ul><!----><ul><li><ul><li>  但computed注重的是计算出来的值（回调函数的返回值），所以必须要写返回值</li><li>  而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(() =&gt; &#123;</span><br><span class="line">  const x1 = sum.value</span><br><span class="line">  console.log(&#x27;watchEffect所指定的回调执行了&#x27;,x1)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><ul><li>  1</li><li>  Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有两个被更名：</li></ul><!----><ul><li><ul><li>  beforeDestroy改名为beforeUnmount</li><li>  destroyed改名为unmounted</li></ul></li></ul><!----><ul><li>  Vue3.0也提供了Composition API形式的生命周期钩子，与Vue2.x中钩子对应关系如下：</li></ul><table><thead><tr><th>选项式 API</th><th>Hook inside setup</th></tr></thead><tbody><tr><td>beforeCreate</td><td>Not needed*</td></tr><tr><td>created</td><td>Not needed*</td></tr><tr><td>beforeMount</td><td>onBeforeMount</td></tr><tr><td>mounted</td><td>onMounted</td></tr><tr><td>beforeUpdate</td><td>onBeforeUpdate</td></tr><tr><td>updated</td><td>onUpdated</td></tr><tr><td>beforeUnmount</td><td>onBeforeUnmount</td></tr><tr><td>unmounted</td><td>onUnmounted</td></tr><tr><td>errorCaptured</td><td>onErrorCaptured</td></tr><tr><td>renderTracked</td><td>onRenderTracked</td></tr><tr><td>renderTriggered</td><td>onRenderTriggered</td></tr><tr><td>activated</td><td>onActivated</td></tr><tr><td>deactivated</td><td>onDeactivated</td></tr></tbody></table><h2 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h2><ul><li>  什么是hook？——本质是一个函数，把setup函数中使用的Composition API进行了封装</li><li>  类似于vue2.0中的mixin</li><li>  自定义hook的优势：复用代码，让setup中的逻辑更清楚易懂</li></ul><h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul><li>  作用：创建一个ref对象，其value值指向另一个对象中的某个属性；</li><li>  语法：<code>const name = toRef(person,&#39;name&#39;)</code></li><li>  应用：要将响应式对象中的某个属性单独提供给外部使用时；</li><li>  扩展：<code>toRefs</code>与<code>toRef</code>功能一致，但可以批量创建多个ref对象，语法<code>toRefs(person)</code></li></ul><h1 id="四、-其他Composition-API"><a href="#四、-其他Composition-API" class="headerlink" title="四、 其他Composition API"></a>四、 其他Composition API</h1><h2 id="1-shallowReactive与shallowRef"><a href="#1-shallowReactive与shallowRef" class="headerlink" title="1.shallowReactive与shallowRef"></a>1.shallowReactive与shallowRef</h2><ul><li>  shallowReactive：只处理对象最外层属性的响应式（浅响应式）</li><li>  shallowRef：只处理基本数据类型的响应式，不进行对象的响应式处理</li><li>  什么时候使用?</li></ul><!----><ul><li><ul><li>  如果有一个对象数据，结构比较深，但变化时只是外层属性变化 ===&gt; shallowReactive</li><li>  如果一个对象数据，后续功能不会修改该对象中的属性，而是生成新的对象来替换 ===&gt; shallowRef</li></ul></li></ul><h2 id="2-readonly与shallowReadonly"><a href="#2-readonly与shallowReadonly" class="headerlink" title="2.readonly与shallowReadonly"></a>2.readonly与shallowReadonly</h2><ul><li>  readonly：让一个响应式数据变为只读的（深只读）</li><li>  shallowReadonly：让一个响应式数据变为只读的（钱只读）</li><li>  应用场景：不希望数据被修改</li></ul><h2 id="3-toRaw与markRaw"><a href="#3-toRaw与markRaw" class="headerlink" title="3.toRaw与markRaw"></a>3.toRaw与markRaw</h2><ul><li>  toRaw：</li></ul><!----><ul><li><ul><li>  作用：将一个由<code>reactive</code>生成的响应式对象转为普遍对象</li><li>  使用场景：用于读取响应式对象对应的普遍对象，对这个普遍对象的所以操作，不会引起页面的更新</li></ul></li></ul><!----><ul><li>  markRaw：</li></ul><!----><ul><li><ul><li>  作用：标记一个对象，使其永远不会再成为响应式对象</li><li>  应用场景：</li></ul></li></ul><!----><ul><li><ul><li><ul><li>有些值不应被设置为响应式的，例如复杂的第三方类库等<ul><li>  当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能</li></ul></li></ul></li></ul></li></ul><h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul><li>  作用：创建一个自定义的ref，并对其依赖项跟踪和更新触发进行显示控制</li><li>  实现防抖效果：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;keyWord&quot;&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123;keyWord&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">  import &#123;customRef&#125; from &#x27;vue&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name:&#x27;DemoCustomRef&#x27;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">      function myRef(value,delay) &#123;</span><br><span class="line">        let timer</span><br><span class="line">        return customRef((track, trigger) =&gt; &#123;</span><br><span class="line">          return &#123;</span><br><span class="line">            get() &#123;</span><br><span class="line">              console.log(`有人从myRef这个容器中读取了数据，我把$&#123;value&#125;给他了`)</span><br><span class="line">              track()</span><br><span class="line">              return value</span><br><span class="line">            &#125;,</span><br><span class="line">            set(newValue) &#123;</span><br><span class="line">              console.log(`有人把myRef这个容器中的数据改为了：$&#123;newValue&#125;`)</span><br><span class="line">              clearTimeout(timer)</span><br><span class="line">              timer = setTimeout(() =&gt; &#123;</span><br><span class="line">                value = newValue</span><br><span class="line">                trigger()</span><br><span class="line">              &#125;,delay)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      let keyWord = myRef(&#x27;hello&#x27;,500)</span><br><span class="line"></span><br><span class="line">      return &#123;keyWord&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="5-provide与inject"><a href="#5-provide与inject" class="headerlink" title="5.provide与inject"></a>5.provide与inject</h2><ul><li>  作用：实现祖组件与后代组件间的通信</li><li>  套路：父组件有一个<code>provide</code>选项来提供数据，后代组件有一个<code>inject</code>选项来开始使用这些数据</li><li>  具体写法</li></ul><ol><li> 祖组件中：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setup() &#123;</span><br><span class="line">  ...</span><br><span class="line">  let car = reactive(&#123;</span><br><span class="line">    carnaem:&#x27;奔驰&#x27;,</span><br><span class="line">    carprice: &#x27;40W&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  provide(&#x27;car&#x27;,car) // 给自己的后代组件传递数据</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li> 后代组件中</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">setup() &#123;</span><br><span class="line">    let car = inject(&#x27;car&#x27;)</span><br><span class="line">    return &#123;car&#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul><li>  isRef：检查一个值是否为一个ref对象</li><li>  isReactive：检查一个对象是否是由<code>readonly</code>创建的响应式代理</li><li>  isReadonly：检查一个对象是否是由<code>readonly</code>创建的只读代理</li><li>  isProxy：创建一个对象是否是由<code>reactive</code>或者<code>readonly</code>方法创建的代理</li></ul><h1 id="五、Composition-API的优势"><a href="#五、Composition-API的优势" class="headerlink" title="五、Composition API的优势"></a>五、Composition API的优势</h1><h2 id="1-Options-API存在的问题"><a href="#1-Options-API存在的问题" class="headerlink" title="1.Options API存在的问题"></a>1.Options API存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别再data，methods，computed里修改</p><h2 id="2-Composition-API的优势"><a href="#2-Composition-API的优势" class="headerlink" title="2.Composition API的优势"></a>2.Composition API的优势</h2><p>可以更加优雅的组织代码，函数，让相关功能的代码更加有序的组织再一起</p><h1 id="六、-新的组件"><a href="#六、-新的组件" class="headerlink" title="六、 新的组件"></a>六、 新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul><li>  在Vue2中：组件必须由一个根标签</li><li>  在Vue3中：组件可以没有根标签，内部会将多个标签包含在一个Fragment虚拟元素中</li><li>  好处：减少标签层级，减少内存占有</li></ul><h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul><li>  Teleport是一种能购将我们的组件html结构移动到指定位置的技术</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;button @click=&quot;isShow = true&quot;&gt;点击弹窗&lt;/button&gt;</span><br><span class="line">    &lt;teleport to = &quot;body&quot;&gt;</span><br><span class="line">      &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">          &lt;h3&gt;我是一个弹窗&lt;/h3&gt;</span><br><span class="line">          &lt;h4&gt;我是内容&lt;/h4&gt;</span><br><span class="line">          &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/teleport&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="3-Supense"><a href="#3-Supense" class="headerlink" title="3.Supense"></a>3.Supense</h2><ul><li>  等待异步组件时渲染一些额外内容，让应用有更好的用户体验</li><li>  使用步骤：</li></ul><!----><ul><li><ul><li>  异步引入组件</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;</span><br><span class="line">const Child = defineAsyncComponent(() =&gt; import(&#x27;./DemoSon.vue&#x27;))</span><br></pre></td></tr></table></figure><p>使用Suspense包裹组件，并配置好default与fallback</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;我是子组件&#123;&#123;sum&#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;suspense&gt;</span><br><span class="line">    &lt;template v-slot:default&gt;</span><br><span class="line">        &lt;!-- &lt;demo-son&gt;&lt;/demo-son&gt; --&gt;</span><br><span class="line">        &lt;child&gt;&lt;/child&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;template v-slot:fallback&gt;</span><br><span class="line">      &lt;h3&gt;稍等，加载中...&lt;/h3&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/suspense&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h1 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul><li>  Vue2.x有许多全局API和配置</li></ul><!----><ul><li><ul><li>  例如：注册全局组件、组成全局指令等</li></ul></li></ul><!----><ul><li>  Vue3.0中对这些API做出了调整：</li></ul><!----><ul><li><ul><li>  将全局的API，即：Vue.xxx调整到应用实例（app）上</li></ul></li></ul><table><thead><tr><th>2.x全局API（Vue）</th><th>3.x实例API（app）</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxxx</td></tr><tr><td>Vue.config.productionTip</td><td>移除</td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table><h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul><li>  data选项应始终被声明为一个函数</li><li>  过度类名的更改：</li></ul><!----><ul><li><ul><li>  Vue2.x写法</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.v-enter,</span><br><span class="line">.v-leave-to &#123;</span><br><span class="line"> opacity: 0; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.v-leave,</span><br><span class="line">.v-enter-to &#123;</span><br><span class="line"> opacity: 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ul><li>  Vue3.x写法</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.v-enter-from，</span><br><span class="line">.v-leave-to &#123;</span><br><span class="line">   opacity:0; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.v-leave-from,</span><br><span class="line">.v-enter-to &#123;</span><br><span class="line">   opaciyt: 1; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>  移除keyCode作为v-on的修饰符，同时也不再支持<code>config.keyCodes</code></li><li>  移除<code>v-on.native</code>修饰符</li></ul><!----><ul><li><ul><li>  父组件中绑定事件</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component&gt;</span><br><span class="line">  v-on:close = &quot;handleComponentEvent&quot;</span><br><span class="line">  v-on:click = &quot;handleNativeClickEvent&quot;</span><br><span class="line">&lt;my-component/&gt;</span><br></pre></td></tr></table></figure><ul><li><ul><li>  子组件中声明自定义事件</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   export default &#123;</span><br><span class="line">     emit: [&#x27;close&#x27;, &#x27;click&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>  移除过滤器（filter）</li></ul><!----><ul><li><ul><li>  使用起来不方便，建议直接使用方法调用或计算属性去替换过滤器</li></ul></li></ul><h1 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h1><h2 id="1-文件首行标红"><a href="#1-文件首行标红" class="headerlink" title="1. 文件首行标红"></a>1. 文件首行标红</h2><img src="/2023/03/06/Vue3%E5%88%9D%E5%AD%A6%E4%B9%A0/c.png" class title="文件首行标红">]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js学习</title>
      <link href="/2023/03/05/Node-js%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/03/05/Node-js%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-js基础"><a href="#Node-js基础" class="headerlink" title="Node.js基础"></a>Node.js基础</h1><h2 id="初识-Nodejs"><a href="#初识-Nodejs" class="headerlink" title="初识 Nodejs"></a>初识 Nodejs</h2><p><strong>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine</strong></p><p><strong>Node.js® 是一个基于 Chrome V8 引擎 的 JavaScript 运行时环境</strong></p><ul><li>  基于 <a href="http://www.expressjs.com.cn/">Express 框架(opens new window)</a>，可以快速构建 Web 应用</li><li>  基于 <a href="https://electronjs.org/">Electron 框架(opens new window)</a>，可以构建跨平台的桌面应用</li><li>  基于 <a href="http://restify.com/">restify 框架(opens new window)</a>，可以快速构建 API 接口项目</li><li>  读写和操作数据库、创建实用的命令行工具辅助前端开发、etc…</li></ul><h2 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer 缓冲区"></a>Buffer 缓冲区</h2><p><a href="http://nodejs.cn/api/buffer.html">Buffer 缓冲区文档(opens new window)</a></p><ul><li>  Buffer 的结构与数组类似，操作方法也与数组类似</li><li>  数组不能存储二进制文件，Buffer 是专门存储二进制数据的</li><li>  Buffer 存储的是二进制数据，显示时以 16 进制的形式显示</li><li>  Buffer 每一个元素范围是 00<del>ff，即 0</del>255、00000000~11111111</li><li>  每一个元素占用一个字节内存</li><li>  Buffer 是对底层内存的直接操作，因此大小一旦确定就不能修改</li></ul><p>Buffer 常用方法：</p><ul><li>  Buffer.from(str[, encoding])：将一个字符串转换为 Buffer</li><li>  Buffer.alloc(size)：创建指定大小的 Buffer</li><li>  Buffer.alloUnsafe(size)：创建指定大小的 Buffer，可能包含敏感数据（分配内存时不会清除内存残留的数据）</li><li>  buf.toString()：将 Buffer 数据转为字符串</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;Hello前端&#x27;</span><br><span class="line"></span><br><span class="line">var buf = Buffer.from(str)</span><br><span class="line"></span><br><span class="line">// 占用内存的大小，一个汉字3字节 13</span><br><span class="line">console.log(buf.length)</span><br><span class="line">// 字符串的长度 7</span><br><span class="line">console.log(str.length)</span><br><span class="line">// 8进制输出第一个元素 145</span><br><span class="line">console.log(buf[1].toString(8))</span><br><span class="line"></span><br><span class="line">//创建一个10个字节的buffer</span><br><span class="line">var buf2 = Buffer.alloc(10)</span><br><span class="line">//通过索引，来操作buf中的元素</span><br><span class="line">buf2[0] = 88</span><br><span class="line">buf2[1] = 255</span><br><span class="line">buf2[2] = 0xaa</span><br><span class="line">buf2[3] = 255</span><br><span class="line"></span><br><span class="line">var buf3 = Buffer.allocUnsafe(10)</span><br><span class="line">console.log(buf3)</span><br></pre></td></tr></table></figure><h2 id="fs-文件系统模块"><a href="#fs-文件系统模块" class="headerlink" title="fs 文件系统模块"></a>fs 文件系统模块</h2><ul><li>  fs 模块中所有的操作都有两种形式可供选择:同步和异步</li><li>  同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码</li><li>  异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回</li><li>  实际开发很少用同步方式，因此只介绍异步方式</li></ul><p>打开模式：</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>r</td><td>读取文件，文件不存在抛异常</td></tr><tr><td>r+</td><td>读写文件，文件不存在抛异常</td></tr><tr><td>rs</td><td>同步模式下打开文件用于读取</td></tr><tr><td>rs+</td><td>同步模式下打开文件用于读写</td></tr><tr><td>w</td><td>写文件，不存在则创建，存在则覆盖原有内容</td></tr><tr><td>wx</td><td>写文件，文件存在打开失败</td></tr><tr><td>w+</td><td>读写文件，不存在创建，存在截断</td></tr><tr><td>wx+</td><td>读写，存在打开失败</td></tr><tr><td>a</td><td>追加，不存在创建</td></tr><tr><td>ax</td><td>追加，存在失败</td></tr><tr><td>a+</td><td>追加和读取，不存在创建</td></tr><tr><td>ax+</td><td>追加和读取，存在失败</td></tr></tbody></table><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><h4 id="简单文件读取"><a href="#简单文件读取" class="headerlink" title="简单文件读取"></a>简单文件读取</h4><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(path[, options], callback)</span><br></pre></td></tr></table></figure><ul><li>  path：文件路径</li><li>  options：配置选项，若是字符串则指定编码格式</li></ul><!----><ul><li><ul><li>  encoding：编码格式</li><li>  flag：打开方式</li></ul></li></ul><!----><ul><li>  callback：回调函数</li></ul><!----><ul><li><ul><li>  err：错误信息</li><li>  data：读取的数据，如果未指定编码格式则返回一个 Buffer</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">fs.readFile(&#x27;./files/1.txt&#x27;, &#x27;utf-8&#x27;, function(err, data) =&gt; &#123;</span><br><span class="line">  if(err) &#123;</span><br><span class="line">    return console.log(&#x27;failed!&#x27; + err.message)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#x27;content:&#x27; + data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 复制文件内容</span><br><span class="line">fs.readFile(&quot;C:/Users/笔记.mp3&quot;, function(err, data) &#123;</span><br><span class="line">if(!err) &#123;</span><br><span class="line">console.log(data);</span><br><span class="line">// 将data写入到文件中</span><br><span class="line">fs.writeFile(&quot;C:/Users/hello.jpg&quot;, data, function(err)&#123;</span><br><span class="line">if(!err)&#123;</span><br><span class="line">console.log(&quot;文件写入成功&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; );</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="流式文件读取"><a href="#流式文件读取" class="headerlink" title="流式文件读取"></a>流式文件读取</h4><ul><li>  简单文件读取的方式会一次性读取文件内容到内存中，若文件较大，会占用过多内存影响系统性能，且读取速度慢</li><li>  大文件适合用流式文件读取，它会分多次将文件读取到内存中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">// 创建一个可读流</span><br><span class="line">var rs = fs.createReadStream(&#x27;C:/Users/笔记.mp3&#x27;)</span><br><span class="line">// 创建一个可写流</span><br><span class="line">var ws = fs.createWriteStream(&#x27;a.mp3&#x27;)</span><br><span class="line"></span><br><span class="line">// 监听流的开启和关闭</span><br><span class="line">// 这几个监听不是必须的</span><br><span class="line">rs.once(&#x27;open&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;可读流打开了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.once(&#x27;close&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;可读流关闭了~~&#x27;)</span><br><span class="line">  //数据读取完毕，关闭可写流</span><br><span class="line">  ws.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&#x27;open&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;可写流打开了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&#x27;close&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;可写流关闭了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//要读取一个可读流中的数据，要为可读流绑定一个data事件，data事件绑定完毕自动开始读取数据</span><br><span class="line">rs.on(&#x27;data&#x27;, function (data) &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">  //将读取到的数据写入到可写流中</span><br><span class="line">  ws.write(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简便方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">var rs = fs.createReadStream(&#x27;C:/Users/lilichao/Desktop/笔记.mp3&#x27;)</span><br><span class="line">var ws = fs.createWriteStream(&#x27;b.mp3&#x27;)</span><br><span class="line"></span><br><span class="line">// pipe()可以将可读流中的内容，直接输出到可写流中</span><br><span class="line">rs.pipe(ws)</span><br></pre></td></tr></table></figure><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><h4 id="简单文件写入"><a href="#简单文件写入" class="headerlink" title="简单文件写入"></a>简单文件写入</h4><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(file, data[, options], callback) </span><br></pre></td></tr></table></figure><ul><li>  file：文件路径</li><li>  data：写入内容</li><li>  options：配置选项，包含 encoding, mode, flag；若是字符串则指定编码格式</li><li>  callback：回调函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">fs.writeFile(&#x27;./files/2.txt&#x27;, &#x27;Hello Nodejs&#x27;, function (err) &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    return console.log(&#x27;failed!&#x27; + err.message)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#x27;success!&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.writeFile(&#x27;C:/Users/hello.txt&#x27;, &#x27;通过 writeFile 写入的内容&#x27;, &#123; flag: &#x27;w&#x27; &#125;, function (err) &#123;</span><br><span class="line">  if (!err) &#123;</span><br><span class="line">    console.log(&#x27;写入成功！&#x27;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="流式文件写入"><a href="#流式文件写入" class="headerlink" title="流式文件写入"></a>流式文件写入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 同步、异步、简单文件的写入都不适合大文件的写入，性能较差，容易导致内存溢出</span><br><span class="line">var fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">// 创建一个可写流</span><br><span class="line">var ws = fs.createWriteStream(&#x27;hello3.txt&#x27;)</span><br><span class="line"></span><br><span class="line">ws.once(&#x27;open&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;流打开了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&#x27;close&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;流关闭了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 通过ws向文件中输出内容</span><br><span class="line">ws.write(&#x27;通过可写流写入文件的内容&#x27;)</span><br><span class="line">ws.write(&#x27;1&#x27;)</span><br><span class="line">ws.write(&#x27;2&#x27;)</span><br><span class="line">ws.write(&#x27;3&#x27;)</span><br><span class="line">ws.write(&#x27;4&#x27;)</span><br><span class="line"></span><br><span class="line">// 关闭流</span><br><span class="line">ws.end()</span><br></pre></td></tr></table></figure><h3 id="路径动态拼接问题-dirname"><a href="#路径动态拼接问题-dirname" class="headerlink" title="路径动态拼接问题 __dirname"></a>路径动态拼接问题 __dirname</h3><ul><li>  在使用 fs 模块操作文件时，如果提供的操作路径是以 ./ 或 ../ 开头的相对路径时，容易出现路径动态拼接错误的问题</li><li>  原因：代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径</li><li>  解决方案：在使用 fs 模块操作文件时，直接提供完整的路径，从而防止路径动态拼接的问题</li><li>  __dirname 获取文件所处的绝对路径</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(__dirname + &#x27;/files/1.txt&#x27;, &#x27;utf8&#x27;, function(err, data) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h3><p>验证路径是否存在：</p><ul><li>  fs.exists(path, callback)</li><li>  fs.existsSync(path)</li></ul><p>获取文件信息：</p><ul><li>  fs.stat(path, callback)</li><li>  fs.stat(path)</li></ul><p>删除文件：</p><ul><li>  fs.unlink(path, callback)</li><li>  fs.unlinkSync(path)</li></ul><p>列出文件：</p><ul><li>  fs.readdir(path[,options], callback)</li><li>  fs.readdirSync(path[, options])</li></ul><p>截断文件：</p><ul><li>  fs.truncate(path, len, callback)</li><li>  fs.truncateSync(path, len)</li></ul><p>建立目录：</p><ul><li>  fs.mkdir(path[, mode], callback)</li><li>  fs.mkdirSync(path[, mode])</li></ul><p>删除目录：</p><ul><li>  fs.rmdir(path, callback)</li><li>  fs.rmdirSync(path)</li></ul><p>重命名文件和目录：</p><ul><li>  fs.rename(oldPath, newPath, callback)</li><li>  fs.renameSync(oldPath, newPath)</li></ul><p>监视文件更改：</p><ul><li>  fs.watchFile(filename[, options], listener)</li></ul><h2 id="path-路径模块"><a href="#path-路径模块" class="headerlink" title="path 路径模块"></a>path 路径模块</h2><p>path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。</p><h3 id="路径拼接-path-join"><a href="#路径拼接-path-join" class="headerlink" title="路径拼接 path.join()"></a>路径拼接 path.join()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">// 注意 ../ 会抵消前面的路径</span><br><span class="line">// ./ 会被忽略</span><br><span class="line">const pathStr = path.join(&#x27;/a&#x27;, &#x27;/b/c&#x27;, &#x27;../../&#x27;, &#x27;./d&#x27;, &#x27;e&#x27;)</span><br><span class="line">console.log(pathStr) // \a\d\e</span><br><span class="line"></span><br><span class="line">fs.readFile(path.join(__dirname, &#x27;./files/1.txt&#x27;), &#x27;utf8&#x27;, function (err, dataStr) &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    return console.log(err.message)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="获取路径中文件名-path-basename"><a href="#获取路径中文件名-path-basename" class="headerlink" title="获取路径中文件名 path.basename()"></a>获取路径中文件名 path.basename()</h3><p>使用 path.basename() 方法，可以获取路径中的最后一部分，常通过该方法获取路径中的文件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.basename(path[, ext])</span><br></pre></td></tr></table></figure><ul><li>  path: 文件路径</li><li>  ext: 文件扩展名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">// 定义文件的存放路径</span><br><span class="line">const fpath = &#x27;/a/b/c/index.html&#x27;</span><br><span class="line"></span><br><span class="line">const fullName = path.basename(fpath)</span><br><span class="line">console.log(fullName) // index.html</span><br><span class="line"></span><br><span class="line">const nameWithoutExt = path.basename(fpath, &#x27;.html&#x27;)</span><br><span class="line">console.log(nameWithoutExt) // index</span><br></pre></td></tr></table></figure><h3 id="获取路径中文件扩展名-path-extname"><a href="#获取路径中文件扩展名-path-extname" class="headerlink" title="获取路径中文件扩展名 path.extname()"></a>获取路径中文件扩展名 path.extname()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">const fpath = &#x27;/a/b/c/index.html&#x27;</span><br><span class="line"></span><br><span class="line">const fext = path.extname(fpath)</span><br><span class="line">console.log(fext) // .html</span><br></pre></td></tr></table></figure><h2 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h2><p>http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。</p><h3 id="创建基本-Web-服务器"><a href="#创建基本-Web-服务器" class="headerlink" title="创建基本 Web 服务器"></a>创建基本 Web 服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;)</span><br><span class="line"></span><br><span class="line">// 创建 web 服务器实例</span><br><span class="line">const server = http.createServer()</span><br><span class="line"></span><br><span class="line">// 为服务器实例绑定 request 事件，监听客户端的请求</span><br><span class="line">server.on(&#x27;request&#x27;, function (req, res) &#123;</span><br><span class="line">  const url = req.url</span><br><span class="line">  const method = req.method</span><br><span class="line">  const str = `Your request url is $&#123;url&#125;, and request method is $&#123;method&#125;`</span><br><span class="line">  console.log(str)</span><br><span class="line"></span><br><span class="line">  // 设置 Content-Type 响应头，解决中文乱码的问题</span><br><span class="line">  res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;)</span><br><span class="line">  // 向客户端响应内容</span><br><span class="line">  res.end(str)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(8080, function () &#123;</span><br><span class="line">  console.log(&#x27;server running at http://127.0.0.1:8080&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="实现简陋路由效果"><a href="#实现简陋路由效果" class="headerlink" title="实现简陋路由效果"></a>实现简陋路由效果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;)</span><br><span class="line">const server = http.createServer()</span><br><span class="line"></span><br><span class="line">server.on(&#x27;request&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  const url = req.url</span><br><span class="line">  // 设置默认的响应内容为 404 Not found</span><br><span class="line">  let content = &#x27;&lt;h1&gt;404 Not found!&lt;/h1&gt;&#x27;</span><br><span class="line">  // 判断用户请求的是否为 / 或 /index.html 首页</span><br><span class="line">  // 判断用户请求的是否为 /about.html 关于页面</span><br><span class="line">  if (url === &#x27;/&#x27; || url === &#x27;/index.html&#x27;) &#123;</span><br><span class="line">    content = &#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27;</span><br><span class="line">  &#125; else if (url === &#x27;/about.html&#x27;) &#123;</span><br><span class="line">    content = &#x27;&lt;h1&gt;关于页面&lt;/h1&gt;&#x27;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;)</span><br><span class="line">  res.end(content)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(80, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;server running at http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="模块化概念"><a href="#模块化概念" class="headerlink" title="模块化概念"></a>模块化概念</h3><ul><li>  模块化是指解决一个复杂问题时，自顶向下逐层把系统划分为若干模块的过程，模块是可组合、分解和更换的单元。</li><li>  模块化可提高代码的复用性和可维护性，实现按需加载。</li><li>  模块化规范是对代码进行模块化拆分和组合时需要遵守的规则，如使用何种语法格式引用模块和向外暴露成员。</li></ul><h3 id="Node-js-中模块的分类"><a href="#Node-js-中模块的分类" class="headerlink" title="Node.js 中模块的分类"></a>Node.js 中模块的分类</h3><ul><li>  内置模块</li><li>  自定义模块</li><li>  第三方模块</li></ul><h3 id="Node-js-中的模块作用域"><a href="#Node-js-中的模块作用域" class="headerlink" title="Node.js 中的模块作用域"></a>Node.js 中的模块作用域</h3><ul><li>  和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域</li><li>  防止全局变量污染</li></ul><h3 id="模块作用域的成员"><a href="#模块作用域的成员" class="headerlink" title="模块作用域的成员"></a>模块作用域的成员</h3><ul><li>  自定义模块中都有一个 module 对象，存储了和当前模块有关的信息</li><li>  在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。导入自定义模块时，得到的就是 module.exports 指向的对象。</li><li>  默认情况下，exports 和 module.exports 指向同一个对象。最终共享的结果，以 module.exports 指向的对象为准。</li></ul><h3 id="CommonJS-模块化规范"><a href="#CommonJS-模块化规范" class="headerlink" title="CommonJS 模块化规范"></a>CommonJS 模块化规范</h3><ul><li>  每个模块内部，module 变量代表当前模块</li><li>  module 变量是一个对象，module.exports 是对外的接口</li><li>  加载某个模块即加载该模块的 module.exports 属性</li></ul><h3 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h3><p>模块第一次加载后会被缓存，即多次调用 require() 不会导致模块的代码被执行多次，提高模块加载效率。</p><h4 id="内置模块加载"><a href="#内置模块加载" class="headerlink" title="内置模块加载"></a>内置模块加载</h4><p>内置模块加载优先级最高。</p><h4 id="自定义模块加载"><a href="#自定义模块加载" class="headerlink" title="自定义模块加载"></a>自定义模块加载</h4><p>加载自定义模块时，路径要以 ./ 或 ../ 开头，否则会作为内置模块或第三方模块加载。</p><p>导入自定义模块时，若省略文件扩展名，则 Node.js 会按顺序尝试加载文件：</p><ul><li>  按确切的文件名加载</li><li>  补全 .js 扩展名加载</li><li>  补全 .json 扩展名加载</li><li>  补全 .node 扩展名加载</li><li>  加载失败，终端报错</li></ul><h4 id="第三方模块加载"><a href="#第三方模块加载" class="headerlink" title="第三方模块加载"></a>第三方模块加载</h4><ul><li>  若导入第三方模块， Node.js 会从<strong>当前模块的父目录</strong>开始，尝试从 /node_modules 文件夹中加载第三方模块。</li><li>  如果没有找到对应的第三方模块，则移动到再<strong>上一层父目录</strong>中，进行加载，直到<strong>文件系统的根目录</strong>。</li></ul><p>例如，假设在 C:\Users\itchen\project\foo.js 文件里调用了 require(‘tools’)，则 Node.js 会按以下顺序查找：</p><ul><li>  C:\Users\itchen\project\node_modules\tools</li><li>  C:\Users\itchen\node_modules\tools</li><li>  C:\Users\node_modules\tools</li><li>  C:\node_modules\tools</li></ul><h4 id="目录作为模块加载"><a href="#目录作为模块加载" class="headerlink" title="目录作为模块加载"></a>目录作为模块加载</h4><p>当把目录作为模块标识符进行加载的时候，有三种加载方式：</p><ul><li>  在被加载的目录下查找 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口</li><li>  如果没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。</li><li>如果以上两步都失败了，则Node.js会在终端打印错误消息，报告模板的缺失：Error: Cannot find module ‘xxx</li></ul><h2 id="3-Node-js与包"><a href="#3-Node-js与包" class="headerlink" title="3. Node.js与包"></a>3. Node.js与包</h2><h3 id="解决包下载速度慢的问题"><a href="#解决包下载速度慢的问题" class="headerlink" title="解决包下载速度慢的问题"></a>解决包下载速度慢的问题</h3><h4 id="1-nrm"><a href="#1-nrm" class="headerlink" title="1. nrm"></a>1. nrm</h4><p>为了更方便的切换下包的镜像资源，我们可以安装nrm这个小工具，利用nrm提供的终端命令，可以快速查看和切换下包的镜像资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 下载包</span><br><span class="line">npm i nrm -g</span><br><span class="line">// 查看所有可用的镜像资源</span><br><span class="line">nrm ls</span><br><span class="line">// 讲下包的镜像资源切换为taobao镜像</span><br><span class="line">nrm use taobao</span><br></pre></td></tr></table></figure><h3 id="开发属于自己的包"><a href="#开发属于自己的包" class="headerlink" title="开发属于自己的包"></a>开发属于自己的包</h3><h4 id="1-初始化包的基本结构"><a href="#1-初始化包的基本结构" class="headerlink" title="1. 初始化包的基本结构"></a>1. 初始化包的基本结构</h4><ol><li> 新建itfeng-tools文件夹，作为包的根目录</li><li> 在itfeng-tools文件夹中，新建如下三个文件</li></ol><ul><li>  package.json（包管理配置文件）</li><li>  index.js （包的入口文件）</li><li>  RWADME.md （包的说明文档）</li></ul><h4 id="2-初始化package-json"><a href="#2-初始化package-json" class="headerlink" title="2.初始化package.json"></a>2.初始化package.json</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;itfengzi-tools&quot;, // 包名称 注意包名不能与已经存在的报名重复</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,// 版本</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;, // 入口文件</span><br><span class="line">  &quot;description&quot;: &quot;提供了格式化时间，HTMLEscape相关的功能&quot;, // 包的介绍信息</span><br><span class="line">  &quot;keywords&quot;: [ // 搜索关键字</span><br><span class="line">    &quot;itfengzi&quot;,</span><br><span class="line">    &quot;dateFormat&quot;,</span><br><span class="line">    &quot;escape&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot; // 包遵循的许可协议</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h3><h4 id="1-注册npm账号"><a href="#1-注册npm账号" class="headerlink" title="1. 注册npm账号"></a>1. 注册npm账号</h4><ol><li> 访问<a href="https://www.npmjs.com/">https://www.npmjs.com/</a>网站，点击sign up按钮，进入注册用户界面</li><li> 填写账号相关信息：Full Name、Public Email、Username、Password</li><li> 点击Create an Account按钮，注册账号</li><li> 登录邮箱，点击验证链接，进行账号的验证</li></ol><h4 id="2-登录npm账号"><a href="#2-登录npm账号" class="headerlink" title="2.登录npm账号"></a>2.登录npm账号</h4><p>npm账号注册完成后，可以在终端中执行<code>npm login</code>命令，依次输入用户名、密码、邮箱后，即可登录成功</p><ul><li>  注意：在运行npm login命令之前，必须先把下包的服务器地址切换为npm的官方服务器，否则会导致发布包失败</li><li>  可以使用nrm工具切换下包服务器</li></ul><p><code>nrm use npm</code></p><h4 id="3-把包发布到npm上"><a href="#3-把包发布到npm上" class="headerlink" title="3.把包发布到npm上"></a>3.把包发布到npm上</h4><p>将终端切换到包的根目录之后，运行<code>npm publish</code>命令，即可将包发布到npm上</p><h4 id="4-删除已发布的包"><a href="#4-删除已发布的包" class="headerlink" title="4.删除已发布的包"></a>4.删除已发布的包</h4><p>运行<code>npm unpublish 包名 --force</code>命令，即可从npm删除已发布的包</p><p>注意：</p><ul><li>  npm unpublish 命令只能删除72小时以内发布的包</li><li>  npm unpublish 删除的包，在24小时内不允许重复发布</li><li>  发布包的时候要慎重，尽量不要发布没有意义的包</li></ul><h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><p><a href="https://www.expressjs.com.cn/">官网传送门(opens new window)</a></p><p><strong>基于 Node.js 平台，快速、开放、极简的 Web 开发框架</strong></p><p>Express 是用于快速创建服务器的第三方模块。</p><p>Express的本质：就是一个npm上的第三方包，提供了快速创建Web服务器的便捷方法</p><p>对于前端程序员来说，最常见的两种服务器，分别是：</p><ul><li>  Web网站服务器：专门对外提供Web网页资源的服务器</li><li>  API接口服务器：专门对外提供API接口的服务区</li></ul><p>使用Express，我们可以方便、快速的创建Web网站的服务器或API接口的服务器</p><h2 id="Express-初体验"><a href="#Express-初体验" class="headerlink" title="Express 初体验"></a>Express 初体验</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装 Express：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure><p>创建服务器，监听客户端请求，并返回内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">// 创建 web 服务器</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">// 监听客户端的 GET 和 POST 请求，并向客户端响应具体的内容</span><br><span class="line">app.get(&#x27;/user&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#123; name: &#x27;zs&#x27;, age: 20, gender: &#x27;男&#x27; &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.post(&#x27;/user&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;请求成功&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  // 通过 req.query 可以获取到客户端发送过来的查询参数</span><br><span class="line">  console.log(req.query)</span><br><span class="line">  res.send(req.query)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 这里的 :id 是一个动态的参数</span><br><span class="line">app.get(&#x27;/user/:ids/:username&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  // req.params 是动态匹配到的 URL 参数，默认是一个空对象</span><br><span class="line">  console.log(req.params)</span><br><span class="line">  res.send(req.params)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(80, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;express server running at http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h3><ul><li>  通过 express.static() 方法可创建静态资源服务器，向外开放访问静态资源。</li><li>  Express 在指定的静态目录中查找文件，并对外提供资源的访问路径，存放静态文件的目录名不会出现在 URL 中</li><li>  访问静态资源时，会根据托管顺序查找文件</li><li>  可为静态资源访问路径添加前缀</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(&#x27;public&#x27;))</span><br><span class="line">app.use(express.static(&#x27;files&#x27;))</span><br><span class="line">// 挂载路劲前缀</span><br><span class="line">app.use(&#x27;/bruce&#x27;, express.static(&#x27;bruce&#x27;))</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">可直接访问 public, files 目录下的静态资源</span><br><span class="line">http://localhost:3000/images/bg.jpg</span><br><span class="line">http://localhost:3000/css/style.css</span><br><span class="line">http://localhost:3000/js/login.js</span><br><span class="line"></span><br><span class="line">通过带有 /bruce 前缀的地址访问 bruce 目录下的文件</span><br><span class="line">http://localhost:8080/bruce/images/logo.png</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h3><p>安装nodemon</p><p><code>npm install -g nodemon</code></p><p>可以间node命令替换为nodemon命令，使用nodemon app.js来启动项目，这样启动之后代码被修改之后，会被nodemon监听到，从而实现自动重启项目的效果</p><h2 id="Express-路由"><a href="#Express-路由" class="headerlink" title="Express 路由"></a>Express 路由</h2><p>在express中，路由指的是客户端的请求与服务器处理函数之间的映射关系</p><p>Express中的路由分3部分组成，分别是请求的类型，请求的URL地址、处理函数</p><p><code>app.METHOD(PATH, HANDLER)</code></p><h3 id="路由的概念"><a href="#路由的概念" class="headerlink" title="路由的概念"></a>路由的概念</h3><h4 id="路由的匹配过程"><a href="#路由的匹配过程" class="headerlink" title="路由的匹配过程"></a>路由的匹配过程</h4><p>每当一个请求到服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数</p><p>在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的URL同时匹配成功，则Express会将这次请求，转交给对应的function函数进行处理</p><ul><li>  按照定义的先后顺序进行匹配</li><li>  请求类型和请求的URL同时匹配成功才会调用对应的处理函数</li></ul><h3 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h3><h4 id="路由基本使用"><a href="#路由基本使用" class="headerlink" title="路由基本使用"></a>路由基本使用</h4><p>创建路由模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">// 挂载路由</span><br><span class="line">app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;hello world&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.post(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;Post Request&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(81, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;express server running at http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="模块化路由"><a href="#模块化路由" class="headerlink" title="模块化路由"></a>模块化路由</h4><p>为了方便对路由进行模块化管理，Express不建议将路由直接挂载到app上，而是推荐将路由抽离为单独的模块；</p><ol><li> 创建路由模块对应的.js文件</li><li> 调用exoress.Router()函数创建路由对象</li><li> 向路由对象上挂载具体路由</li><li> 使用module.exports向外共享路由对象</li><li> 使用app.use()函数注册路由模块</li></ol><p>创建路由模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// router.js</span><br><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">// 创建路由对象</span><br><span class="line">const router = express.Router()</span><br><span class="line"></span><br><span class="line">// 挂载具体路由</span><br><span class="line">router.get(&#x27;/user/list&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;Get user list.&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">router.post(&#x27;/user/add&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;Add new user.&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 向外导出路由对象</span><br><span class="line">module.exports = router</span><br></pre></td></tr></table></figure><p>注册路由模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const router = require(&#x27;./router&#x27;)</span><br><span class="line"></span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">// 注册路由模块，添加访问前缀</span><br><span class="line">app.use(&#x27;/api&#x27;, router)</span><br><span class="line"></span><br><span class="line">app.listen(80, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Express-中间件"><a href="#Express-中间件" class="headerlink" title="Express 中间件"></a>Express 中间件</h2><ul><li>  中间件是指流程的中间处理环节</li><li>  服务器收到请求后，可先调用中间件进行预处理</li><li>  中间件是一个函数，包含 req, res, next 三个参数，next() 参数把流转关系转交给下一个中间件或路由</li></ul><p>中间件注意事项；</p><ul><li>  在注册路由之前注册中间件（错误级别中间件除外）</li><li>  当一个请求到达Express的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理</li><li>  中间件函数的形参列表中，必须包含next参数，而路由处理函数中只包含req和res</li><li>  为了防止代码逻辑混乱，调用next()函数数后不再写额外的代码</li><li>  多个中间件共享同一份 req、 res对象，基于这样的特性，我们可以在上游的中间件中，统一为req或res对象添加自定义属性或方法，供下游的中间件或路由进行使用</li></ul><h3 id="全局中间件"><a href="#全局中间件" class="headerlink" title="全局中间件"></a>全局中间件</h3><p>客户端发起的任何请求。到达服务器之后，都会触发的中间件，叫全局生效的中间件</p><ul><li>  通过 app.use() 定义的中间件为全局中间件</li><li>  可以连续定义多个全局中间件，客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">// 定义第一个全局中间件</span><br><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;调用了第1个全局中间件&#x27;)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line">// 定义第二个全局中间件</span><br><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;调用了第2个全局中间件&#x27;)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/user&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;User page.&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(80, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="局部中间件"><a href="#局部中间件" class="headerlink" title="局部中间件"></a>局部中间件</h3><p>不使用app.use()定义的中间件，叫做局部失效的中间件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">// 定义中间件函数</span><br><span class="line">const mw1 = (req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;调用了第一个局部生效的中间件&#x27;)</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mw2 = (req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;调用了第二个局部生效的中间件&#x27;)</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 两种定义局部中间件的方式</span><br><span class="line">app.get(&#x27;/hello&#x27;, mw2, mw1, (req, res) =&gt; res.send(&#x27;hello page.&#x27;))</span><br><span class="line">app.get(&#x27;/about&#x27;, [mw1, mw2], (req, res) =&gt; res.send(&#x27;about page.&#x27;))</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/user&#x27;, (req, res) =&gt; res.send(&#x27;User page.&#x27;))</span><br><span class="line"></span><br><span class="line">app.listen(80, function () &#123;</span><br><span class="line">  console.log(&#x27;Express server running at http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="中间件分类"><a href="#中间件分类" class="headerlink" title="中间件分类"></a>中间件分类</h3><h4 id="应用级别的中间件"><a href="#应用级别的中间件" class="headerlink" title="应用级别的中间件"></a>应用级别的中间件</h4><ul><li>  通过 app.use() 或 app.get() 或 app.post() ，绑定到 app 实例上的中间件</li></ul><h4 id="路由级别的中间件"><a href="#路由级别的中间件" class="headerlink" title="路由级别的中间件"></a>路由级别的中间件</h4><ul><li>  绑定到 express.Router() 实例上的中间件，叫做路由级别的中间件。用法和应用级别中间件没有区别。应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到 router 实例上。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const app = express()</span><br><span class="line">const router = express.Router()</span><br><span class="line"></span><br><span class="line">router.use(function (req, res, next) &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(&#x27;/&#x27;, router)</span><br></pre></td></tr></table></figure><h4 id="错误级别的中间件"><a href="#错误级别的中间件" class="headerlink" title="错误级别的中间件"></a>错误级别的中间件</h4><ul><li>  用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题</li><li>  错误级别中间件的处理函数中，必须有 4 个形参，形参顺序从前到后分别是 (err, req, res, next) 。</li><li>  错误级别的中间件必须注册在所有路由之后</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  throw new Error(&#x27;服务器内部发生了错误！&#x27;)</span><br><span class="line">  res.send(&#x27;Home page.&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 定义错误级别的中间件，捕获整个项目的异常错误，从而防止程序的崩溃</span><br><span class="line">app.use((err, req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;发生了错误！&#x27; + err.message)</span><br><span class="line">  res.send(&#x27;Error：&#x27; + err.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(80, function () &#123;</span><br><span class="line">  console.log(&#x27;Express server running at http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Express-内置中间件"><a href="#Express-内置中间件" class="headerlink" title="Express 内置中间件"></a>Express 内置中间件</h4><p>自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验：</p><ul><li>  express.static 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）</li><li>  express.json 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li><li>  express.urlencoded 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.json())</span><br><span class="line">app.use(express.urlencoded(&#123; extended: false &#125;))</span><br></pre></td></tr></table></figure><h4 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h4><p>非Express官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件，在项目中，可以按需下载并配置第三方中间件，从而提高开发效率；</p><ul><li>  运行<code>npm install body-parser</code>安装中间件</li><li>  使用require导入中间件</li><li>  调用app.use()注册并使用中间件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">const parser = require(&#x27;body-parser&#x27;)</span><br><span class="line"></span><br><span class="line">app.use(parser.urlencoded(&#123; extended: false &#125;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;Home page&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">app.post(&#x27;/user&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  console.log(req.body);</span><br><span class="line">  res.send(&#x27;User page&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(81, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;http://127.0.0.1:81&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h3><p>自定义一个类似express.urlencoded这样的中间件，来解析post提交到服务器的表单数据</p><p>实现步骤：</p><ol><li> 定义中间件</li><li> 监听req的data事件</li><li> 监听req的end事件</li><li> 使用querystring模块解析请求体数据</li><li> 将解析出来的数据对象挂载为req.body</li><li> 将自定义中间件封装为模块</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 导入express模块</span><br><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">// 创建express的服务器实例</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">const customBodyParser = require(&#x27;./10.custom-body-parser&#x27;)</span><br><span class="line"></span><br><span class="line">// 这是解析表单数据的中间件</span><br><span class="line">app.use(customBodyParser)</span><br><span class="line"></span><br><span class="line">app.post(&#x27;/user&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  console.log(req.body);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 调用app.listen方法,指定端口号并启动web服务器</span><br><span class="line">app.listen(81, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;http://127.0.0.1:81&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 导入处理querystring的Node.js内置模块</span><br><span class="line">const qs = require(&#x27;querystring&#x27;)</span><br><span class="line"></span><br><span class="line">// 调用qs.parse()方法，把查询字符串解析为对象</span><br><span class="line">const bodyParser = (req, res, next) =&gt; &#123;</span><br><span class="line">  // 定义一个str字符串，专门用来储存客户端发送过来的请求体数据</span><br><span class="line">  let str = &#x27;&#x27;</span><br><span class="line">  // 监听req的data事件</span><br><span class="line">  req.on(&#x27;data&#x27;, (chunk) =&gt; &#123;</span><br><span class="line">    str += chunk</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // 监听req的end事件</span><br><span class="line">  req.on(&#x27;end&#x27;, () =&gt; &#123;</span><br><span class="line">    // 调用qs.parse()方法，把查询字符串解析为对象</span><br><span class="line">    const body = qs.parse(str)</span><br><span class="line">    // 将解析出来的请求体对象，挂载为req.body属性</span><br><span class="line">    req.body = body</span><br><span class="line">    // 最后调用next()函数。执行后续的业务逻辑</span><br><span class="line">    next()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = bodyParser</span><br></pre></td></tr></table></figure><h2 id="使用Express写接口"><a href="#使用Express写接口" class="headerlink" title="使用Express写接口"></a>使用Express写接口</h2><h3 id="创建基本服务器"><a href="#创建基本服务器" class="headerlink" title="创建基本服务器"></a>创建基本服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">const router = require(&#x27;./12.apiRouter&#x27;)</span><br><span class="line"></span><br><span class="line">app.use(&#x27;/api&#x27;, router)</span><br><span class="line"></span><br><span class="line">app.listen(81, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;http://127.0.0.1:81&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="创建API路由模块"><a href="#创建API路由模块" class="headerlink" title="创建API路由模块"></a>创建API路由模块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const router = express.Router()</span><br><span class="line"></span><br><span class="line">module.express = router</span><br></pre></td></tr></table></figure><h3 id="编写GET接口"><a href="#编写GET接口" class="headerlink" title="编写GET接口"></a>编写GET接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">router.get(&#x27;/get&#x27;, (req, res) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  const query = req.query</span><br><span class="line">  // 调用res.send()方法，向客户端响应结果</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    status: 0, // 0表示处理成功，1表示处理失败</span><br><span class="line">    msg: &#x27;GET 请求成功！&#x27;, // 状态描述</span><br><span class="line">    data: query // 需要响应给客户端的数据</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="编写POST接口"><a href="#编写POST接口" class="headerlink" title="编写POST接口"></a>编写POST接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定义POST接口</span><br><span class="line">router.post(&#x27;/post&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  // 通过req.body获取请求体中包含的url-encoded格式的数据</span><br><span class="line">  const body = req.body</span><br><span class="line">  // 调用res.send()方法，向客户端响应结果</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    status: 0,</span><br><span class="line">    msg: &#x27;POST请求成功&#x27;,</span><br><span class="line">    data: body</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS 跨域资源共享"></a>CORS 跨域资源共享</h3><h4 id="接口的跨域问题"><a href="#接口的跨域问题" class="headerlink" title="接口的跨域问题"></a>接口的跨域问题</h4><p>解决接口跨域的问题的方案主要有两种</p><ul><li>  CORS（主流的解决方案，推荐使用）</li><li>  JSONP（有缺陷的解决方案，只支持GET请求）</li></ul><h4 id="cors-中间件解决跨域"><a href="#cors-中间件解决跨域" class="headerlink" title="cors 中间件解决跨域"></a>cors 中间件解决跨域</h4><ul><li>  安装中间件：<code>npm install cors</code></li><li>  导入中间件：const cors = require(‘cors’)</li><li>  配置中间件：app.use(cors())</li></ul><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><ul><li>  CORS（Cross-Origin Resource Sharing，跨域资源共享）解决跨域，是通过 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获取资源</li><li>  浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头，就可解除浏览器端的跨域访问限制</li><li>  CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。</li><li>  CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。</li></ul><h4 id="CORS-常见响应头"><a href="#CORS-常见响应头" class="headerlink" title="CORS 常见响应头"></a>CORS 常见响应头</h4><ul><li>  Access-Control-Allow-Origin：制定了允许访问资源的外域 URL</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;http://bruceblog.io&#x27;)</span><br><span class="line">res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;)</span><br></pre></td></tr></table></figure><ul><li>  Access-Control-Allow-Headers</li><li>  默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一）</li><li>  如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败！</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;Content-Type, X-Custom-Header&#x27;)</span><br></pre></td></tr></table></figure><ul><li>  Access-Control-Allow-Methods</li><li>  默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods 来指明实际请求所允许使用的 HTTP 方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;POST, GET, DELETE, HEAD&#x27;)</span><br><span class="line">res.setHEader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;*&#x27;)</span><br></pre></td></tr></table></figure><h3 id="CORS-请求分类"><a href="#CORS-请求分类" class="headerlink" title="CORS 请求分类"></a>CORS 请求分类</h3><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><ul><li>  请求方式：GET、POST、HEAD 三者之一</li><li>  HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值 application/x-www-formurlencoded、multipart/form-data、text/plain）</li></ul><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><ul><li>  请求方式为 GET、POST、HEAD 之外的请求 Method 类型</li><li>  请求头中包含自定义头部字段</li><li>  向服务器发送了 application/json 格式的数据</li></ul><p>在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据</p><h4 id="简单请求和预检请求"><a href="#简单请求和预检请求" class="headerlink" title="简单请求和预检请求"></a>简单请求和预检请求</h4><ul><li>  简单请求的特点：客户端与服务器之间只会发送一次请求</li><li>  预检请求的特点：客户端与服务器之间会发送两次请求，OPTION预检请求成功之后，才会发起真正的请求</li></ul><h3 id="JSONP接口"><a href="#JSONP接口" class="headerlink" title="JSONP接口"></a>JSONP接口</h3><h4 id="回顾JSONP的概念与特点"><a href="#回顾JSONP的概念与特点" class="headerlink" title="回顾JSONP的概念与特点"></a>回顾JSONP的概念与特点</h4><p>概念：浏览器端通过<script>标签的src属性，请求服务器上的数据，同时，服务器放回一个函数的调用，这种请求数据的方式叫做JSONP</p><p>特点：</p><ul><li>  JSONP不属于真正的Ajax请求，因为她没有使用XMLHttpRequest这个对象</li><li>  JSONP仅支持GTE请求，不支持POST、PUT、DELETE等请求</li></ul><h4 id="创建JSONP接口的注意事项"><a href="#创建JSONP接口的注意事项" class="headerlink" title="创建JSONP接口的注意事项"></a>创建JSONP接口的注意事项</h4><p>如果项目中已经配置了CORS的跨域资源共享，为了防止冲突，必须在配置CORS中间件之前声明JSONP的接口，否则JSONP接口会被处理成开启了CORS的接口</p><h4 id="实现JSONP接口的步骤"><a href="#实现JSONP接口的步骤" class="headerlink" title="实现JSONP接口的步骤"></a>实现JSONP接口的步骤</h4><ol><li> 获取客户端发送过来的回调函数的名字</li><li> 得到要通过JSONP形式发送给客户端的数据</li><li> 根据前两步得到的数据，拼接主一个函数调用的字符串</li><li> 把上一步拼接得到的字符串，响应给客户端的<script>标签进行解析执行</li></ol><h4 id="实现JSONP接口的具体代码"><a href="#实现JSONP接口的具体代码" class="headerlink" title="实现JSONP接口的具体代码"></a>实现JSONP接口的具体代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 必须在配置cors前配置JSONP接口</span><br><span class="line">app.get(&#x27;/api/jsonp&#x27;,(req, res) =&gt; &#123; </span><br><span class="line">  // 得到函数的名称</span><br><span class="line">  const funcName = req.query.callback</span><br><span class="line">  // 定义要发送到客户端的数据对象</span><br><span class="line">  const data = &#123; name: &#x27;czf&#x27;, age: 21&#125;</span><br><span class="line">  // 把拼接的字符串，响应给客户端</span><br><span class="line">  const scriptStr = `$&#123;funcName&#125;($&#123;JSON.stringify(data)&#125;)`</span><br><span class="line">  // 把拼接的字符串响应给客户端</span><br><span class="line">  res.send(scriptStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(&#x27;#btnJsonp&#x27;).on(&#x27;click&#x27;, function() &#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    type: &#x27;GET&#x27;,</span><br><span class="line">    url: &#x27;http://127.0.0.1:81/api/jsonp&#x27;,</span><br><span class="line">    dataType: &#x27;jsonp&#x27;,</span><br><span class="line">    success: function (res) &#123;</span><br><span class="line">      console.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h2><p>数据库（database）是用来组织、存储和管理数据的仓库</p><h3 id="常见的数据库及分类"><a href="#常见的数据库及分类" class="headerlink" title="常见的数据库及分类"></a>常见的数据库及分类</h3><p>市面上的数据库有很多种，最常见的数据库有如下几个</p><ul><li>  MySQL数据库（目前使用最广泛、流行度最高的开源免费数据库；Community + Enterprise）</li><li>  Oracle数据库</li><li>  SQL Server数据库里</li><li>  Mongodb数据库</li></ul><p>其中MySQL、Oracle、SQL Server 属于传统型数据库（又叫做:关系型数据库或SQL数据库），这三者的设计理念相同、用法比较类似</p><p>而Mongodb属于新型数据库（又叫做:非关系型数据库或NoSQL数据库），它在一定程度上弥补了传统型数据库的缺陷</p><h3 id="传统型数据库的数据组织结构"><a href="#传统型数据库的数据组织结构" class="headerlink" title="传统型数据库的数据组织结构"></a>传统型数据库的数据组织结构</h3><p>在传统型数据库中，数据的结构分为数据库（database）、数据表（table）、数据行（row）、字段（field）这四大部分组成</p><ul><li>  数据库类似与Excel的工作薄</li><li>  数据表类似于Excel的工作表</li><li>  数据行类似于excel的没一行数据</li><li>  字段类似于Excel的列</li><li>  每个字段都有对应的数据类型</li></ul><h2 id="MySQL的基本使用"><a href="#MySQL的基本使用" class="headerlink" title="MySQL的基本使用"></a>MySQL的基本使用</h2><p>DataType数据类型</p><ul><li>  int 整数</li><li>  varchar(len) 字符串</li><li>  tinyint(1) 布尔值</li></ul><p>字段的特殊标识：</p><ul><li>  PK（Primary Key） 主键、唯一标识</li><li>  NN（Not Null） 值不允许为空</li><li>  UQ（Unique） 值唯一</li><li>  AI（Auto Increment） 值自动增长</li></ul><h2 id="使用SQL管理数据库"><a href="#使用SQL管理数据库" class="headerlink" title="使用SQL管理数据库"></a>使用SQL管理数据库</h2><p>SQL全称（Structured Query Language）是结构化查询语言，专门用来访问和处理数据库的编程语言，能够让我们以编程的形式，操作数据库里的数据</p><ul><li>  SQL是一门数据库编程语言</li><li>  使用SQL语言编写出来的代码，叫做SQL语句</li><li>  SQL语言只能在关系型数据库中使用</li></ul><h3 id="sql能做什么"><a href="#sql能做什么" class="headerlink" title="sql能做什么"></a>sql能做什么</h3><ul><li>  增(insert into)删(delete)查(select)改(update )</li><li>  创建数据库</li><li>  创建新表</li><li>  创建存储过程、视图</li><li>  etc…</li></ul><h2 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h2><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p><code>select */列 from 表名</code></p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>INSERT INTO 语句用于向数据表中插入新的数据行</p><p><code>insert into table_name(列1， 列2) values(值1，值2)</code></p><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>UPDATE：更新某一行中的一个列</p><p><code>update table_name set 列=&#39;&#39; where 行 = ?</code></p><p>UPDATE：更新某一行中的若干列·</p><p><code>updata table_name set 列=&#39;&#39;, 列=&#39;&#39; where 行= ?</code></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>DELETE语句用于删除表中的行</p><p><code>delete from table_name where 行= ?</code></p><h4 id="WHERE语句"><a href="#WHERE语句" class="headerlink" title="WHERE语句"></a>WHERE语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询语句中的WHERE条件</span><br><span class="line">select 列名称 from 表名称 where 列 运算符 值</span><br><span class="line">update 表名称 set 列=值 where 列 运算符 值</span><br><span class="line">delete from 表名称 where 列 运算符 值</span><br></pre></td></tr></table></figure><h4 id="AND和OR运算符"><a href="#AND和OR运算符" class="headerlink" title="AND和OR运算符"></a>AND和OR运算符</h4><p>and和or可在where子句中把两个或多个条件结合起来</p><p>and表示必须同时满足多个条件，相当于Javascript中的&amp;&amp;运算符</p><p>or表示只要满足任意一个条件即可，相当于JavaScript中的||运算符</p><h4 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h4><p>ORDER BY语句用于根据指定的列对结果进行排序</p><p>ORDER BY语句默认按照升序对记录进行升序排序（asc）</p><p>如果希望按照降序对记录进行排序，可以使用DESC关键字</p><p><code>select * from table_name order by 字段</code></p><p><code>select * from table_name order by 字段 desc</code></p><p><strong>多重排序</strong></p><p>例子：对users表中的数据，先按照status字段进行降序排序，再按照username的字母顺序，进行升序排序</p><p><code>select * from users order by status desc, username asc</code></p><h4 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT(*)"></a>COUNT(*)</h4><p>COUNT(*) 函数用于返回查询结果的总数据条数</p><p><code>select count(*) from 表名称</code></p><h4 id="AS"><a href="#AS" class="headerlink" title="AS"></a>AS</h4><p>使用AS为列设置别名</p><p><code>select * as 别名 from 表名称</code></p><h2 id="在项目中操作MySQL"><a href="#在项目中操作MySQL" class="headerlink" title="在项目中操作MySQL"></a>在项目中操作MySQL</h2><ol><li> 安装操作MySQL数据库的第三方模块（mysql）</li><li> 通过mysql模块链接到MySQL数据库</li><li> 通过mysql模块执行SQL语句</li></ol><h3 id="安装mysql模块"><a href="#安装mysql模块" class="headerlink" title="安装mysql模块"></a>安装mysql模块</h3><p>mysql模块是托管于npm上的第三方模块，它提供了在Node.js项目中链接和操作MySQL数据库的能力</p><p><code>npm install mysql</code></p><h3 id="配置mysql模块"><a href="#配置mysql模块" class="headerlink" title="配置mysql模块"></a>配置mysql模块</h3><p>在使用mysql模块操作MySQL数据库之前，必须先度mysql模块进行必要的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 导入mysql模块</span><br><span class="line">const mysql = require(&#x27;mysql&#x27;)</span><br><span class="line">// 建立于MySQL数据库的连接关系</span><br><span class="line">const db = mysql.createPool(&#123;</span><br><span class="line">  host: &#x27;127.0.0.1&#x27;, // 数据库的IP地址</span><br><span class="line">  user: &#x27;root&#x27;, // 登录数据库的账号</span><br><span class="line">  password: &#x27;123456&#x27;, // 登录数据库的密码</span><br><span class="line">  database: &#x27;my_db_01&#x27; // 指定要操作哪个数据库</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 查询</span><br><span class="line">const sqlStr = &#x27;select * from users&#x27;</span><br><span class="line">db.query(sqlStr, (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line"></span><br><span class="line">  console.log(results)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 插入</span><br><span class="line">const user = &#123; username: &#x27;lhw&#x27;,  password: &#x27;lhw123&#x27;&#125;</span><br><span class="line">const sqlStr1 = &#x27;insert into users(username, password) values(?, ?)&#x27;</span><br><span class="line"></span><br><span class="line">db.query(sqlStr1, [user.username, user.password], (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line">  if(results.affectedRows === 1) &#123;</span><br><span class="line">    console.log(&#x27;插入数据成功&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>向表中新增数据是，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速插入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123; username: &#x27;xjc&#x27;,  password: &#x27;xjc123&#x27;&#125;</span><br><span class="line">const sqlStr1 = &#x27;insert into users set ?&#x27;</span><br><span class="line"></span><br><span class="line">db.query(sqlStr1, user, (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line">  if(results.affectedRows === 1) &#123;</span><br><span class="line">    console.log(&#x27;插入数据成功&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123; id: 5, username: &#x27;aaa&#x27;,  password: &#x27;000&#x27;&#125;</span><br><span class="line">const sqlStr1 = &#x27;update users set username=?, password=? where id=?&#x27;</span><br><span class="line"></span><br><span class="line">db.query(sqlStr1, [user.username, user.password, user.id], (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line">  if(results.affectedRows === 1) &#123;</span><br><span class="line">    console.log(&#x27;更新数据成功&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 更新用户信息，便捷方式</span><br><span class="line">const user = &#123; id: 5, username: &#x27;bbb&#x27;,  password: &#x27;111&#x27;&#125;</span><br><span class="line">const sqlStr1 = &#x27;update users set ? where id=?&#x27;</span><br><span class="line"></span><br><span class="line">db.query(sqlStr1, [user, user.id], (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line">  if(results.affectedRows === 1) &#123;</span><br><span class="line">    console.log(&#x27;更新数据成功&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 删除id为5的数据</span><br><span class="line">const sqlStr1 = &#x27;delete from users where id=?&#x27;</span><br><span class="line"></span><br><span class="line">db.query(sqlStr1, 5, (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line">  if(results.affectedRows === 1) &#123;</span><br><span class="line">    console.log(&#x27;删除数据成功&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>标记删除</p><p>使用delete语句，会真正的把数据从表中删除，为了保险起见，推荐使用标记删除的形式，来模拟删除的动作。所谓标记删除，就是在表中设置类似于status这样的状态字段，来标记当前这条数据是否被删除。</p><p>当用户执行了删除的动作时，我们并没有执行delete语句把数据删除掉，而是执行了update语句将这条数据对应的status字段标记为删除即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const sqlStr1 = &#x27;update users set status=? where id=?&#x27;</span><br><span class="line">db.query(sqlStr1, [1, 4], (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line">  if (results.affectedRows === 1) &#123;</span><br><span class="line">    console.log(&#x27;标记删除成功&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="前后端的身份验证"><a href="#前后端的身份验证" class="headerlink" title="前后端的身份验证"></a>前后端的身份验证</h2><h3 id="Web开发模式"><a href="#Web开发模式" class="headerlink" title="Web开发模式"></a>Web开发模式</h3><h3 id="服务端渲染的Web开发模式"><a href="#服务端渲染的Web开发模式" class="headerlink" title="服务端渲染的Web开发模式"></a>服务端渲染的Web开发模式</h3><ul><li>  服务端渲染的概念：服务器发送给客户端的HTML页面，是在服务器通过字符串的拼接，动态生成的，因此，客户端不需要使用Ajax.js这样的技术额外请求页面的数据</li></ul><h3 id="服务端渲染的优缺点"><a href="#服务端渲染的优缺点" class="headerlink" title="服务端渲染的优缺点"></a>服务端渲染的优缺点</h3><p>优点</p><ul><li>  前端耗时少，因为服务器端负责动态生成HTML内容，浏览器只需要直接渲染页面即可，尤其是移动端，更省电。</li><li>  有利于SEO，因为服务器端响应的是完整的HTML页面内容，所以爬虫更加容易获取信息，更有利于SEO。</li></ul><p>缺点</p><ul><li>  占用服务器端资源，即服务器完成HTML页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。</li><li>  不利于前后端分离，开发效率低，使用服务器渲染，则无法进行分工合作，尤其对前端复杂度高的项目，不利于项目高效开发。</li></ul><h3 id="前后端分离的Web开发模式"><a href="#前后端分离的Web开发模式" class="headerlink" title="前后端分离的Web开发模式"></a>前后端分离的Web开发模式</h3><p>前后端分离的概念：前后端分离的开发模式，依赖于Ajax技术的广泛应用，前后端分离的Web开发模式，就是后端只负责提供API接口，前端使用Ajax调用接口的开发模式。</p><h3 id="前后端分离的优缺点"><a href="#前后端分离的优缺点" class="headerlink" title="前后端分离的优缺点"></a>前后端分离的优缺点</h3><p>优点：</p><ul><li>  开发体验好，前端专注于UI页面的开发，后端专注于api的开发，且前端会有更多的选择性</li><li>  用户体验好，Ajax技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新</li><li>  减轻了服务器的渲染压力，因为页面最终是在每个用户的浏览器中生成的</li></ul><p>缺点：</p><ul><li>  不利于SEO，因为完整的HTML页面需要在客户端动态拼接完成，所以爬虫无法爬取页面的有效信息</li></ul><h3 id="如何选择web开发模式"><a href="#如何选择web开发模式" class="headerlink" title="如何选择web开发模式"></a>如何选择web开发模式</h3><p>不谈业务场景而盲目选择使用何种开发模式都是耍流氓</p><ul><li>  比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的SEO，则这时我们就需要使用服务器渲染</li><li>  而类似后台管理项目，交互性比较强，不需要考虑SEO，那么就可以使用前后端分离的开发模式，</li></ul><p>另外，具体使用何种开发模式并不是绝对的，为了同时兼顾首页的渲染速度和前后端分离的开发效率，一些网站采用了首屏服务器渲染+其他页面前后端分离的开发模式。</p><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><p>目的：为了确认当前所声称为某种身份的用户，确实是所声称的用户</p><h4 id="不同开发模式下的身份认证"><a href="#不同开发模式下的身份认证" class="headerlink" title="不同开发模式下的身份认证"></a>不同开发模式下的身份认证</h4><p>对于服务器渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案：</p><ol><li> 服务器渲染推荐使用Session认证机制</li><li> 前后端分离推荐使用JWT认证机制</li></ol><h4 id="Session认证机制"><a href="#Session认证机制" class="headerlink" title="Session认证机制"></a>Session认证机制</h4><h5 id="HTTP协议的无状态性"><a href="#HTTP协议的无状态性" class="headerlink" title="HTTP协议的无状态性"></a>HTTP协议的无状态性</h5><p>HTTP协议的无状态性，指的是客户端的每次HTTP请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次HTTP请求的状态</p><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>cookie是存储在用户浏览器中的一段不超过4KB的字符串，它由一个名称（Name），一个值(Value)和其他几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。</p><p>不同域名下的Cookie各自独立，每当客户端发起请求的时，会自动把当前域名下所有未过期的Cookie一同发送到服务器</p><p>Cookie的几大特性：</p><ul><li>  自动发送</li><li>  域名独立</li><li>  过期限制</li><li>  4KB限制</li></ul><h5 id="Cookie在身份认证中的作用"><a href="#Cookie在身份认证中的作用" class="headerlink" title="Cookie在身份认证中的作用"></a>Cookie在身份认证中的作用</h5><p>客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的Cookie，客户端会自动将Cookie保存在浏览器中。</p><p>随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的Cookie，通过请求头的形式发送给服务器，服务器即可验明客户端的身份。</p><p><img src=""></p><h5 id="Cookie不具有安全性"><a href="#Cookie不具有安全性" class="headerlink" title="Cookie不具有安全性"></a>Cookie不具有安全性</h5><p>由于Cookie时存储在浏览器中的，而且浏览器也提供了读写Cookie的API，因此Cookie很容易被伪造，不具有安全性，因此不建议服务器将重要的隐私数据通过Cookie的形式发送给浏览器</p><h5 id="Session的工作原理"><a href="#Session的工作原理" class="headerlink" title="Session的工作原理"></a>Session的工作原理</h5><p><img src=""></p><h4 id="在Express中使用Session认证"><a href="#在Express中使用Session认证" class="headerlink" title="在Express中使用Session认证"></a>在Express中使用Session认证</h4><p>配置express-session中间件</p><p>express-session中间件安装成功后，需要通过app.use()来注册session中间件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> const app = express()</span><br><span class="line"></span><br><span class="line">const session =require(&#x27;express-session&#x27;)</span><br><span class="line">app.use(</span><br><span class="line">  session(&#123;</span><br><span class="line">    secret: &#x27;itheima&#x27;,</span><br><span class="line">    resave: false,</span><br><span class="line">    saveUninitialized: true,</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>向session中存数据</p><p>当express-session中间件配置成功后，即可通过req.session来访问和使用session对象，从而存储用户的关键信息</p><h4 id="JWT认证机制"><a href="#JWT认证机制" class="headerlink" title="JWT认证机制"></a>JWT认证机制</h4><p>session认证机制需要配合Cookie才能实现，由于Cookie默认不支持跨域访问，所以，当涉及到当前跨域请求后端接口的时候，需要很多额外的配置，才能实现跨域session认证。</p><p>注意：</p><ul><li>  当前端请求后端接口不存在跨域问题的时候，推荐使用Session身份认证机制</li><li>  当前端需要跨域请求后端接口的时候，不推荐使用Session身份认证机制，推荐使用JWT认证机制</li></ul><h5 id="JWT工作原理"><a href="#JWT工作原理" class="headerlink" title="JWT工作原理"></a>JWT工作原理</h5><p><img src=""></p><p>总结：用户的信息通过Token字符串的形式，保存在客户端浏览器中，服务器通过还原Token字符串的形式来认证用户的身份</p><h5 id="JWT的组成部分"><a href="#JWT的组成部分" class="headerlink" title="JWT的组成部分"></a>JWT的组成部分</h5><p>JWT通常由三部分组成，分别是Header（头部）、Payload（有效荷载）、Signature（签名）</p><p>三者之间使用英文的”.”分割</p><h5 id="JWT的三个部分各自代表的含义"><a href="#JWT的三个部分各自代表的含义" class="headerlink" title="JWT的三个部分各自代表的含义"></a>JWT的三个部分各自代表的含义</h5><p>JWT的三个部分，从前到后分别时Header、Payload、Signature</p><p>其中：</p><ul><li>  Payload部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串</li><li>  Header和Signature是安全性相关的部分，只是为了保证Token的安全性</li></ul><h5 id="JWT使用方式"><a href="#JWT使用方式" class="headerlink" title="JWT使用方式"></a>JWT使用方式</h5><p>客户端收到服务器放回的JWT之后，通常会将它存储在localStorage或sessionStorage中</p><p>此后，客户端每次与服务器通信，都要带上这个JWT的字符串，从而进行身份认证，推荐的做法是把JWT放在HTTP请求头的Authorization字段中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><h4 id="在Express中使用JWT"><a href="#在Express中使用JWT" class="headerlink" title="在Express中使用JWT"></a>在Express中使用JWT</h4><h5 id="安装JWT相关的包"><a href="#安装JWT相关的包" class="headerlink" title="安装JWT相关的包"></a>安装JWT相关的包</h5><p><code>npm install jsonwebtoken express-jwt</code></p><p>其中：</p><ul><li>  jsonwebtoken用于生成JWT字符串</li><li>  express-jwt用于将JWT字符串解析还原成JSON对象</li></ul><h5 id="导入JWT相关的包"><a href="#导入JWT相关的包" class="headerlink" title="导入JWT相关的包"></a>导入JWT相关的包</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cosnt jwt = require(&#x27;jsonwebtoken&#x27;)</span><br><span class="line"></span><br><span class="line">const expressJWT = require(’express-jwt&#x27;)</span><br></pre></td></tr></table></figure><h5 id="定义secret密钥"><a href="#定义secret密钥" class="headerlink" title="定义secret密钥"></a>定义secret密钥</h5><p>为了保证JWT字符串的安全性，防止JWT字符串在网络传输过程中被别人破解，我们需要定义一个用于加密和解密的secret密钥：</p><ol><li> 当生成JWT字符串的时候，需要使用secret密钥对用户的信息进行加密，最终得到加密好的JWT字符串</li><li> 当把JWT字符串解析还原成JSON对象的时候，需要使用secret密钥进行解密</li></ol><p><code>const secretKey = &#39;itheima No1 ^_^&#39;</code></p><h5 id="在登录成果后生成JWT字符串"><a href="#在登录成果后生成JWT字符串" class="headerlink" title="在登录成果后生成JWT字符串"></a>在登录成果后生成JWT字符串</h5><p>调用jsonwebtoken包提供的sign()方法，将用户的信息加密成JWT字符串，响应给客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.post(&#x27;api/login&#x27;, function(req, res) &#123;</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    status: 200,</span><br><span class="line">    message: &#x27;登录成功&#x27;,</span><br><span class="line">    token: jwt.sign(&#123; username: userinfo.username &#125;, secretKey, &#123; expiresIn: &#x27;30s&#x27;&#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="将JWT字符串还原为JSON对象"><a href="#将JWT字符串还原为JSON对象" class="headerlink" title="将JWT字符串还原为JSON对象"></a>将JWT字符串还原为JSON对象</h5><p>客户端每次在访问那些有权限接口的时候，都需要主动通过请求头中的Authorization字段，将Token字符串发送到服务器进行身份认证</p><p>此时服务器可以通过<strong>express-jwt</strong>这个中间件，自动将客户端发送过来的Token解析还原成JSON对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用app.use()来注册中间件</span><br><span class="line">// expressJWT(&#123; secret: secretKey &#125;) 就是用来解析Token的中间件</span><br><span class="line">// .unless(&#123; path: [/^/api//]&#125;) 用来指定哪些接口不需要访问权限</span><br><span class="line">app.use(expressJWT(&#123; secret: secretKey &#125;).unless(&#123; path: [/^/api//]&#125;))</span><br></pre></td></tr></table></figure><h5 id="使用req-user获取用户信息"><a href="#使用req-user获取用户信息" class="headerlink" title="使用req.user获取用户信息"></a>使用req.user获取用户信息</h5><p>当express-jwt这个中间件配置成功之后，即可在那些有权限的接口中，使用req.user对象，来访问从JWT字符串中解析出来的用户信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;/admin/getinfo&#x27;, function(req, res) &#123;</span><br><span class="line">  console.log(req.user)</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    status: 200,</span><br><span class="line">    message: &#x27;获取用户信息成功！&#x27;,</span><br><span class="line">    data: req.user</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="捕获解析JWT失败后产生的错误"><a href="#捕获解析JWT失败后产生的错误" class="headerlink" title="捕获解析JWT失败后产生的错误"></a>捕获解析JWT失败后产生的错误</h5><p>当使用express-jwt解析Token字符串时，如果客户端发送过来的Token字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行，我们可以通过Express的错误中间件，捕获这个错误并进行相关的处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.use((err, req, res, next) =&gt; &#123;</span><br><span class="line">  // token解析失败导致的错误</span><br><span class="line">  if(err.name === &#x27;UnauthorizedError&#x27;) &#123;</span><br><span class="line">    return res.send(&#123; status: 401, message: &#x27;无效的token&#x27;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 其他原因导致的错误</span><br><span class="line">  res.send(&#123; status: 500, message: &#x27;未知错误&#x27;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></script></p>]]></content>
      
      
      
        <tags>
            
            <tag> node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo学习</title>
      <link href="/2022/09/27/Hexo%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/09/27/Hexo%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a></p><h1 id="1-初识Hexo"><a href="#1-初识Hexo" class="headerlink" title="1.初识Hexo"></a>1.初识Hexo</h1><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页</p><h2 id="1-1-安装Hexo"><a href="#1-1-安装Hexo" class="headerlink" title="1.1 安装Hexo"></a>1.1 安装Hexo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**npm install -g hexo-cli**</span><br></pre></td></tr></table></figure><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm server</span><br></pre></td></tr></table></figure><h2 id="1-2-目录结构"><a href="#1-2-目录结构" class="headerlink" title="1.2 目录结构"></a>1.2 目录结构</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27188772/1664181986671-6cc3ea7d-2e2e-4007-ad9c-107a0baa1a63.png" alt="img"></p><h2 id="1-3-generate（生成静态网址）"><a href="#1-3-generate（生成静态网址）" class="headerlink" title="1.3 generate（生成静态网址）"></a>1.3 generate（生成静态网址）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**hexo generate**</span><br></pre></td></tr></table></figure><p>生成静态文件。</p><table><thead><tr><th><strong>选项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>-d, –deploy</td><td>文件生成后立即部署网站</td></tr><tr><td>-w, –watch</td><td>监视文件变动</td></tr><tr><td>-b, –bail</td><td>生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td>-f, –force</td><td>强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。 使用该参数的效果接近 hexo clean &amp;&amp; hexo generate</td></tr><tr><td>-c, –concurrency</td><td>最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>ps：生成好的public文件夹可以直接当成静态网站进行部署</p><h1 id="2-Hexo博客主题的安装与推荐"><a href="#2-Hexo博客主题的安装与推荐" class="headerlink" title="2. Hexo博客主题的安装与推荐"></a>2. Hexo博客主题的安装与推荐</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27188772/1664185687883-f65df138-f1a7-4524-ac46-8d607065f212.png" alt="img"></p><h1 id="3-文档编辑写"><a href="#3-文档编辑写" class="headerlink" title="3. 文档编辑写"></a>3. 文档编辑写</h1><p> 你可以执行下列命令来创建一篇新文章或者新的页面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。</p><h2 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h2><p>Hexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。</p><table><thead><tr><th><strong>布局</strong></th><th><strong>路径</strong></th></tr></thead><tbody><tr><td>post</td><td>source/_posts</td></tr><tr><td>page</td><td>source</td></tr><tr><td>draft</td><td>source/_drafts</td></tr></tbody></table><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--- title: Hello World date: 2022/9/27 12:00:00 ---</span><br></pre></td></tr></table></figure><p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td><td align="left"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td><td align="left">文章的文件名</td></tr><tr><td align="left"><code>date</code></td><td align="left">建立日期</td><td align="left">文件建立日期</td></tr><tr><td align="left"><code>updated</code></td><td align="left">更新日期</td><td align="left">文件更新日期</td></tr><tr><td align="left"><code>comments</code></td><td align="left">开启文章的评论功能</td><td align="left">true</td></tr><tr><td align="left"><code>tags</code></td><td align="left">标签（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>categories</code></td><td align="left">分类（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">覆盖文章网址</td><td align="left"></td></tr><tr><td align="left"><code>excerpt</code></td><td align="left">Page excerpt in plain text. Use <a href="https://hexo.io/docs/tag-plugins#Post-Excerpt">this plugin</a> to format the text</td><td align="left"></td></tr><tr><td align="left"><code>disableNunjucks</code></td><td align="left">Disable rendering of Nunjucks tag <code>&#123;&#123; &#125;&#125;</code>/<code>&#123;% %&#125;</code> and <a href="https://hexo.io/docs/tag-plugins">tag plugins</a> when enabled</td><td align="left"></td></tr><tr><td align="left"><code>lang</code></td><td align="left">Set the language to override <a href="https://hexo.io/docs/internationalization#Path">auto-detection</a></td><td align="left">Inherited from <code>_config.yml</code></td></tr></tbody></table><h2 id="Hexo插入图片"><a href="#Hexo插入图片" class="headerlink" title="Hexo插入图片"></a>Hexo插入图片</h2><p>版本：Hexo5.0.2（Hexo3以上即可）</p><p>解决方案如下：</p><p>修改配置文件</p><ul><li>  在根目录下配置文件_config.yml 中有 post_asset_folder:false改为true。</li><li>  这样在建立文件时，Hexo会自动建立一个与文章同名的文件夹，这样就可以把与该文章相关的所有资源（图片）都放到那个文件夹里方便后面引用</li><li>  我这里放的图片是：vite.jpg</li><li>  安装插件：hexo-asset-image</li></ul><p><code>npm install https://github.com/7ym0n/hexo-asset-image --save（使用cnpm速度相当会快点，当然npm也可以滴）</code></p><ul><li>  使用这个插件来引入图片，而不是网上那些方法里说的用传统md语法相对路径的方法。</li><li>  插入图片时用这种方式：</li></ul><p><code>&#123;% asset_img vite.jpg This is an test image %&#125;</code></p><ul><li>  其中vite.jpg就是你要引用的图片，我这里就是vite.jpg，后面的This is an test image是图片描述，可以自己修改。</li></ul><h1 id="4-部署到GitHub"><a href="#4-部署到GitHub" class="headerlink" title="4. 部署到GitHub"></a>4. 部署到GitHub</h1><p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deploy:  type: git</span><br></pre></td></tr></table></figure><p>您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deploy: - type: git  repo: - type: heroku  repo:</span><br></pre></td></tr></table></figure><p>Refer to the <a href="https://hexo.io/plugins/">Plugins</a> list for more deployment plugins.</p><p><strong>缩进</strong></p><p>YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ol><li>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ol><li>修改配置。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deploy:  type: git  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io  branch: [branch]  message: [message]</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th><th><strong>默认</strong></th></tr></thead><tbody><tr><td>repo</td><td>库（Repository）地址</td><td></td></tr><tr><td>branch</td><td>分支名称</td><td>gh-pages (GitHub) coding-pages (Coding.net) master (others)</td></tr><tr><td>message</td><td>自定义提交信息</td><td>Site updated: <code>&#123;&#123;` now('YYYY-MM-DD HH:mm:ss') `&#125;&#125;</code>)</td></tr><tr><td>token</td><td>Optional token value to authenticate with the repo. Prefix with $ to read token from environment variable</td><td></td></tr></tbody></table><ol><li>生成站点文件并推送至远程库。执行 hexo clean &amp;&amp; hexo deploy。</li></ol><ul><li>You will be prompted with username and password of the target repository, unless you authenticate with a token or ssh key.</li><li>hexo-deployer-git does not store your username and password. Use <a href="https://git-scm.com/docs/git-credential-cache">git-credential-cache</a> to store them temporarily.</li></ul><ol><li>登入 Github/BitBucket/Gitlab，请在库设置（Repository Settings）中将默认分支设置为_config.yml配置中的分支名称。稍等片刻，您的站点就会显示在您的Github Pages中。</li></ol><h2 id="GitHub项目创建"><a href="#GitHub项目创建" class="headerlink" title="GitHub项目创建"></a>GitHub项目创建</h2><p>注意：项目文件名必须是 &lt;用户名&gt;.github.io</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27188772/1664271440539-12f83f73-d804-4dce-b0be-d769b07527c5.png" alt="img"></p><p>代码上传到GitHub仓库后就可以通过访问<a href="https://pokemonfeng.github.io/%E6%9D%A5%E6%9F%A5%E7%9C%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2">https://pokemonfeng.github.io/来查看自己的博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub代码提交失败</title>
      <link href="/2022/09/27/GitHub%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E5%A4%B1%E8%B4%A5/"/>
      <url>/2022/09/27/GitHub%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.choupangxia.com/2021/05/18/git-error/">参考文章</a></p><h2 id="Git操作失败场景"><a href="#Git操作失败场景" class="headerlink" title="Git操作失败场景"></a>Git操作失败场景</h2><p>原来项目中使用Git是正常的，无论是GitHub的项目还是码云的项目，都是可以正常pull和push的。但当将Mac Book的操作系统升级之后，发现Git无法执行pull和push操作，add和commit操作都还是正常的。</p><h2 id="网络上的状况和解决方案"><a href="#网络上的状况和解决方案" class="headerlink" title="网络上的状况和解决方案"></a>网络上的状况和解决方案</h2><p>如果你不是因为升级操作系统导致的git失效，你可以先尝试一下网络上的解决方案。</p><h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p>在命令行执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关GitHub无法访问问题</title>
      <link href="/2022/09/27/%E6%9C%89%E5%85%B3GitHub%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/27/%E6%9C%89%E5%85%B3GitHub%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_27415615/article/details/124791034?ops_request_misc=&request_id=&biz_id=102&utm_term=github%E5%AE%98%E7%BD%91%E8%BF%9B%E4%B8%8D%E5%8E%BB&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-124791034.nonecase&spm=1018.2226.3001.4187">参考资料</a></p><p>用<a href="https://tool.chinaz.com/dns?type=1">IP地址查找工具1</a>或者<a href="https://www.ipaddress.com/">IP地址查找工具2</a>将查找的ip地址通过<a href="http://www.electronjs.org/apps/switchhosts">switchhosts（hosts切换工具）</a>更改本地hosts的方式</p><h1 id="第一步：ping一下Github的官网，测试网络连通性"><a href="#第一步：ping一下Github的官网，测试网络连通性" class="headerlink" title="第一步：ping一下Github的官网，测试网络连通性"></a>第一步：ping一下Github的官网，测试网络连通性</h1><p>如果进不去Github官网的话，当你用ping工具执行ping github.com命令时，显示的TTL很高或者提示“请求超时”，我的是请求超时</p><img src="/2022/09/27/%E6%9C%89%E5%85%B3GitHub%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/a.png" class title="图片"><p>如果当你通过第一步发现ping giithub.com的网速显示请求超时的时候，接下来进行第二步；</p><h1 id="第二步：修改hosts文件（用hosts切换工具方便一点，前言里有）"><a href="#第二步：修改hosts文件（用hosts切换工具方便一点，前言里有）" class="headerlink" title="第二步：修改hosts文件（用hosts切换工具方便一点，前言里有）"></a>第二步：修改hosts文件（用hosts切换工具方便一点，前言里有）</h1><p>没有hosts切换工具的，在如下位置找到hosts并手动修改（直接保存可能存在权限问题，百度一下解决）</p><hr><p>Windows 系统位于 C:\Windows\System32\drivers\etc<br>Android（安卓）系统hosts位于 /etc/<br>Mac（苹果电脑）系统hosts位于 /etc/<br>iPhone（iOS）系统hosts位于 /etc/<br>Linux系统hosts位于 /etc/<br>绝大多数Unix系统都是在 /etc/</p><p>在hosts文件最后加上以下内容（一般以追加的方式修改）</p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/26/hello-world/"/>
      <url>/2022/09/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
