<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Netlify前端自动化部署服务</title>
      <link href="/2023/03/07/Netlify%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/03/07/Netlify%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-首先将项目发布github进行代码管理"><a href="#1-首先将项目发布github进行代码管理" class="headerlink" title="1. 首先将项目发布github进行代码管理"></a>1. 首先将项目发布github进行代码管理</h1><ol start="2"><li>打开Netlify网站</li><li>点击右上方的Log in</li><li>可以通过GitHub账户直接登录</li></ol><ol start="5"><li>登录成功之后来到首页，点击Add new site</li></ol><img src="/2023/03/07/Netlify%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/b.png" class title="图片"><ol start="6"><li>选择Import an existing project</li></ol><img src="/2023/03/07/Netlify%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/c.png" class title="图片"><ol start="7"><li>从GitHub、GitLab或Bitbucket去获取我们的项目代码</li></ol><img src="/2023/03/07/Netlify%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/d.png" class title="图片"><ol start="8"><li>我们以GitHub为例，点击左下角的GitHub，然后选择对应的代码仓库</li></ol><img src="/2023/03/07/Netlify%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/e.png" class title="图片"><ol start="9"><li>接着配置部署设置，配置完成后点击Deploy site</li></ol><img src="/2023/03/07/Netlify%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/f.png" class title="图片"><p>Base directory : 用于链接单存储库或从存储库的子目录构建的站点的可选字段。它指定了我们的构建机器人在开始构建之前更改为的目录。这是我们的构建系统检查依赖项管理文件（如 or ）的地方。如果未设置，则基目录默认为存储库的根目录。package.json.nvmrc</p><p>Build command: 如果您使用的是静态站点生成器或其他构建工具，则应在其中指定要运行的命令以构建站点。例如。构建命令在 Bash shell 中运行，允许您向命令添加与 Bash 兼容的语法。访问框架文档，了解常用工具的典型设置。npm run build</p><p>Publish directory: 包含生成生成的部署就绪 HTML 文件和资产的目录（相对于存储库的根目录）。如果指定了基目录，则应将其包含在发布目录路径中</p><ol start="10"><li>之后返回到该页面，滑到下方可以查看打包进度，待打包完毕，返回上一页，点击网址，即可查看到已经发布的网页了。</li></ol><img src="/2023/03/07/Netlify%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/g.png" class title="图片"><img src="/2023/03/07/Netlify%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/h.png" class title="图片"><p>ps：此时为打包完毕的情况，未打包完毕显示的是Building</p>]]></content>
      
      
      
        <tags>
            
            <tag> Neilify </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack学习</title>
      <link href="/2023/03/06/Webpack%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/03/06/Webpack%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、认识webpack"><a href="#一、认识webpack" class="headerlink" title="一、认识webpack"></a>一、认识webpack</h1><p><strong>从本质上来讲，webpack是一个现代的JavaScript应用的静态</strong> <strong>模块打包</strong> <strong>工具</strong></p><ol><li> webpack其中一个核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系</li><li> 不仅仅是JavaScript文件，CSS、图片、json文件等等再webpack中都可以当作模块来使用。</li></ol><p><strong>打包</strong>：</p><ol><li> 将webpack中的各种资源模块进行打包合并成一个或多个包（Bundle）；</li></ol><!----><ol start="2"><li> 在打包过程中，还可以对资源进行处理，比如压缩图片，将scss转成css，将ES6语法转成ES5语法，将TypeScript转成JavaScript等等。</li></ol><h1 id="二、-和grunt-gulp的对比"><a href="#二、-和grunt-gulp的对比" class="headerlink" title="二、 和grunt/gulp的对比"></a>二、 和grunt/gulp的对比</h1><h2 id="1-grunt-gulp的核心是Task"><a href="#1-grunt-gulp的核心是Task" class="headerlink" title="1. grunt/gulp的核心是Task"></a>1. grunt/gulp的核心是Task</h2><ol><li> 我们可以配置一些列的task，并且定义task要处理的事务（例如ES6、ts转化、图片压缩、scss转成css）</li><li> 之后让grunt/gulp来依次执行这些task，而且让整个流程自动化</li><li> 所以grunt/gulp也被称为前端自动化任务管理工具。</li></ol><h2 id="2-我们来开一个gulo的task"><a href="#2-我们来开一个gulo的task" class="headerlink" title="2. 我们来开一个gulo的task"></a>2. 我们来开一个gulo的task</h2><p>下面的task就是将src下面的所有js文件转成ES5语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const gulp = require(&#x27;gulp&#x27;);</span><br><span class="line">const babel = require(&#x27;gulp-babel&#x27;);</span><br><span class="line"></span><br><span class="line">gulp.task(&#x27;js&#x27;,()=&gt;</span><br><span class="line">          gulp.src(&#x27;src/*.js&#x27;)</span><br><span class="line">            .pipr(babel(&#123;</span><br><span class="line">                presets:[&#x27;es2015&#x27;]</span><br><span class="line">&#125;))</span><br><span class="line">          .pipe(gulp.dest(&#x27;dist&#x27;))</span><br><span class="line">          &#125;;</span><br></pre></td></tr></table></figure><p>并且最终输出到dist文件中</p><h2 id="3-是么时候使用grunt-gulp"><a href="#3-是么时候使用grunt-gulp" class="headerlink" title="3. 是么时候使用grunt/gulp"></a>3. 是么时候使用grunt/gulp</h2><ol><li> 如果你的工程模块依赖非常简单，甚至是没有用到模块化的概念；</li><li> 只需要进行简单的合并、压缩、就使用grunt/gulp即可；</li><li> 但是如果整个项目使用了模块化管理，而且相互依赖非常强，我们就可以使用更加强大的webpack。</li></ol><h2 id="4-grunt-gulp和webpack的不同"><a href="#4-grunt-gulp和webpack的不同" class="headerlink" title="4. grunt/gulp和webpack的不同"></a>4. grunt/gulp和webpack的不同</h2><ol><li> grunt/gulp更加强调的是前端流程的自动化，模块化不是它的核心；</li><li> webpack更加强调模块化开发管理，而文件压缩合并、预处理等功能，就是他附带的功能。</li></ol><h1 id="三、webpack安装"><a href="#三、webpack安装" class="headerlink" title="三、webpack安装"></a>三、webpack安装</h1><ol><li> 依赖node环境</li><li> node环境为了可以正常的执行很多代码，必须其中包含各种依赖各的包</li><li> npm工具：管理这种包</li><li> 安装：npm install webpack@版本 -g （全局）</li><li> 局部安装：npm install webpack@版本 –save-dev</li></ol><h1 id="四、-打包"><a href="#四、-打包" class="headerlink" title="四、 打包"></a>四、 打包</h1><h2 id="1-打包js"><a href="#1-打包js" class="headerlink" title="1. 打包js"></a>1. 打包js</h2><h3 id="1-1基本使用"><a href="#1-1基本使用" class="headerlink" title="1.1基本使用"></a>1.1基本使用</h3><ol><li> webpack会自己处理文件间的依赖</li><li> 配置出口入口</li></ol><p>文件目录  </p><img src="/2023/03/06/Webpack%E5%AD%A6%E4%B9%A0/a.png" class title="文件目录"><ol><li> 创建webpack.config.js文件</li><li> 下载path包：npm install path</li><li> 配置文件webpack.config.js</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#x27;./src/main.js&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">        filename: &#x27;bundle.js&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: /.css$/,</span><br><span class="line">            //css-loader只负着将css文件进行加载</span><br><span class="line">            //style-loader负责将样式添加到DOM中</span><br><span class="line">            use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-ES6转ES5"><a href="#1-2-ES6转ES5" class="headerlink" title="1.2 ES6转ES5"></a>1.2 ES6转ES5</h3><h4 id="1-2-1-ES6语法处理"><a href="#1-2-1-ES6语法处理" class="headerlink" title="1.2.1 ES6语法处理"></a>1.2.1 ES6语法处理</h4><ol><li>使用babel<br> npm install –save-dev babel-loader@版本 babel-core babel-preset-es2015</li><li> 配置webpack,config,js</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /.js$/,</span><br><span class="line">      exclude: /(node_modules|bower_components)/,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: &#x27;babel-loader&#x27;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [&#x27;@babel/preset-env&#x27;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-打包css"><a href="#2-打包css" class="headerlink" title="2. 打包css"></a>2. 打包css</h2><h3 id="2-1-安装loader"><a href="#2-1-安装loader" class="headerlink" title="2.1. 安装loader"></a>2.1. 安装loader</h3><ol><li><ol><li> css-loader: npm install –save-dev css-loader</li><li> style-loader: npm install style-loader –save-dev</li></ol></li></ol><p>删除：npm uninstall style-loader/css-loader</p><h3 id="2-2配置webpack-config-js"><a href="#2-2配置webpack-config-js" class="headerlink" title="2.2配置webpack.config.js"></a>2.2配置webpack.config.js</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /.css$/,</span><br><span class="line">        use: [ &#x27;style-loader&#x27;, &#x27;css-loader&#x27; ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-下载less-loader"><a href="#2-3-下载less-loader" class="headerlink" title="2.3. 下载less-loader"></a>2.3. 下载less-loader</h3><p>安装：npm install –save-dev less-loader less<br>配置：webpack.config.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: /.less$/,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: &quot;style-loader&quot; // creates style nodes from JS strings</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: &quot;css-loader&quot; // translates CSS into CommonJS</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: &quot;less-loader&quot; // compiles Less to CSS</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-打包图片"><a href="#3-打包图片" class="headerlink" title="3. 打包图片"></a>3. 打包图片</h2><h3 id="1-安装url-loader"><a href="#1-安装url-loader" class="headerlink" title="1.安装url-loader"></a>1.安装url-loader</h3><ol><li> 下载对应loader</li><li> 安装：npm install –save-dev url-loader</li><li>用法：url-loader 功能类似于 <a href="https://github.com/webpack-contrib/file-loader">file-loader</a>，但是在文件大小（单位 byte）低于指定的限制时，可以返回一个 DataURL。<br> import img from ‘./image.png’</li><li> 配置webpack.config,js</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /.(png|jpg|gif)$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &#x27;url-loader&#x27;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 8192</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 1. 当加载的图片，小于limit时，会将图片编译成base64字符串形式</p><ol start="2"><li>当加载的图片，大于limit时，需要使用file-loader模块进行加载</li></ol><h3 id="2-file-loader"><a href="#2-file-loader" class="headerlink" title="2. file-loader"></a>2. file-loader</h3><ol><li> 安装：npm install –save-dev file-loader</li><li> 打包后图片打包到dist中，名字、路径改变，加载不出图片</li><li> 解决路径问题</li></ol><p>修改配置：publicPath:’./dist/‘（通过url加载时会在前面加上dist/）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#x27;./src/main.js&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">        filename: &#x27;bundle.js&#x27;,</span><br><span class="line">        publicPath:&#x27;./dist/&#x27;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="3-打包图片路劲和命名"><a href="#3-打包图片路劲和命名" class="headerlink" title="3. 打包图片路劲和命名"></a>3. 打包图片路劲和命名</h3><p>配置webpack.config.js</p><p>1.打包图片命名</p><p>name: ‘img/[name].[hash:8].[ext]’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            test: /.(png|jpg|gif)$/,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: &#x27;url-loader&#x27;,</span><br><span class="line">                //当加载的图片，小于limit时，会将图片编译成base64字符串形式</span><br><span class="line">                //当加载的图片，大于limit时，需要使用file-loader模块进行加载</span><br><span class="line">                options: &#123;</span><br><span class="line">                    limit: 8192,</span><br><span class="line">                    // 打包图片命名</span><br><span class="line">                    name: &#x27;img/[name].[hash:8].[ext]&#x27;</span><br><span class="line">                &#125;,</span><br><span class="line"></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure><h1 id="五、引入vue"><a href="#五、引入vue" class="headerlink" title="五、引入vue"></a>五、引入vue</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//5. 依赖vue文件</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &#x27;你好&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>修改webpack.config,js配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#x27;./src/main.js&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">        filename: &#x27;bundle.js&#x27;,</span><br><span class="line">        publicPath: &#x27;./dist/&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">                test: /.css$/,</span><br><span class="line">                //css-loader只负着将css文件进行加载</span><br><span class="line">                //style-loader负责将样式添加到DOM中</span><br><span class="line">                use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /.less$/,</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: &quot;style-loader&quot; // creates style nodes from JS strings</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;css-loader&quot; // translates CSS into CommonJS</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;less-loader&quot; // compiles Less to CSS</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /.(png|jpg|gif)$/,</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: &#x27;url-loader&#x27;,</span><br><span class="line">                    //当加载的图片，小于limit时，会将图片编译成base64字符串形式</span><br><span class="line">                    //当加载的图片，大于limit时，需要使用file-loader模块进行加载</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        limit: 8192,</span><br><span class="line">                        // 打包图片命名</span><br><span class="line">                        name: &#x27;img/[name].[hash:8].[ext]&#x27;</span><br><span class="line">                    &#125;,</span><br><span class="line"></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /.js$/,</span><br><span class="line">                //exclude:排除</span><br><span class="line">                //include：包含</span><br><span class="line">                exclude: /(node_modules|bower_components)/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &#x27;babel-loader&#x27;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        presets: [&#x27;es2015&#x27;]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        //alias：别名</span><br><span class="line">        //git commit -m &#x27;注释&#x27;</span><br><span class="line">        //git c &#x27;&#x27;</span><br><span class="line">        //给git起别名</span><br><span class="line">        alias: &#123;</span><br><span class="line">            &#x27;vue$&#x27;: &#x27;vue/dist/vue.esm.js&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-vue文件封装处理"><a href="#1-vue文件封装处理" class="headerlink" title="1..vue文件封装处理"></a>1..vue文件封装处理</h2><p>安装：vue-loader以及vue-template-compiler</p><p>npm install vue-loader vue-template-compiler–save-dev</p><p><strong>修改webpack.config.js文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: /.vue$/,</span><br><span class="line">            use: [&#x27;vue-loader&#x27;]</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>创建App.vue文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">    &lt;h2 class=&quot;title&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;Cpn&gt;&lt;/Cpn&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Cpn from &#x27;./Cpn&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name:&quot;App&quot;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        Cpn</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            message: &#x27;你好&#x27;,</span><br><span class="line">            name: &#x27;coderczf&#x27;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        btnClick() &#123;</span><br><span class="line">            this.name = &#x27;我是谁&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    .title&#123;</span><br><span class="line">        color: green;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><strong>修改main.js文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//5. 依赖vue文件</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">//  import App from &#x27;./vue/app.js&#x27;</span><br><span class="line">import App from &#x27;./vue/App.vue&#x27;</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    //有el和tempalte，后者会替换前者</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    template: &#x27;&lt;App/&gt;&#x27;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        App</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>技巧</strong>: 省略后缀</p><p>修改webpack.config.js文件</p><p>extensions: [‘.js’, ‘.vue’, ‘.css’],</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">       extensions: [&#x27;.js&#x27;, &#x27;.vue&#x27;, &#x27;.css&#x27;],</span><br><span class="line">       alias: &#123;</span><br><span class="line">           &#x27;vue$&#x27;: &#x27;vue/dist/vue.esm.js&#x27;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="六、认识plugin"><a href="#六、认识plugin" class="headerlink" title="六、认识plugin"></a>六、认识plugin</h1><h2 id="1-plugin是什么"><a href="#1-plugin是什么" class="headerlink" title="1. plugin是什么"></a>1. plugin是什么</h2><ol><li> plugin是插件的意思，通常是用于对某个现有架构经行扩展</li><li> webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化、文件压缩等等。</li></ol><h2 id="2-loader与plugin的区别"><a href="#2-loader与plugin的区别" class="headerlink" title="2. loader与plugin的区别"></a>2. loader与plugin的区别</h2><ol><li> loader主要用于转换某些类型的模块，它是一个转换器；</li><li> plugin是插件，它是对webpack本身的扩展，是一个扩展器。</li></ol><h2 id="3-plugin的使用过程"><a href="#3-plugin的使用过程" class="headerlink" title="3. plugin的使用过程"></a>3. plugin的使用过程</h2><ol><li> 通过npm安装需要使用的plugin（某些webpack已经内置的插件不需要安装）</li><li> 在webpack.config,js中的plugins中配置插件</li></ol><h2 id="4-添加版权的plugin"><a href="#4-添加版权的plugin" class="headerlink" title="4. 添加版权的plugin"></a>4. 添加版权的plugin</h2><ol><li> 我们先来使用一个简单的插件，为打包的文件添加版权声明</li></ol><!----><ol><li><ol><li> 该插件的名字叫BannerPlugin，属于webpack’自带的插件。</li></ol></li></ol><!----><ol start="2"><li> 按照下面的方式修改webpack.config.js的文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&#x27;webpack&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#x27;./src/main.js&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">        filename: &#x27;bundle.js&#x27;,</span><br><span class="line">        publicPath: &#x27;./dist/&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&#x27;最终版权归czf所有&#x27;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li> 重新打包程序：查看bundle,js文件的头部，看到如下信息</li></ol><h1 id="七、-打包html-js的plugin"><a href="#七、-打包html-js的plugin" class="headerlink" title="七、 打包html/js的plugin"></a>七、 打包html/js的plugin</h1><ol><li> <strong>当需要间index.html文件打包到dist文件中，这个时候就可以使用HtmlWebpackPlugin插件</strong></li></ol><h2 id="7-1-HtmlWebpackPlugin插件作用"><a href="#7-1-HtmlWebpackPlugin插件作用" class="headerlink" title="7.1 HtmlWebpackPlugin插件作用"></a>7.1 HtmlWebpackPlugin插件作用</h2><ol><li> 自动生成一个index.html文件（可以指定模板来生成）</li><li> 将打包的js文件，自动通过script标签插入到body中</li></ol><h2 id="7-2-安装HtmlWebpackPlugin插件"><a href="#7-2-安装HtmlWebpackPlugin插件" class="headerlink" title="7.2 安装HtmlWebpackPlugin插件"></a>7.2 安装HtmlWebpackPlugin插件</h2><p>npm install html-webpack-plugin –save-dev</p><h2 id="7-2-使用"><a href="#7-2-使用" class="headerlink" title="7.2 使用"></a>7.2 使用</h2><ol><li> 修改webpack’.config.js文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line"></span><br><span class="line">   plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&#x27;最终版权归czf所有&#x27;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &#x27;index.html&#x27;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h2 id="7-3-js压缩的plugin"><a href="#7-3-js压缩的plugin" class="headerlink" title="7.3 js压缩的plugin"></a>7.3 js压缩的plugin</h2><ol><li> 对j打包的js文件进行压缩</li><li> 使用第三方插件uglifyjs-webpack-plugin</li></ol><p>npm install uglifyjs-webpack-plugin@版本 –save-dev</p><ol start="3"><li> 修改webpack.config,js文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const uglifyjsPlugin = require(&#x27;uglifyjs-webpack-plugin&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#x27;./src/main.js&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">        filename: &#x27;bundle.js&#x27;,</span><br><span class="line">        // publicPath: &#x27;./dist/&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&#x27;最终版权归czf所有&#x27;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &#x27;index.html&#x27;</span><br><span class="line">        &#125;),</span><br><span class="line">        new uglifyjsPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八、-搭建服务器"><a href="#八、-搭建服务器" class="headerlink" title="八、 搭建服务器"></a>八、 搭建服务器</h1><ol><li> webpack提供了一个可选的本地开发服务器，这个本地服务器基于node,js搭建，内部使用express框架，可以实现我们想要的让浏览器自动刷新显示我们修改后的结果。</li><li> 安装：npm install –save-dev webpack-dev-server</li><li> devserver也是作为webpack中的一个选项，选项本身可以设置如下属性：</li></ol><!----><ol><li><ol><li> contentBase：为哪一个文件夹提供本地服务，默认是根文件夹，</li><li> port：端口号</li><li> inline：页面实时刷新</li><li> historyApiFallback：在SPA页面中，依赖HTML5的history模式</li></ol></li></ol><!----><ol start="4"><li> webpack.config.js文件配置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">  contentBase:&#x27;/dist&#x27;,</span><br><span class="line">    inline:true</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>5.运行执行指令:webpack-dev-server<br>可以修改package-json里设置指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server&quot;</span><br></pre></td></tr></table></figure><h1 id="九、-配置文件分离"><a href="#九、-配置文件分离" class="headerlink" title="九、 配置文件分离"></a>九、 配置文件分离</h1><ol><li> 安装：npm install webpack-merge –save-dev</li><li> 引入依赖</li></ol><p>例：对prod.config,js进行合并</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const uglifyjsPlugin = require(&#x27;uglifyjs-webpack-plugin&#x27;)</span><br><span class="line">const webpackMerge = require(&#x27;webpack-merge&#x27;)</span><br><span class="line">const baseConfig = require(&#x27;./base.config&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = webpackMerge(baseConfig, &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        new uglifyjsPlugin()</span><br><span class="line">    ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="十、打包时出现的一些错误"><a href="#十、打包时出现的一些错误" class="headerlink" title="十、打包时出现的一些错误"></a>十、打包时出现的一些错误</h1><h3 id="1-没有引用对应loader"><a href="#1-没有引用对应loader" class="headerlink" title="1.没有引用对应loader"></a>1.没有引用对应loader</h3><img src="/2023/03/06/Webpack%E5%AD%A6%E4%B9%A0/b.png" class title="没有引用对应loader"><p>解决：下载对应loader包</p><h3 id="2-版本不一致"><a href="#2-版本不一致" class="headerlink" title="2.版本不一致"></a>2.版本不一致</h3><img src="/2023/03/06/Webpack%E5%AD%A6%E4%B9%A0/c.png" class title="版本不一致"><p>解决：安装对应的版本：npm install –save-dev less-loader@版本 less@版本</p><h3 id="3-图片不显示"><a href="#3-图片不显示" class="headerlink" title="3.图片不显示"></a>3.图片不显示</h3><ol><li> 修改路径</li><li> 配置webpack.config.js文件</li></ol><p>publicPath:’./dist/‘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#x27;./src/main.js&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">        filename: &#x27;bundle.js&#x27;,</span><br><span class="line">        publicPath:&#x27;./dist/&#x27;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3初学习</title>
      <link href="/2023/03/06/Vue3%E5%88%9D%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/03/06/Vue3%E5%88%9D%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h2><ul><li><ul><li>  打包大小减少41%</li><li>  初次渲染快55%，更新渲染快133%</li><li>  内存减少54%</li></ul></li></ul><h2 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h2><ul><li><ul><li>  使用Proxy代替defineProperty实现响应式</li><li>  重写虚拟DOM实现和Tree-Shaking（剔除没有用的代码）</li></ul></li></ul><h2 id="3-拥抱TYpeScript"><a href="#3-拥抱TYpeScript" class="headerlink" title="3.拥抱TYpeScript"></a>3.拥抱TYpeScript</h2><ul><li><ul><li>  Vue3可以更好的支持TypeScript</li></ul></li></ul><h2 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h2><ul><li><ul><li>  Composition API（组合API）</li></ul></li></ul><!----><ul><li><ul><li><ul><li>setup配置<ul><li>  ref与reactive</li><li>  watch与watchEffect</li><li>  provide与inject</li><li>  …</li></ul></li></ul></li></ul></li></ul><!----><ul><li><ul><li>  新的内置组件</li></ul></li></ul><!----><ul><li><ul><li><ul><li>Fragment<ul><li>  Teieport</li><li>  Suspense</li></ul></li></ul></li></ul></li></ul><!----><ul><li><ul><li>  其他改变</li></ul></li></ul><!----><ul><li><ul><li><ul><li>新的生命周期钩子<ul><li>  data选项应始终被声明为一个函数</li><li>  移除keyCode支持作为v-on的修饰符</li><li>  …</li></ul></li></ul></li></ul></li></ul><h1 id="二、-创建Vue"><a href="#二、-创建Vue" class="headerlink" title="二、 创建Vue"></a>二、 创建Vue</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//检查版本</span><br><span class="line">vue --version</span><br><span class="line"></span><br><span class="line">//安装</span><br><span class="line">install -g @vue/cli</span><br></pre></td></tr></table></figure><h3 id="1-使用vite创建"><a href="#1-使用vite创建" class="headerlink" title="1. 使用vite创建"></a>1. 使用vite创建</h3><h4 id="1-1简介："><a href="#1-1简介：" class="headerlink" title="1.1简介："></a>1.1简介：</h4><ul><li>  什么式vite？ –新一代前端构建工具</li><li>  优势如下：</li></ul><!----><ul><li><ul><li>  开发环境中，无需打包操作，可快速的冷启动</li><li>  轻量快速的热重载（HMR）</li><li>  真正的按需编译，不再等待整个应用编译完成</li></ul></li></ul><!----><ul><li>  传统构建与vite构建对比图</li></ul><img src="/2023/03/06/Vue3%E5%88%9D%E5%AD%A6%E4%B9%A0/vite1.png" class title="vite构建对比图"><img src="/2023/03/06/Vue3%E5%88%9D%E5%AD%A6%E4%B9%A0/vite2.png" class title="vite构建对比图"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建工程</span><br><span class="line">npm init vite-app &lt;project-name&gt;</span><br><span class="line">// 进入工程目录</span><br><span class="line">cd &lt;project-name&gt;</span><br><span class="line">// 安装依赖</span><br><span class="line">npm i</span><br><span class="line">// 运行</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h1 id="三、常用Composition-Api"><a href="#三、常用Composition-Api" class="headerlink" title="三、常用Composition Api"></a>三、常用Composition Api</h1><h2 id="1-拉开序幕的setup"><a href="#1-拉开序幕的setup" class="headerlink" title="1. 拉开序幕的setup"></a>1. 拉开序幕的setup</h2><ol><li> 理解：Vue3.0中一个新的配置项，值为一个函数；</li><li> setup是所有Composition API（组合API）“表演的舞台”</li><li> 组件中所用到的：数据，方法等等，均要配置在setup中；</li><li> setup函数的两种返回值：</li></ol><!----><ol><li><ol><li> 若放回一个对象，则对象中的属性、方法、在模板中均可直接使用。</li><li> 若放回一个渲染函数：则可以自定义渲染内容</li></ol></li></ol><!----><ol start="5"><li> 注意点：</li></ol><ul><li><ul><li>  尽量不要与Vue2.x配置混用</li></ul></li></ul><!----><ul><li><ul><li><ul><li>Vue2.x配置（data、methods、computed…）中可以访问到setup中的属性、方法。<ul><li>  但在setup中不能访问到Vue2.x配置（data、methods、computed..）</li><li>  如果有重名，setup优先</li></ul></li></ul></li></ul></li></ul><!----><ul><li><ul><li>  setup不能是一个async函数，因为返回值不再是retuen的对象，而是promise，模板看不到return对象中的属性。(后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合)</li></ul></li></ul><h2 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2. ref函数"></a>2. ref函数</h2><ul><li>  作用：定义一个响应式的数据</li><li>  语法：<code>const xxx = ref(initValue)</code></li></ul><!----><ul><li><ul><li>  创建一个包含响应式数据的引用对象（reference对象，简称ref对象）</li><li>  JS中操作数据：<code>xxx.value</code></li><li>  模板中读取数据：不需要.value，直接<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li></ul></li></ul><!----><ul><li>  备注：</li></ul><!----><ul><li><ul><li>  接受的数据可以是：基本类型、也可以是对象类型</li><li>  基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的get与set完成的</li><li>  对象类型的数据：内部“求助”了Vue3.0中的一个函数——<code>reative</code>函数</li></ul></li></ul><h2 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h2><ul><li>  作用：定义一个对象类型的响应式数据（基本类型不要用它，用ref）数组</li><li>  语法：<code>const 代理对象 = reactive（源对象）</code>接收一个对象（或数组），返回一个代理对象（proxy对象）</li><li>  reactive定义的响应式数据是“深层次的”</li><li>  内部基于ES6的Proxy实现，通过代理对象操作源对象内部数据进行操作</li></ul><h2 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h2><ul><li>  从定义数据角度对比：</li></ul><!----><ul><li><ul><li>  ref用来定义： 基本类型数据</li><li>  reactive用来定义：对象（或数组）类型数据</li><li>  备注：ref也可以用来定义对象（或数组）类型数据，它内部会自动通过<code>reactive</code>转为代理对象</li></ul></li></ul><!----><ul><li>  从原理角度对比:</li></ul><!----><ul><li><ul><li>  ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）</li><li>  reactive通过使用Proxy来实现响应式（数据劫持），并通过Reflect操作源对象内部的数据</li></ul></li></ul><!----><ul><li>  从使用角度对比：</li></ul><!----><ul><li><ul><li>  ref定义的数据：操作数据需要<code>.value</code>，读取数据时模板中直接读取不需要<code>.value</code></li><li>  reactive定义的数据：操作数据与读取数据:均不需要<code>.value</code></li></ul></li></ul><h2 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h2><ul><li>  setup执行的时机</li></ul><!----><ul><li><ul><li>  在beforeCreate之前执行一次，this时undefined</li></ul></li></ul><!----><ul><li>  setup的参数</li></ul><!----><ul><li><ul><li>  props：值为对象，包含：组件外部传递过来，且组件内部声明接收了属性</li><li>  context：上下文对象</li></ul></li></ul><!----><ul><li><ul><li><ul><li>attrs：值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性，相当于<code>this.$attrs</code><ul><li>  slots:收到的插槽内容，相当于<code>this.$slots</code></li><li>  emit:分发自定义事件的函数，相当于<code>this.$emit</code></li></ul></li></ul></li></ul></li></ul><h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h3><ul><li>  与Vue2.x中computed配置功能一致</li><li>  写法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reactive, computed &#125; from &#x27;vue&#x27; </span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    let person2 = reactive(&#123;</span><br><span class="line">      firstname: &#x27;张&#x27;,</span><br><span class="line">      lastname:&#x27;三&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    person2.fullname = computed(&#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        return person2.firstname + &#x27;-&#x27; + person2.lastname</span><br><span class="line">      &#125;,</span><br><span class="line">      set(value) &#123;</span><br><span class="line">        const nameArr = value.split(&#x27;-&#x27;)</span><br><span class="line">        person2.firstname = nameArr[0]</span><br><span class="line">        person2.lastname = nameArr[1]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      person2,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h3><ul><li>  与Vue2.x中watch配置功能一致</li><li>  两个小坑“</li></ul><!----><ul><li><ul><li>  监视reactive定义的响应式数据时：oldValue无法准确获取、强制开启了深度监视（deep配置失效）</li><li>  监视reactive定义的响应式数据中某个属性时：deep配置有效</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/watch</span><br><span class="line">  //#region</span><br><span class="line">  let sum = ref(0)</span><br><span class="line">  let msg = ref(&#x27;你好啊&#x27;)</span><br><span class="line">    </span><br><span class="line">  // 情况一：监视ref所定义的一个响应式数据</span><br><span class="line">  // watch(sum,(newValue,oldValue) =&gt; &#123;</span><br><span class="line">  //   console.log(&#x27;sum变了&#x27;,newValue,oldValue)</span><br><span class="line">  // &#125;,&#123;immediate:true&#125;)</span><br><span class="line">  </span><br><span class="line">  // 情况二：监视ref所定义的多个响应式数据</span><br><span class="line">  // watch([sum,msg],(newValue,oldValue) =&gt; &#123;</span><br><span class="line">  //   console.log(&#x27;sum或msg变了&#x27;,newValue,oldValue)</span><br><span class="line">  // &#125;,&#123;immediate:true&#125;)  </span><br><span class="line"></span><br><span class="line">  // 情况三：监视reactive所定义的一个响应式数据，</span><br><span class="line">  // 1.注意：此处无法正确获取oldValue</span><br><span class="line">  // 2.注意：强制开启了深度监视（deep配置无效）</span><br><span class="line"></span><br><span class="line">  // watch(person2,(newValue, oldValue) =&gt; &#123;</span><br><span class="line">  //   console.log(&#x27;person变了&#x27;,newValue,oldValue)</span><br><span class="line">  // &#125;)</span><br><span class="line"></span><br><span class="line">  // 情况四：监视reactive所定义的一个响应式数据中的某个属性</span><br><span class="line">  //   watch(() =&gt; person2.age,(newValue, oldValue) =&gt; &#123;</span><br><span class="line">  //   console.log(&#x27;person的age变了&#x27;,newValue,oldValue)</span><br><span class="line">  // &#125;)</span><br><span class="line"></span><br><span class="line">  // 情况五：监视reactive所定义的一个响应式中的某些属性</span><br><span class="line">  // watch([() =&gt; person2.name,() =&gt; person2.age],(newValue, oldValue) =&gt; &#123;</span><br><span class="line">  //   console.log(&#x27;person的age变了&#x27;,newValue,oldValue)</span><br><span class="line">  // &#125;)</span><br><span class="line"></span><br><span class="line">  //特殊情况： 监视reactive所定义的一个深层次的属性，要开启深度监视</span><br><span class="line">  // watch([() =&gt; person2.name,() =&gt; person2.age],(newValue, oldValue) =&gt; &#123;</span><br><span class="line">  //   console.log(&#x27;person的age变了&#x27;,newValue,oldValue)</span><br><span class="line">  // &#125;)</span><br><span class="line"></span><br><span class="line">  //#endregion</span><br></pre></td></tr></table></figure><h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h3><ul><li>  watch的规则是：既要指明监视的属性，也要指明监视的回调</li><li>  watchEffect的规则是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性</li><li>  watchEffect有点像computed：</li></ul><!----><ul><li><ul><li>  但computed注重的是计算出来的值（回调函数的返回值），所以必须要写返回值</li><li>  而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(() =&gt; &#123;</span><br><span class="line">  const x1 = sum.value</span><br><span class="line">  console.log(&#x27;watchEffect所指定的回调执行了&#x27;,x1)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><ul><li>  1</li><li>  Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有两个被更名：</li></ul><!----><ul><li><ul><li>  beforeDestroy改名为beforeUnmount</li><li>  destroyed改名为unmounted</li></ul></li></ul><!----><ul><li>  Vue3.0也提供了Composition API形式的生命周期钩子，与Vue2.x中钩子对应关系如下：</li></ul><table><thead><tr><th>选项式 API</th><th>Hook inside setup</th></tr></thead><tbody><tr><td>beforeCreate</td><td>Not needed*</td></tr><tr><td>created</td><td>Not needed*</td></tr><tr><td>beforeMount</td><td>onBeforeMount</td></tr><tr><td>mounted</td><td>onMounted</td></tr><tr><td>beforeUpdate</td><td>onBeforeUpdate</td></tr><tr><td>updated</td><td>onUpdated</td></tr><tr><td>beforeUnmount</td><td>onBeforeUnmount</td></tr><tr><td>unmounted</td><td>onUnmounted</td></tr><tr><td>errorCaptured</td><td>onErrorCaptured</td></tr><tr><td>renderTracked</td><td>onRenderTracked</td></tr><tr><td>renderTriggered</td><td>onRenderTriggered</td></tr><tr><td>activated</td><td>onActivated</td></tr><tr><td>deactivated</td><td>onDeactivated</td></tr></tbody></table><h2 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h2><ul><li>  什么是hook？——本质是一个函数，把setup函数中使用的Composition API进行了封装</li><li>  类似于vue2.0中的mixin</li><li>  自定义hook的优势：复用代码，让setup中的逻辑更清楚易懂</li></ul><h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul><li>  作用：创建一个ref对象，其value值指向另一个对象中的某个属性；</li><li>  语法：<code>const name = toRef(person,&#39;name&#39;)</code></li><li>  应用：要将响应式对象中的某个属性单独提供给外部使用时；</li><li>  扩展：<code>toRefs</code>与<code>toRef</code>功能一致，但可以批量创建多个ref对象，语法<code>toRefs(person)</code></li></ul><h1 id="四、-其他Composition-API"><a href="#四、-其他Composition-API" class="headerlink" title="四、 其他Composition API"></a>四、 其他Composition API</h1><h2 id="1-shallowReactive与shallowRef"><a href="#1-shallowReactive与shallowRef" class="headerlink" title="1.shallowReactive与shallowRef"></a>1.shallowReactive与shallowRef</h2><ul><li>  shallowReactive：只处理对象最外层属性的响应式（浅响应式）</li><li>  shallowRef：只处理基本数据类型的响应式，不进行对象的响应式处理</li><li>  什么时候使用?</li></ul><!----><ul><li><ul><li>  如果有一个对象数据，结构比较深，但变化时只是外层属性变化 ===&gt; shallowReactive</li><li>  如果一个对象数据，后续功能不会修改该对象中的属性，而是生成新的对象来替换 ===&gt; shallowRef</li></ul></li></ul><h2 id="2-readonly与shallowReadonly"><a href="#2-readonly与shallowReadonly" class="headerlink" title="2.readonly与shallowReadonly"></a>2.readonly与shallowReadonly</h2><ul><li>  readonly：让一个响应式数据变为只读的（深只读）</li><li>  shallowReadonly：让一个响应式数据变为只读的（钱只读）</li><li>  应用场景：不希望数据被修改</li></ul><h2 id="3-toRaw与markRaw"><a href="#3-toRaw与markRaw" class="headerlink" title="3.toRaw与markRaw"></a>3.toRaw与markRaw</h2><ul><li>  toRaw：</li></ul><!----><ul><li><ul><li>  作用：将一个由<code>reactive</code>生成的响应式对象转为普遍对象</li><li>  使用场景：用于读取响应式对象对应的普遍对象，对这个普遍对象的所以操作，不会引起页面的更新</li></ul></li></ul><!----><ul><li>  markRaw：</li></ul><!----><ul><li><ul><li>  作用：标记一个对象，使其永远不会再成为响应式对象</li><li>  应用场景：</li></ul></li></ul><!----><ul><li><ul><li><ul><li>有些值不应被设置为响应式的，例如复杂的第三方类库等<ul><li>  当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能</li></ul></li></ul></li></ul></li></ul><h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul><li>  作用：创建一个自定义的ref，并对其依赖项跟踪和更新触发进行显示控制</li><li>  实现防抖效果：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;keyWord&quot;&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123;keyWord&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">  import &#123;customRef&#125; from &#x27;vue&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name:&#x27;DemoCustomRef&#x27;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">      function myRef(value,delay) &#123;</span><br><span class="line">        let timer</span><br><span class="line">        return customRef((track, trigger) =&gt; &#123;</span><br><span class="line">          return &#123;</span><br><span class="line">            get() &#123;</span><br><span class="line">              console.log(`有人从myRef这个容器中读取了数据，我把$&#123;value&#125;给他了`)</span><br><span class="line">              track()</span><br><span class="line">              return value</span><br><span class="line">            &#125;,</span><br><span class="line">            set(newValue) &#123;</span><br><span class="line">              console.log(`有人把myRef这个容器中的数据改为了：$&#123;newValue&#125;`)</span><br><span class="line">              clearTimeout(timer)</span><br><span class="line">              timer = setTimeout(() =&gt; &#123;</span><br><span class="line">                value = newValue</span><br><span class="line">                trigger()</span><br><span class="line">              &#125;,delay)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      let keyWord = myRef(&#x27;hello&#x27;,500)</span><br><span class="line"></span><br><span class="line">      return &#123;keyWord&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="5-provide与inject"><a href="#5-provide与inject" class="headerlink" title="5.provide与inject"></a>5.provide与inject</h2><ul><li>  作用：实现祖组件与后代组件间的通信</li><li>  套路：父组件有一个<code>provide</code>选项来提供数据，后代组件有一个<code>inject</code>选项来开始使用这些数据</li><li>  具体写法</li></ul><ol><li> 祖组件中：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setup() &#123;</span><br><span class="line">  ...</span><br><span class="line">  let car = reactive(&#123;</span><br><span class="line">    carnaem:&#x27;奔驰&#x27;,</span><br><span class="line">    carprice: &#x27;40W&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  provide(&#x27;car&#x27;,car) // 给自己的后代组件传递数据</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li> 后代组件中</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">setup() &#123;</span><br><span class="line">    let car = inject(&#x27;car&#x27;)</span><br><span class="line">    return &#123;car&#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul><li>  isRef：检查一个值是否为一个ref对象</li><li>  isReactive：检查一个对象是否是由<code>readonly</code>创建的响应式代理</li><li>  isReadonly：检查一个对象是否是由<code>readonly</code>创建的只读代理</li><li>  isProxy：创建一个对象是否是由<code>reactive</code>或者<code>readonly</code>方法创建的代理</li></ul><h1 id="五、Composition-API的优势"><a href="#五、Composition-API的优势" class="headerlink" title="五、Composition API的优势"></a>五、Composition API的优势</h1><h2 id="1-Options-API存在的问题"><a href="#1-Options-API存在的问题" class="headerlink" title="1.Options API存在的问题"></a>1.Options API存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别再data，methods，computed里修改</p><h2 id="2-Composition-API的优势"><a href="#2-Composition-API的优势" class="headerlink" title="2.Composition API的优势"></a>2.Composition API的优势</h2><p>可以更加优雅的组织代码，函数，让相关功能的代码更加有序的组织再一起</p><h1 id="六、-新的组件"><a href="#六、-新的组件" class="headerlink" title="六、 新的组件"></a>六、 新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul><li>  在Vue2中：组件必须由一个根标签</li><li>  在Vue3中：组件可以没有根标签，内部会将多个标签包含在一个Fragment虚拟元素中</li><li>  好处：减少标签层级，减少内存占有</li></ul><h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul><li>  Teleport是一种能购将我们的组件html结构移动到指定位置的技术</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;button @click=&quot;isShow = true&quot;&gt;点击弹窗&lt;/button&gt;</span><br><span class="line">    &lt;teleport to = &quot;body&quot;&gt;</span><br><span class="line">      &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">          &lt;h3&gt;我是一个弹窗&lt;/h3&gt;</span><br><span class="line">          &lt;h4&gt;我是内容&lt;/h4&gt;</span><br><span class="line">          &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/teleport&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="3-Supense"><a href="#3-Supense" class="headerlink" title="3.Supense"></a>3.Supense</h2><ul><li>  等待异步组件时渲染一些额外内容，让应用有更好的用户体验</li><li>  使用步骤：</li></ul><!----><ul><li><ul><li>  异步引入组件</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;</span><br><span class="line">const Child = defineAsyncComponent(() =&gt; import(&#x27;./DemoSon.vue&#x27;))</span><br></pre></td></tr></table></figure><p>使用Suspense包裹组件，并配置好default与fallback</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;我是子组件&#123;&#123;sum&#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;suspense&gt;</span><br><span class="line">    &lt;template v-slot:default&gt;</span><br><span class="line">        &lt;!-- &lt;demo-son&gt;&lt;/demo-son&gt; --&gt;</span><br><span class="line">        &lt;child&gt;&lt;/child&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;template v-slot:fallback&gt;</span><br><span class="line">      &lt;h3&gt;稍等，加载中...&lt;/h3&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/suspense&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h1 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul><li>  Vue2.x有许多全局API和配置</li></ul><!----><ul><li><ul><li>  例如：注册全局组件、组成全局指令等</li></ul></li></ul><!----><ul><li>  Vue3.0中对这些API做出了调整：</li></ul><!----><ul><li><ul><li>  将全局的API，即：Vue.xxx调整到应用实例（app）上</li></ul></li></ul><table><thead><tr><th>2.x全局API（Vue）</th><th>3.x实例API（app）</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxxx</td></tr><tr><td>Vue.config.productionTip</td><td>移除</td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table><h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul><li>  data选项应始终被声明为一个函数</li><li>  过度类名的更改：</li></ul><!----><ul><li><ul><li>  Vue2.x写法</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.v-enter,</span><br><span class="line">.v-leave-to &#123;</span><br><span class="line"> opacity: 0; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.v-leave,</span><br><span class="line">.v-enter-to &#123;</span><br><span class="line"> opacity: 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ul><li>  Vue3.x写法</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.v-enter-from，</span><br><span class="line">.v-leave-to &#123;</span><br><span class="line">   opacity:0; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.v-leave-from,</span><br><span class="line">.v-enter-to &#123;</span><br><span class="line">   opaciyt: 1; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>  移除keyCode作为v-on的修饰符，同时也不再支持<code>config.keyCodes</code></li><li>  移除<code>v-on.native</code>修饰符</li></ul><!----><ul><li><ul><li>  父组件中绑定事件</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component&gt;</span><br><span class="line">  v-on:close = &quot;handleComponentEvent&quot;</span><br><span class="line">  v-on:click = &quot;handleNativeClickEvent&quot;</span><br><span class="line">&lt;my-component/&gt;</span><br></pre></td></tr></table></figure><ul><li><ul><li>  子组件中声明自定义事件</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   export default &#123;</span><br><span class="line">     emit: [&#x27;close&#x27;, &#x27;click&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>  移除过滤器（filter）</li></ul><!----><ul><li><ul><li>  使用起来不方便，建议直接使用方法调用或计算属性去替换过滤器</li></ul></li></ul><h1 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h1><h2 id="1-文件首行标红"><a href="#1-文件首行标红" class="headerlink" title="1. 文件首行标红"></a>1. 文件首行标红</h2><img src="/2023/03/06/Vue3%E5%88%9D%E5%AD%A6%E4%B9%A0/c.png" class title="文件首行标红">]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js学习</title>
      <link href="/2023/03/05/Node-js%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/03/05/Node-js%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-js基础"><a href="#Node-js基础" class="headerlink" title="Node.js基础"></a>Node.js基础</h1><h2 id="初识-Nodejs"><a href="#初识-Nodejs" class="headerlink" title="初识 Nodejs"></a>初识 Nodejs</h2><p><strong>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine</strong></p><p><strong>Node.js® 是一个基于 Chrome V8 引擎 的 JavaScript 运行时环境</strong></p><ul><li>  基于 <a href="http://www.expressjs.com.cn/">Express 框架(opens new window)</a>，可以快速构建 Web 应用</li><li>  基于 <a href="https://electronjs.org/">Electron 框架(opens new window)</a>，可以构建跨平台的桌面应用</li><li>  基于 <a href="http://restify.com/">restify 框架(opens new window)</a>，可以快速构建 API 接口项目</li><li>  读写和操作数据库、创建实用的命令行工具辅助前端开发、etc…</li></ul><h2 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer 缓冲区"></a>Buffer 缓冲区</h2><p><a href="http://nodejs.cn/api/buffer.html">Buffer 缓冲区文档(opens new window)</a></p><ul><li>  Buffer 的结构与数组类似，操作方法也与数组类似</li><li>  数组不能存储二进制文件，Buffer 是专门存储二进制数据的</li><li>  Buffer 存储的是二进制数据，显示时以 16 进制的形式显示</li><li>  Buffer 每一个元素范围是 00<del>ff，即 0</del>255、00000000~11111111</li><li>  每一个元素占用一个字节内存</li><li>  Buffer 是对底层内存的直接操作，因此大小一旦确定就不能修改</li></ul><p>Buffer 常用方法：</p><ul><li>  Buffer.from(str[, encoding])：将一个字符串转换为 Buffer</li><li>  Buffer.alloc(size)：创建指定大小的 Buffer</li><li>  Buffer.alloUnsafe(size)：创建指定大小的 Buffer，可能包含敏感数据（分配内存时不会清除内存残留的数据）</li><li>  buf.toString()：将 Buffer 数据转为字符串</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;Hello前端&#x27;</span><br><span class="line"></span><br><span class="line">var buf = Buffer.from(str)</span><br><span class="line"></span><br><span class="line">// 占用内存的大小，一个汉字3字节 13</span><br><span class="line">console.log(buf.length)</span><br><span class="line">// 字符串的长度 7</span><br><span class="line">console.log(str.length)</span><br><span class="line">// 8进制输出第一个元素 145</span><br><span class="line">console.log(buf[1].toString(8))</span><br><span class="line"></span><br><span class="line">//创建一个10个字节的buffer</span><br><span class="line">var buf2 = Buffer.alloc(10)</span><br><span class="line">//通过索引，来操作buf中的元素</span><br><span class="line">buf2[0] = 88</span><br><span class="line">buf2[1] = 255</span><br><span class="line">buf2[2] = 0xaa</span><br><span class="line">buf2[3] = 255</span><br><span class="line"></span><br><span class="line">var buf3 = Buffer.allocUnsafe(10)</span><br><span class="line">console.log(buf3)</span><br></pre></td></tr></table></figure><h2 id="fs-文件系统模块"><a href="#fs-文件系统模块" class="headerlink" title="fs 文件系统模块"></a>fs 文件系统模块</h2><ul><li>  fs 模块中所有的操作都有两种形式可供选择:同步和异步</li><li>  同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码</li><li>  异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回</li><li>  实际开发很少用同步方式，因此只介绍异步方式</li></ul><p>打开模式：</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>r</td><td>读取文件，文件不存在抛异常</td></tr><tr><td>r+</td><td>读写文件，文件不存在抛异常</td></tr><tr><td>rs</td><td>同步模式下打开文件用于读取</td></tr><tr><td>rs+</td><td>同步模式下打开文件用于读写</td></tr><tr><td>w</td><td>写文件，不存在则创建，存在则覆盖原有内容</td></tr><tr><td>wx</td><td>写文件，文件存在打开失败</td></tr><tr><td>w+</td><td>读写文件，不存在创建，存在截断</td></tr><tr><td>wx+</td><td>读写，存在打开失败</td></tr><tr><td>a</td><td>追加，不存在创建</td></tr><tr><td>ax</td><td>追加，存在失败</td></tr><tr><td>a+</td><td>追加和读取，不存在创建</td></tr><tr><td>ax+</td><td>追加和读取，存在失败</td></tr></tbody></table><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><h4 id="简单文件读取"><a href="#简单文件读取" class="headerlink" title="简单文件读取"></a>简单文件读取</h4><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(path[, options], callback)</span><br></pre></td></tr></table></figure><ul><li>  path：文件路径</li><li>  options：配置选项，若是字符串则指定编码格式</li></ul><!----><ul><li><ul><li>  encoding：编码格式</li><li>  flag：打开方式</li></ul></li></ul><!----><ul><li>  callback：回调函数</li></ul><!----><ul><li><ul><li>  err：错误信息</li><li>  data：读取的数据，如果未指定编码格式则返回一个 Buffer</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">fs.readFile(&#x27;./files/1.txt&#x27;, &#x27;utf-8&#x27;, function(err, data) =&gt; &#123;</span><br><span class="line">  if(err) &#123;</span><br><span class="line">    return console.log(&#x27;failed!&#x27; + err.message)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#x27;content:&#x27; + data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 复制文件内容</span><br><span class="line">fs.readFile(&quot;C:/Users/笔记.mp3&quot;, function(err, data) &#123;</span><br><span class="line">if(!err) &#123;</span><br><span class="line">console.log(data);</span><br><span class="line">// 将data写入到文件中</span><br><span class="line">fs.writeFile(&quot;C:/Users/hello.jpg&quot;, data, function(err)&#123;</span><br><span class="line">if(!err)&#123;</span><br><span class="line">console.log(&quot;文件写入成功&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; );</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="流式文件读取"><a href="#流式文件读取" class="headerlink" title="流式文件读取"></a>流式文件读取</h4><ul><li>  简单文件读取的方式会一次性读取文件内容到内存中，若文件较大，会占用过多内存影响系统性能，且读取速度慢</li><li>  大文件适合用流式文件读取，它会分多次将文件读取到内存中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">// 创建一个可读流</span><br><span class="line">var rs = fs.createReadStream(&#x27;C:/Users/笔记.mp3&#x27;)</span><br><span class="line">// 创建一个可写流</span><br><span class="line">var ws = fs.createWriteStream(&#x27;a.mp3&#x27;)</span><br><span class="line"></span><br><span class="line">// 监听流的开启和关闭</span><br><span class="line">// 这几个监听不是必须的</span><br><span class="line">rs.once(&#x27;open&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;可读流打开了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.once(&#x27;close&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;可读流关闭了~~&#x27;)</span><br><span class="line">  //数据读取完毕，关闭可写流</span><br><span class="line">  ws.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&#x27;open&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;可写流打开了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&#x27;close&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;可写流关闭了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//要读取一个可读流中的数据，要为可读流绑定一个data事件，data事件绑定完毕自动开始读取数据</span><br><span class="line">rs.on(&#x27;data&#x27;, function (data) &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">  //将读取到的数据写入到可写流中</span><br><span class="line">  ws.write(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简便方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">var rs = fs.createReadStream(&#x27;C:/Users/lilichao/Desktop/笔记.mp3&#x27;)</span><br><span class="line">var ws = fs.createWriteStream(&#x27;b.mp3&#x27;)</span><br><span class="line"></span><br><span class="line">// pipe()可以将可读流中的内容，直接输出到可写流中</span><br><span class="line">rs.pipe(ws)</span><br></pre></td></tr></table></figure><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><h4 id="简单文件写入"><a href="#简单文件写入" class="headerlink" title="简单文件写入"></a>简单文件写入</h4><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(file, data[, options], callback) </span><br></pre></td></tr></table></figure><ul><li>  file：文件路径</li><li>  data：写入内容</li><li>  options：配置选项，包含 encoding, mode, flag；若是字符串则指定编码格式</li><li>  callback：回调函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">fs.writeFile(&#x27;./files/2.txt&#x27;, &#x27;Hello Nodejs&#x27;, function (err) &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    return console.log(&#x27;failed!&#x27; + err.message)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#x27;success!&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.writeFile(&#x27;C:/Users/hello.txt&#x27;, &#x27;通过 writeFile 写入的内容&#x27;, &#123; flag: &#x27;w&#x27; &#125;, function (err) &#123;</span><br><span class="line">  if (!err) &#123;</span><br><span class="line">    console.log(&#x27;写入成功！&#x27;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="流式文件写入"><a href="#流式文件写入" class="headerlink" title="流式文件写入"></a>流式文件写入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 同步、异步、简单文件的写入都不适合大文件的写入，性能较差，容易导致内存溢出</span><br><span class="line">var fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">// 创建一个可写流</span><br><span class="line">var ws = fs.createWriteStream(&#x27;hello3.txt&#x27;)</span><br><span class="line"></span><br><span class="line">ws.once(&#x27;open&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;流打开了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&#x27;close&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;流关闭了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 通过ws向文件中输出内容</span><br><span class="line">ws.write(&#x27;通过可写流写入文件的内容&#x27;)</span><br><span class="line">ws.write(&#x27;1&#x27;)</span><br><span class="line">ws.write(&#x27;2&#x27;)</span><br><span class="line">ws.write(&#x27;3&#x27;)</span><br><span class="line">ws.write(&#x27;4&#x27;)</span><br><span class="line"></span><br><span class="line">// 关闭流</span><br><span class="line">ws.end()</span><br></pre></td></tr></table></figure><h3 id="路径动态拼接问题-dirname"><a href="#路径动态拼接问题-dirname" class="headerlink" title="路径动态拼接问题 __dirname"></a>路径动态拼接问题 __dirname</h3><ul><li>  在使用 fs 模块操作文件时，如果提供的操作路径是以 ./ 或 ../ 开头的相对路径时，容易出现路径动态拼接错误的问题</li><li>  原因：代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径</li><li>  解决方案：在使用 fs 模块操作文件时，直接提供完整的路径，从而防止路径动态拼接的问题</li><li>  __dirname 获取文件所处的绝对路径</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(__dirname + &#x27;/files/1.txt&#x27;, &#x27;utf8&#x27;, function(err, data) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h3><p>验证路径是否存在：</p><ul><li>  fs.exists(path, callback)</li><li>  fs.existsSync(path)</li></ul><p>获取文件信息：</p><ul><li>  fs.stat(path, callback)</li><li>  fs.stat(path)</li></ul><p>删除文件：</p><ul><li>  fs.unlink(path, callback)</li><li>  fs.unlinkSync(path)</li></ul><p>列出文件：</p><ul><li>  fs.readdir(path[,options], callback)</li><li>  fs.readdirSync(path[, options])</li></ul><p>截断文件：</p><ul><li>  fs.truncate(path, len, callback)</li><li>  fs.truncateSync(path, len)</li></ul><p>建立目录：</p><ul><li>  fs.mkdir(path[, mode], callback)</li><li>  fs.mkdirSync(path[, mode])</li></ul><p>删除目录：</p><ul><li>  fs.rmdir(path, callback)</li><li>  fs.rmdirSync(path)</li></ul><p>重命名文件和目录：</p><ul><li>  fs.rename(oldPath, newPath, callback)</li><li>  fs.renameSync(oldPath, newPath)</li></ul><p>监视文件更改：</p><ul><li>  fs.watchFile(filename[, options], listener)</li></ul><h2 id="path-路径模块"><a href="#path-路径模块" class="headerlink" title="path 路径模块"></a>path 路径模块</h2><p>path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。</p><h3 id="路径拼接-path-join"><a href="#路径拼接-path-join" class="headerlink" title="路径拼接 path.join()"></a>路径拼接 path.join()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">// 注意 ../ 会抵消前面的路径</span><br><span class="line">// ./ 会被忽略</span><br><span class="line">const pathStr = path.join(&#x27;/a&#x27;, &#x27;/b/c&#x27;, &#x27;../../&#x27;, &#x27;./d&#x27;, &#x27;e&#x27;)</span><br><span class="line">console.log(pathStr) // \a\d\e</span><br><span class="line"></span><br><span class="line">fs.readFile(path.join(__dirname, &#x27;./files/1.txt&#x27;), &#x27;utf8&#x27;, function (err, dataStr) &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    return console.log(err.message)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="获取路径中文件名-path-basename"><a href="#获取路径中文件名-path-basename" class="headerlink" title="获取路径中文件名 path.basename()"></a>获取路径中文件名 path.basename()</h3><p>使用 path.basename() 方法，可以获取路径中的最后一部分，常通过该方法获取路径中的文件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.basename(path[, ext])</span><br></pre></td></tr></table></figure><ul><li>  path: 文件路径</li><li>  ext: 文件扩展名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">// 定义文件的存放路径</span><br><span class="line">const fpath = &#x27;/a/b/c/index.html&#x27;</span><br><span class="line"></span><br><span class="line">const fullName = path.basename(fpath)</span><br><span class="line">console.log(fullName) // index.html</span><br><span class="line"></span><br><span class="line">const nameWithoutExt = path.basename(fpath, &#x27;.html&#x27;)</span><br><span class="line">console.log(nameWithoutExt) // index</span><br></pre></td></tr></table></figure><h3 id="获取路径中文件扩展名-path-extname"><a href="#获取路径中文件扩展名-path-extname" class="headerlink" title="获取路径中文件扩展名 path.extname()"></a>获取路径中文件扩展名 path.extname()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">const fpath = &#x27;/a/b/c/index.html&#x27;</span><br><span class="line"></span><br><span class="line">const fext = path.extname(fpath)</span><br><span class="line">console.log(fext) // .html</span><br></pre></td></tr></table></figure><h2 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h2><p>http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。</p><h3 id="创建基本-Web-服务器"><a href="#创建基本-Web-服务器" class="headerlink" title="创建基本 Web 服务器"></a>创建基本 Web 服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;)</span><br><span class="line"></span><br><span class="line">// 创建 web 服务器实例</span><br><span class="line">const server = http.createServer()</span><br><span class="line"></span><br><span class="line">// 为服务器实例绑定 request 事件，监听客户端的请求</span><br><span class="line">server.on(&#x27;request&#x27;, function (req, res) &#123;</span><br><span class="line">  const url = req.url</span><br><span class="line">  const method = req.method</span><br><span class="line">  const str = `Your request url is $&#123;url&#125;, and request method is $&#123;method&#125;`</span><br><span class="line">  console.log(str)</span><br><span class="line"></span><br><span class="line">  // 设置 Content-Type 响应头，解决中文乱码的问题</span><br><span class="line">  res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;)</span><br><span class="line">  // 向客户端响应内容</span><br><span class="line">  res.end(str)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(8080, function () &#123;</span><br><span class="line">  console.log(&#x27;server running at http://127.0.0.1:8080&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="实现简陋路由效果"><a href="#实现简陋路由效果" class="headerlink" title="实现简陋路由效果"></a>实现简陋路由效果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;)</span><br><span class="line">const server = http.createServer()</span><br><span class="line"></span><br><span class="line">server.on(&#x27;request&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  const url = req.url</span><br><span class="line">  // 设置默认的响应内容为 404 Not found</span><br><span class="line">  let content = &#x27;&lt;h1&gt;404 Not found!&lt;/h1&gt;&#x27;</span><br><span class="line">  // 判断用户请求的是否为 / 或 /index.html 首页</span><br><span class="line">  // 判断用户请求的是否为 /about.html 关于页面</span><br><span class="line">  if (url === &#x27;/&#x27; || url === &#x27;/index.html&#x27;) &#123;</span><br><span class="line">    content = &#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27;</span><br><span class="line">  &#125; else if (url === &#x27;/about.html&#x27;) &#123;</span><br><span class="line">    content = &#x27;&lt;h1&gt;关于页面&lt;/h1&gt;&#x27;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;)</span><br><span class="line">  res.end(content)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(80, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;server running at http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="模块化概念"><a href="#模块化概念" class="headerlink" title="模块化概念"></a>模块化概念</h3><ul><li>  模块化是指解决一个复杂问题时，自顶向下逐层把系统划分为若干模块的过程，模块是可组合、分解和更换的单元。</li><li>  模块化可提高代码的复用性和可维护性，实现按需加载。</li><li>  模块化规范是对代码进行模块化拆分和组合时需要遵守的规则，如使用何种语法格式引用模块和向外暴露成员。</li></ul><h3 id="Node-js-中模块的分类"><a href="#Node-js-中模块的分类" class="headerlink" title="Node.js 中模块的分类"></a>Node.js 中模块的分类</h3><ul><li>  内置模块</li><li>  自定义模块</li><li>  第三方模块</li></ul><h3 id="Node-js-中的模块作用域"><a href="#Node-js-中的模块作用域" class="headerlink" title="Node.js 中的模块作用域"></a>Node.js 中的模块作用域</h3><ul><li>  和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域</li><li>  防止全局变量污染</li></ul><h3 id="模块作用域的成员"><a href="#模块作用域的成员" class="headerlink" title="模块作用域的成员"></a>模块作用域的成员</h3><ul><li>  自定义模块中都有一个 module 对象，存储了和当前模块有关的信息</li><li>  在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。导入自定义模块时，得到的就是 module.exports 指向的对象。</li><li>  默认情况下，exports 和 module.exports 指向同一个对象。最终共享的结果，以 module.exports 指向的对象为准。</li></ul><h3 id="CommonJS-模块化规范"><a href="#CommonJS-模块化规范" class="headerlink" title="CommonJS 模块化规范"></a>CommonJS 模块化规范</h3><ul><li>  每个模块内部，module 变量代表当前模块</li><li>  module 变量是一个对象，module.exports 是对外的接口</li><li>  加载某个模块即加载该模块的 module.exports 属性</li></ul><h3 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h3><p>模块第一次加载后会被缓存，即多次调用 require() 不会导致模块的代码被执行多次，提高模块加载效率。</p><h4 id="内置模块加载"><a href="#内置模块加载" class="headerlink" title="内置模块加载"></a>内置模块加载</h4><p>内置模块加载优先级最高。</p><h4 id="自定义模块加载"><a href="#自定义模块加载" class="headerlink" title="自定义模块加载"></a>自定义模块加载</h4><p>加载自定义模块时，路径要以 ./ 或 ../ 开头，否则会作为内置模块或第三方模块加载。</p><p>导入自定义模块时，若省略文件扩展名，则 Node.js 会按顺序尝试加载文件：</p><ul><li>  按确切的文件名加载</li><li>  补全 .js 扩展名加载</li><li>  补全 .json 扩展名加载</li><li>  补全 .node 扩展名加载</li><li>  加载失败，终端报错</li></ul><h4 id="第三方模块加载"><a href="#第三方模块加载" class="headerlink" title="第三方模块加载"></a>第三方模块加载</h4><ul><li>  若导入第三方模块， Node.js 会从<strong>当前模块的父目录</strong>开始，尝试从 /node_modules 文件夹中加载第三方模块。</li><li>  如果没有找到对应的第三方模块，则移动到再<strong>上一层父目录</strong>中，进行加载，直到<strong>文件系统的根目录</strong>。</li></ul><p>例如，假设在 C:\Users\itchen\project\foo.js 文件里调用了 require(‘tools’)，则 Node.js 会按以下顺序查找：</p><ul><li>  C:\Users\itchen\project\node_modules\tools</li><li>  C:\Users\itchen\node_modules\tools</li><li>  C:\Users\node_modules\tools</li><li>  C:\node_modules\tools</li></ul><h4 id="目录作为模块加载"><a href="#目录作为模块加载" class="headerlink" title="目录作为模块加载"></a>目录作为模块加载</h4><p>当把目录作为模块标识符进行加载的时候，有三种加载方式：</p><ul><li>  在被加载的目录下查找 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口</li><li>  如果没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。</li><li>如果以上两步都失败了，则Node.js会在终端打印错误消息，报告模板的缺失：Error: Cannot find module ‘xxx</li></ul><h2 id="3-Node-js与包"><a href="#3-Node-js与包" class="headerlink" title="3. Node.js与包"></a>3. Node.js与包</h2><h3 id="解决包下载速度慢的问题"><a href="#解决包下载速度慢的问题" class="headerlink" title="解决包下载速度慢的问题"></a>解决包下载速度慢的问题</h3><h4 id="1-nrm"><a href="#1-nrm" class="headerlink" title="1. nrm"></a>1. nrm</h4><p>为了更方便的切换下包的镜像资源，我们可以安装nrm这个小工具，利用nrm提供的终端命令，可以快速查看和切换下包的镜像资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 下载包</span><br><span class="line">npm i nrm -g</span><br><span class="line">// 查看所有可用的镜像资源</span><br><span class="line">nrm ls</span><br><span class="line">// 讲下包的镜像资源切换为taobao镜像</span><br><span class="line">nrm use taobao</span><br></pre></td></tr></table></figure><h3 id="开发属于自己的包"><a href="#开发属于自己的包" class="headerlink" title="开发属于自己的包"></a>开发属于自己的包</h3><h4 id="1-初始化包的基本结构"><a href="#1-初始化包的基本结构" class="headerlink" title="1. 初始化包的基本结构"></a>1. 初始化包的基本结构</h4><ol><li> 新建itfeng-tools文件夹，作为包的根目录</li><li> 在itfeng-tools文件夹中，新建如下三个文件</li></ol><ul><li>  package.json（包管理配置文件）</li><li>  index.js （包的入口文件）</li><li>  RWADME.md （包的说明文档）</li></ul><h4 id="2-初始化package-json"><a href="#2-初始化package-json" class="headerlink" title="2.初始化package.json"></a>2.初始化package.json</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;itfengzi-tools&quot;, // 包名称 注意包名不能与已经存在的报名重复</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,// 版本</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;, // 入口文件</span><br><span class="line">  &quot;description&quot;: &quot;提供了格式化时间，HTMLEscape相关的功能&quot;, // 包的介绍信息</span><br><span class="line">  &quot;keywords&quot;: [ // 搜索关键字</span><br><span class="line">    &quot;itfengzi&quot;,</span><br><span class="line">    &quot;dateFormat&quot;,</span><br><span class="line">    &quot;escape&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot; // 包遵循的许可协议</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h3><h4 id="1-注册npm账号"><a href="#1-注册npm账号" class="headerlink" title="1. 注册npm账号"></a>1. 注册npm账号</h4><ol><li> 访问<a href="https://www.npmjs.com/">https://www.npmjs.com/</a>网站，点击sign up按钮，进入注册用户界面</li><li> 填写账号相关信息：Full Name、Public Email、Username、Password</li><li> 点击Create an Account按钮，注册账号</li><li> 登录邮箱，点击验证链接，进行账号的验证</li></ol><h4 id="2-登录npm账号"><a href="#2-登录npm账号" class="headerlink" title="2.登录npm账号"></a>2.登录npm账号</h4><p>npm账号注册完成后，可以在终端中执行<code>npm login</code>命令，依次输入用户名、密码、邮箱后，即可登录成功</p><ul><li>  注意：在运行npm login命令之前，必须先把下包的服务器地址切换为npm的官方服务器，否则会导致发布包失败</li><li>  可以使用nrm工具切换下包服务器</li></ul><p><code>nrm use npm</code></p><h4 id="3-把包发布到npm上"><a href="#3-把包发布到npm上" class="headerlink" title="3.把包发布到npm上"></a>3.把包发布到npm上</h4><p>将终端切换到包的根目录之后，运行<code>npm publish</code>命令，即可将包发布到npm上</p><h4 id="4-删除已发布的包"><a href="#4-删除已发布的包" class="headerlink" title="4.删除已发布的包"></a>4.删除已发布的包</h4><p>运行<code>npm unpublish 包名 --force</code>命令，即可从npm删除已发布的包</p><p>注意：</p><ul><li>  npm unpublish 命令只能删除72小时以内发布的包</li><li>  npm unpublish 删除的包，在24小时内不允许重复发布</li><li>  发布包的时候要慎重，尽量不要发布没有意义的包</li></ul><h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><p><a href="https://www.expressjs.com.cn/">官网传送门(opens new window)</a></p><p><strong>基于 Node.js 平台，快速、开放、极简的 Web 开发框架</strong></p><p>Express 是用于快速创建服务器的第三方模块。</p><p>Express的本质：就是一个npm上的第三方包，提供了快速创建Web服务器的便捷方法</p><p>对于前端程序员来说，最常见的两种服务器，分别是：</p><ul><li>  Web网站服务器：专门对外提供Web网页资源的服务器</li><li>  API接口服务器：专门对外提供API接口的服务区</li></ul><p>使用Express，我们可以方便、快速的创建Web网站的服务器或API接口的服务器</p><h2 id="Express-初体验"><a href="#Express-初体验" class="headerlink" title="Express 初体验"></a>Express 初体验</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装 Express：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure><p>创建服务器，监听客户端请求，并返回内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">// 创建 web 服务器</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">// 监听客户端的 GET 和 POST 请求，并向客户端响应具体的内容</span><br><span class="line">app.get(&#x27;/user&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#123; name: &#x27;zs&#x27;, age: 20, gender: &#x27;男&#x27; &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.post(&#x27;/user&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;请求成功&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  // 通过 req.query 可以获取到客户端发送过来的查询参数</span><br><span class="line">  console.log(req.query)</span><br><span class="line">  res.send(req.query)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 这里的 :id 是一个动态的参数</span><br><span class="line">app.get(&#x27;/user/:ids/:username&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  // req.params 是动态匹配到的 URL 参数，默认是一个空对象</span><br><span class="line">  console.log(req.params)</span><br><span class="line">  res.send(req.params)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(80, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;express server running at http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h3><ul><li>  通过 express.static() 方法可创建静态资源服务器，向外开放访问静态资源。</li><li>  Express 在指定的静态目录中查找文件，并对外提供资源的访问路径，存放静态文件的目录名不会出现在 URL 中</li><li>  访问静态资源时，会根据托管顺序查找文件</li><li>  可为静态资源访问路径添加前缀</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(&#x27;public&#x27;))</span><br><span class="line">app.use(express.static(&#x27;files&#x27;))</span><br><span class="line">// 挂载路劲前缀</span><br><span class="line">app.use(&#x27;/bruce&#x27;, express.static(&#x27;bruce&#x27;))</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">可直接访问 public, files 目录下的静态资源</span><br><span class="line">http://localhost:3000/images/bg.jpg</span><br><span class="line">http://localhost:3000/css/style.css</span><br><span class="line">http://localhost:3000/js/login.js</span><br><span class="line"></span><br><span class="line">通过带有 /bruce 前缀的地址访问 bruce 目录下的文件</span><br><span class="line">http://localhost:8080/bruce/images/logo.png</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h3><p>安装nodemon</p><p><code>npm install -g nodemon</code></p><p>可以间node命令替换为nodemon命令，使用nodemon app.js来启动项目，这样启动之后代码被修改之后，会被nodemon监听到，从而实现自动重启项目的效果</p><h2 id="Express-路由"><a href="#Express-路由" class="headerlink" title="Express 路由"></a>Express 路由</h2><p>在express中，路由指的是客户端的请求与服务器处理函数之间的映射关系</p><p>Express中的路由分3部分组成，分别是请求的类型，请求的URL地址、处理函数</p><p><code>app.METHOD(PATH, HANDLER)</code></p><h3 id="路由的概念"><a href="#路由的概念" class="headerlink" title="路由的概念"></a>路由的概念</h3><h4 id="路由的匹配过程"><a href="#路由的匹配过程" class="headerlink" title="路由的匹配过程"></a>路由的匹配过程</h4><p>每当一个请求到服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数</p><p>在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的URL同时匹配成功，则Express会将这次请求，转交给对应的function函数进行处理</p><ul><li>  按照定义的先后顺序进行匹配</li><li>  请求类型和请求的URL同时匹配成功才会调用对应的处理函数</li></ul><h3 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h3><h4 id="路由基本使用"><a href="#路由基本使用" class="headerlink" title="路由基本使用"></a>路由基本使用</h4><p>创建路由模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">// 挂载路由</span><br><span class="line">app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;hello world&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.post(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;Post Request&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(81, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;express server running at http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="模块化路由"><a href="#模块化路由" class="headerlink" title="模块化路由"></a>模块化路由</h4><p>为了方便对路由进行模块化管理，Express不建议将路由直接挂载到app上，而是推荐将路由抽离为单独的模块；</p><ol><li> 创建路由模块对应的.js文件</li><li> 调用exoress.Router()函数创建路由对象</li><li> 向路由对象上挂载具体路由</li><li> 使用module.exports向外共享路由对象</li><li> 使用app.use()函数注册路由模块</li></ol><p>创建路由模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// router.js</span><br><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">// 创建路由对象</span><br><span class="line">const router = express.Router()</span><br><span class="line"></span><br><span class="line">// 挂载具体路由</span><br><span class="line">router.get(&#x27;/user/list&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;Get user list.&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">router.post(&#x27;/user/add&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;Add new user.&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 向外导出路由对象</span><br><span class="line">module.exports = router</span><br></pre></td></tr></table></figure><p>注册路由模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const router = require(&#x27;./router&#x27;)</span><br><span class="line"></span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">// 注册路由模块，添加访问前缀</span><br><span class="line">app.use(&#x27;/api&#x27;, router)</span><br><span class="line"></span><br><span class="line">app.listen(80, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Express-中间件"><a href="#Express-中间件" class="headerlink" title="Express 中间件"></a>Express 中间件</h2><ul><li>  中间件是指流程的中间处理环节</li><li>  服务器收到请求后，可先调用中间件进行预处理</li><li>  中间件是一个函数，包含 req, res, next 三个参数，next() 参数把流转关系转交给下一个中间件或路由</li></ul><p>中间件注意事项；</p><ul><li>  在注册路由之前注册中间件（错误级别中间件除外）</li><li>  当一个请求到达Express的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理</li><li>  中间件函数的形参列表中，必须包含next参数，而路由处理函数中只包含req和res</li><li>  为了防止代码逻辑混乱，调用next()函数数后不再写额外的代码</li><li>  多个中间件共享同一份 req、 res对象，基于这样的特性，我们可以在上游的中间件中，统一为req或res对象添加自定义属性或方法，供下游的中间件或路由进行使用</li></ul><h3 id="全局中间件"><a href="#全局中间件" class="headerlink" title="全局中间件"></a>全局中间件</h3><p>客户端发起的任何请求。到达服务器之后，都会触发的中间件，叫全局生效的中间件</p><ul><li>  通过 app.use() 定义的中间件为全局中间件</li><li>  可以连续定义多个全局中间件，客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">// 定义第一个全局中间件</span><br><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;调用了第1个全局中间件&#x27;)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line">// 定义第二个全局中间件</span><br><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;调用了第2个全局中间件&#x27;)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/user&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;User page.&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(80, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="局部中间件"><a href="#局部中间件" class="headerlink" title="局部中间件"></a>局部中间件</h3><p>不使用app.use()定义的中间件，叫做局部失效的中间件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">// 定义中间件函数</span><br><span class="line">const mw1 = (req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;调用了第一个局部生效的中间件&#x27;)</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mw2 = (req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;调用了第二个局部生效的中间件&#x27;)</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 两种定义局部中间件的方式</span><br><span class="line">app.get(&#x27;/hello&#x27;, mw2, mw1, (req, res) =&gt; res.send(&#x27;hello page.&#x27;))</span><br><span class="line">app.get(&#x27;/about&#x27;, [mw1, mw2], (req, res) =&gt; res.send(&#x27;about page.&#x27;))</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/user&#x27;, (req, res) =&gt; res.send(&#x27;User page.&#x27;))</span><br><span class="line"></span><br><span class="line">app.listen(80, function () &#123;</span><br><span class="line">  console.log(&#x27;Express server running at http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="中间件分类"><a href="#中间件分类" class="headerlink" title="中间件分类"></a>中间件分类</h3><h4 id="应用级别的中间件"><a href="#应用级别的中间件" class="headerlink" title="应用级别的中间件"></a>应用级别的中间件</h4><ul><li>  通过 app.use() 或 app.get() 或 app.post() ，绑定到 app 实例上的中间件</li></ul><h4 id="路由级别的中间件"><a href="#路由级别的中间件" class="headerlink" title="路由级别的中间件"></a>路由级别的中间件</h4><ul><li>  绑定到 express.Router() 实例上的中间件，叫做路由级别的中间件。用法和应用级别中间件没有区别。应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到 router 实例上。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const app = express()</span><br><span class="line">const router = express.Router()</span><br><span class="line"></span><br><span class="line">router.use(function (req, res, next) &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(&#x27;/&#x27;, router)</span><br></pre></td></tr></table></figure><h4 id="错误级别的中间件"><a href="#错误级别的中间件" class="headerlink" title="错误级别的中间件"></a>错误级别的中间件</h4><ul><li>  用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题</li><li>  错误级别中间件的处理函数中，必须有 4 个形参，形参顺序从前到后分别是 (err, req, res, next) 。</li><li>  错误级别的中间件必须注册在所有路由之后</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  throw new Error(&#x27;服务器内部发生了错误！&#x27;)</span><br><span class="line">  res.send(&#x27;Home page.&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 定义错误级别的中间件，捕获整个项目的异常错误，从而防止程序的崩溃</span><br><span class="line">app.use((err, req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;发生了错误！&#x27; + err.message)</span><br><span class="line">  res.send(&#x27;Error：&#x27; + err.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(80, function () &#123;</span><br><span class="line">  console.log(&#x27;Express server running at http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Express-内置中间件"><a href="#Express-内置中间件" class="headerlink" title="Express 内置中间件"></a>Express 内置中间件</h4><p>自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验：</p><ul><li>  express.static 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）</li><li>  express.json 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li><li>  express.urlencoded 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.json())</span><br><span class="line">app.use(express.urlencoded(&#123; extended: false &#125;))</span><br></pre></td></tr></table></figure><h4 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h4><p>非Express官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件，在项目中，可以按需下载并配置第三方中间件，从而提高开发效率；</p><ul><li>  运行<code>npm install body-parser</code>安装中间件</li><li>  使用require导入中间件</li><li>  调用app.use()注册并使用中间件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">const parser = require(&#x27;body-parser&#x27;)</span><br><span class="line"></span><br><span class="line">app.use(parser.urlencoded(&#123; extended: false &#125;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;Home page&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">app.post(&#x27;/user&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  console.log(req.body);</span><br><span class="line">  res.send(&#x27;User page&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(81, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;http://127.0.0.1:81&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h3><p>自定义一个类似express.urlencoded这样的中间件，来解析post提交到服务器的表单数据</p><p>实现步骤：</p><ol><li> 定义中间件</li><li> 监听req的data事件</li><li> 监听req的end事件</li><li> 使用querystring模块解析请求体数据</li><li> 将解析出来的数据对象挂载为req.body</li><li> 将自定义中间件封装为模块</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 导入express模块</span><br><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">// 创建express的服务器实例</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">const customBodyParser = require(&#x27;./10.custom-body-parser&#x27;)</span><br><span class="line"></span><br><span class="line">// 这是解析表单数据的中间件</span><br><span class="line">app.use(customBodyParser)</span><br><span class="line"></span><br><span class="line">app.post(&#x27;/user&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  console.log(req.body);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 调用app.listen方法,指定端口号并启动web服务器</span><br><span class="line">app.listen(81, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;http://127.0.0.1:81&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 导入处理querystring的Node.js内置模块</span><br><span class="line">const qs = require(&#x27;querystring&#x27;)</span><br><span class="line"></span><br><span class="line">// 调用qs.parse()方法，把查询字符串解析为对象</span><br><span class="line">const bodyParser = (req, res, next) =&gt; &#123;</span><br><span class="line">  // 定义一个str字符串，专门用来储存客户端发送过来的请求体数据</span><br><span class="line">  let str = &#x27;&#x27;</span><br><span class="line">  // 监听req的data事件</span><br><span class="line">  req.on(&#x27;data&#x27;, (chunk) =&gt; &#123;</span><br><span class="line">    str += chunk</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // 监听req的end事件</span><br><span class="line">  req.on(&#x27;end&#x27;, () =&gt; &#123;</span><br><span class="line">    // 调用qs.parse()方法，把查询字符串解析为对象</span><br><span class="line">    const body = qs.parse(str)</span><br><span class="line">    // 将解析出来的请求体对象，挂载为req.body属性</span><br><span class="line">    req.body = body</span><br><span class="line">    // 最后调用next()函数。执行后续的业务逻辑</span><br><span class="line">    next()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = bodyParser</span><br></pre></td></tr></table></figure><h2 id="使用Express写接口"><a href="#使用Express写接口" class="headerlink" title="使用Express写接口"></a>使用Express写接口</h2><h3 id="创建基本服务器"><a href="#创建基本服务器" class="headerlink" title="创建基本服务器"></a>创建基本服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">const router = require(&#x27;./12.apiRouter&#x27;)</span><br><span class="line"></span><br><span class="line">app.use(&#x27;/api&#x27;, router)</span><br><span class="line"></span><br><span class="line">app.listen(81, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;http://127.0.0.1:81&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="创建API路由模块"><a href="#创建API路由模块" class="headerlink" title="创建API路由模块"></a>创建API路由模块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const router = express.Router()</span><br><span class="line"></span><br><span class="line">module.express = router</span><br></pre></td></tr></table></figure><h3 id="编写GET接口"><a href="#编写GET接口" class="headerlink" title="编写GET接口"></a>编写GET接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">router.get(&#x27;/get&#x27;, (req, res) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  const query = req.query</span><br><span class="line">  // 调用res.send()方法，向客户端响应结果</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    status: 0, // 0表示处理成功，1表示处理失败</span><br><span class="line">    msg: &#x27;GET 请求成功！&#x27;, // 状态描述</span><br><span class="line">    data: query // 需要响应给客户端的数据</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="编写POST接口"><a href="#编写POST接口" class="headerlink" title="编写POST接口"></a>编写POST接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定义POST接口</span><br><span class="line">router.post(&#x27;/post&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  // 通过req.body获取请求体中包含的url-encoded格式的数据</span><br><span class="line">  const body = req.body</span><br><span class="line">  // 调用res.send()方法，向客户端响应结果</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    status: 0,</span><br><span class="line">    msg: &#x27;POST请求成功&#x27;,</span><br><span class="line">    data: body</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS 跨域资源共享"></a>CORS 跨域资源共享</h3><h4 id="接口的跨域问题"><a href="#接口的跨域问题" class="headerlink" title="接口的跨域问题"></a>接口的跨域问题</h4><p>解决接口跨域的问题的方案主要有两种</p><ul><li>  CORS（主流的解决方案，推荐使用）</li><li>  JSONP（有缺陷的解决方案，只支持GET请求）</li></ul><h4 id="cors-中间件解决跨域"><a href="#cors-中间件解决跨域" class="headerlink" title="cors 中间件解决跨域"></a>cors 中间件解决跨域</h4><ul><li>  安装中间件：<code>npm install cors</code></li><li>  导入中间件：const cors = require(‘cors’)</li><li>  配置中间件：app.use(cors())</li></ul><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><ul><li>  CORS（Cross-Origin Resource Sharing，跨域资源共享）解决跨域，是通过 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获取资源</li><li>  浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头，就可解除浏览器端的跨域访问限制</li><li>  CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。</li><li>  CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。</li></ul><h4 id="CORS-常见响应头"><a href="#CORS-常见响应头" class="headerlink" title="CORS 常见响应头"></a>CORS 常见响应头</h4><ul><li>  Access-Control-Allow-Origin：制定了允许访问资源的外域 URL</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;http://bruceblog.io&#x27;)</span><br><span class="line">res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;)</span><br></pre></td></tr></table></figure><ul><li>  Access-Control-Allow-Headers</li><li>  默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一）</li><li>  如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败！</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;Content-Type, X-Custom-Header&#x27;)</span><br></pre></td></tr></table></figure><ul><li>  Access-Control-Allow-Methods</li><li>  默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods 来指明实际请求所允许使用的 HTTP 方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;POST, GET, DELETE, HEAD&#x27;)</span><br><span class="line">res.setHEader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;*&#x27;)</span><br></pre></td></tr></table></figure><h3 id="CORS-请求分类"><a href="#CORS-请求分类" class="headerlink" title="CORS 请求分类"></a>CORS 请求分类</h3><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><ul><li>  请求方式：GET、POST、HEAD 三者之一</li><li>  HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值 application/x-www-formurlencoded、multipart/form-data、text/plain）</li></ul><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><ul><li>  请求方式为 GET、POST、HEAD 之外的请求 Method 类型</li><li>  请求头中包含自定义头部字段</li><li>  向服务器发送了 application/json 格式的数据</li></ul><p>在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据</p><h4 id="简单请求和预检请求"><a href="#简单请求和预检请求" class="headerlink" title="简单请求和预检请求"></a>简单请求和预检请求</h4><ul><li>  简单请求的特点：客户端与服务器之间只会发送一次请求</li><li>  预检请求的特点：客户端与服务器之间会发送两次请求，OPTION预检请求成功之后，才会发起真正的请求</li></ul><h3 id="JSONP接口"><a href="#JSONP接口" class="headerlink" title="JSONP接口"></a>JSONP接口</h3><h4 id="回顾JSONP的概念与特点"><a href="#回顾JSONP的概念与特点" class="headerlink" title="回顾JSONP的概念与特点"></a>回顾JSONP的概念与特点</h4><p>概念：浏览器端通过<script>标签的src属性，请求服务器上的数据，同时，服务器放回一个函数的调用，这种请求数据的方式叫做JSONP</p><p>特点：</p><ul><li>  JSONP不属于真正的Ajax请求，因为她没有使用XMLHttpRequest这个对象</li><li>  JSONP仅支持GTE请求，不支持POST、PUT、DELETE等请求</li></ul><h4 id="创建JSONP接口的注意事项"><a href="#创建JSONP接口的注意事项" class="headerlink" title="创建JSONP接口的注意事项"></a>创建JSONP接口的注意事项</h4><p>如果项目中已经配置了CORS的跨域资源共享，为了防止冲突，必须在配置CORS中间件之前声明JSONP的接口，否则JSONP接口会被处理成开启了CORS的接口</p><h4 id="实现JSONP接口的步骤"><a href="#实现JSONP接口的步骤" class="headerlink" title="实现JSONP接口的步骤"></a>实现JSONP接口的步骤</h4><ol><li> 获取客户端发送过来的回调函数的名字</li><li> 得到要通过JSONP形式发送给客户端的数据</li><li> 根据前两步得到的数据，拼接主一个函数调用的字符串</li><li> 把上一步拼接得到的字符串，响应给客户端的<script>标签进行解析执行</li></ol><h4 id="实现JSONP接口的具体代码"><a href="#实现JSONP接口的具体代码" class="headerlink" title="实现JSONP接口的具体代码"></a>实现JSONP接口的具体代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 必须在配置cors前配置JSONP接口</span><br><span class="line">app.get(&#x27;/api/jsonp&#x27;,(req, res) =&gt; &#123; </span><br><span class="line">  // 得到函数的名称</span><br><span class="line">  const funcName = req.query.callback</span><br><span class="line">  // 定义要发送到客户端的数据对象</span><br><span class="line">  const data = &#123; name: &#x27;czf&#x27;, age: 21&#125;</span><br><span class="line">  // 把拼接的字符串，响应给客户端</span><br><span class="line">  const scriptStr = `$&#123;funcName&#125;($&#123;JSON.stringify(data)&#125;)`</span><br><span class="line">  // 把拼接的字符串响应给客户端</span><br><span class="line">  res.send(scriptStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(&#x27;#btnJsonp&#x27;).on(&#x27;click&#x27;, function() &#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    type: &#x27;GET&#x27;,</span><br><span class="line">    url: &#x27;http://127.0.0.1:81/api/jsonp&#x27;,</span><br><span class="line">    dataType: &#x27;jsonp&#x27;,</span><br><span class="line">    success: function (res) &#123;</span><br><span class="line">      console.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h2><p>数据库（database）是用来组织、存储和管理数据的仓库</p><h3 id="常见的数据库及分类"><a href="#常见的数据库及分类" class="headerlink" title="常见的数据库及分类"></a>常见的数据库及分类</h3><p>市面上的数据库有很多种，最常见的数据库有如下几个</p><ul><li>  MySQL数据库（目前使用最广泛、流行度最高的开源免费数据库；Community + Enterprise）</li><li>  Oracle数据库</li><li>  SQL Server数据库里</li><li>  Mongodb数据库</li></ul><p>其中MySQL、Oracle、SQL Server 属于传统型数据库（又叫做:关系型数据库或SQL数据库），这三者的设计理念相同、用法比较类似</p><p>而Mongodb属于新型数据库（又叫做:非关系型数据库或NoSQL数据库），它在一定程度上弥补了传统型数据库的缺陷</p><h3 id="传统型数据库的数据组织结构"><a href="#传统型数据库的数据组织结构" class="headerlink" title="传统型数据库的数据组织结构"></a>传统型数据库的数据组织结构</h3><p>在传统型数据库中，数据的结构分为数据库（database）、数据表（table）、数据行（row）、字段（field）这四大部分组成</p><ul><li>  数据库类似与Excel的工作薄</li><li>  数据表类似于Excel的工作表</li><li>  数据行类似于excel的没一行数据</li><li>  字段类似于Excel的列</li><li>  每个字段都有对应的数据类型</li></ul><h2 id="MySQL的基本使用"><a href="#MySQL的基本使用" class="headerlink" title="MySQL的基本使用"></a>MySQL的基本使用</h2><p>DataType数据类型</p><ul><li>  int 整数</li><li>  varchar(len) 字符串</li><li>  tinyint(1) 布尔值</li></ul><p>字段的特殊标识：</p><ul><li>  PK（Primary Key） 主键、唯一标识</li><li>  NN（Not Null） 值不允许为空</li><li>  UQ（Unique） 值唯一</li><li>  AI（Auto Increment） 值自动增长</li></ul><h2 id="使用SQL管理数据库"><a href="#使用SQL管理数据库" class="headerlink" title="使用SQL管理数据库"></a>使用SQL管理数据库</h2><p>SQL全称（Structured Query Language）是结构化查询语言，专门用来访问和处理数据库的编程语言，能够让我们以编程的形式，操作数据库里的数据</p><ul><li>  SQL是一门数据库编程语言</li><li>  使用SQL语言编写出来的代码，叫做SQL语句</li><li>  SQL语言只能在关系型数据库中使用</li></ul><h3 id="sql能做什么"><a href="#sql能做什么" class="headerlink" title="sql能做什么"></a>sql能做什么</h3><ul><li>  增(insert into)删(delete)查(select)改(update )</li><li>  创建数据库</li><li>  创建新表</li><li>  创建存储过程、视图</li><li>  etc…</li></ul><h2 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h2><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p><code>select */列 from 表名</code></p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>INSERT INTO 语句用于向数据表中插入新的数据行</p><p><code>insert into table_name(列1， 列2) values(值1，值2)</code></p><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>UPDATE：更新某一行中的一个列</p><p><code>update table_name set 列=&#39;&#39; where 行 = ?</code></p><p>UPDATE：更新某一行中的若干列·</p><p><code>updata table_name set 列=&#39;&#39;, 列=&#39;&#39; where 行= ?</code></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>DELETE语句用于删除表中的行</p><p><code>delete from table_name where 行= ?</code></p><h4 id="WHERE语句"><a href="#WHERE语句" class="headerlink" title="WHERE语句"></a>WHERE语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询语句中的WHERE条件</span><br><span class="line">select 列名称 from 表名称 where 列 运算符 值</span><br><span class="line">update 表名称 set 列=值 where 列 运算符 值</span><br><span class="line">delete from 表名称 where 列 运算符 值</span><br></pre></td></tr></table></figure><h4 id="AND和OR运算符"><a href="#AND和OR运算符" class="headerlink" title="AND和OR运算符"></a>AND和OR运算符</h4><p>and和or可在where子句中把两个或多个条件结合起来</p><p>and表示必须同时满足多个条件，相当于Javascript中的&amp;&amp;运算符</p><p>or表示只要满足任意一个条件即可，相当于JavaScript中的||运算符</p><h4 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h4><p>ORDER BY语句用于根据指定的列对结果进行排序</p><p>ORDER BY语句默认按照升序对记录进行升序排序（asc）</p><p>如果希望按照降序对记录进行排序，可以使用DESC关键字</p><p><code>select * from table_name order by 字段</code></p><p><code>select * from table_name order by 字段 desc</code></p><p><strong>多重排序</strong></p><p>例子：对users表中的数据，先按照status字段进行降序排序，再按照username的字母顺序，进行升序排序</p><p><code>select * from users order by status desc, username asc</code></p><h4 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT(*)"></a>COUNT(*)</h4><p>COUNT(*) 函数用于返回查询结果的总数据条数</p><p><code>select count(*) from 表名称</code></p><h4 id="AS"><a href="#AS" class="headerlink" title="AS"></a>AS</h4><p>使用AS为列设置别名</p><p><code>select * as 别名 from 表名称</code></p><h2 id="在项目中操作MySQL"><a href="#在项目中操作MySQL" class="headerlink" title="在项目中操作MySQL"></a>在项目中操作MySQL</h2><ol><li> 安装操作MySQL数据库的第三方模块（mysql）</li><li> 通过mysql模块链接到MySQL数据库</li><li> 通过mysql模块执行SQL语句</li></ol><h3 id="安装mysql模块"><a href="#安装mysql模块" class="headerlink" title="安装mysql模块"></a>安装mysql模块</h3><p>mysql模块是托管于npm上的第三方模块，它提供了在Node.js项目中链接和操作MySQL数据库的能力</p><p><code>npm install mysql</code></p><h3 id="配置mysql模块"><a href="#配置mysql模块" class="headerlink" title="配置mysql模块"></a>配置mysql模块</h3><p>在使用mysql模块操作MySQL数据库之前，必须先度mysql模块进行必要的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 导入mysql模块</span><br><span class="line">const mysql = require(&#x27;mysql&#x27;)</span><br><span class="line">// 建立于MySQL数据库的连接关系</span><br><span class="line">const db = mysql.createPool(&#123;</span><br><span class="line">  host: &#x27;127.0.0.1&#x27;, // 数据库的IP地址</span><br><span class="line">  user: &#x27;root&#x27;, // 登录数据库的账号</span><br><span class="line">  password: &#x27;123456&#x27;, // 登录数据库的密码</span><br><span class="line">  database: &#x27;my_db_01&#x27; // 指定要操作哪个数据库</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 查询</span><br><span class="line">const sqlStr = &#x27;select * from users&#x27;</span><br><span class="line">db.query(sqlStr, (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line"></span><br><span class="line">  console.log(results)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 插入</span><br><span class="line">const user = &#123; username: &#x27;lhw&#x27;,  password: &#x27;lhw123&#x27;&#125;</span><br><span class="line">const sqlStr1 = &#x27;insert into users(username, password) values(?, ?)&#x27;</span><br><span class="line"></span><br><span class="line">db.query(sqlStr1, [user.username, user.password], (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line">  if(results.affectedRows === 1) &#123;</span><br><span class="line">    console.log(&#x27;插入数据成功&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>向表中新增数据是，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速插入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123; username: &#x27;xjc&#x27;,  password: &#x27;xjc123&#x27;&#125;</span><br><span class="line">const sqlStr1 = &#x27;insert into users set ?&#x27;</span><br><span class="line"></span><br><span class="line">db.query(sqlStr1, user, (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line">  if(results.affectedRows === 1) &#123;</span><br><span class="line">    console.log(&#x27;插入数据成功&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123; id: 5, username: &#x27;aaa&#x27;,  password: &#x27;000&#x27;&#125;</span><br><span class="line">const sqlStr1 = &#x27;update users set username=?, password=? where id=?&#x27;</span><br><span class="line"></span><br><span class="line">db.query(sqlStr1, [user.username, user.password, user.id], (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line">  if(results.affectedRows === 1) &#123;</span><br><span class="line">    console.log(&#x27;更新数据成功&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 更新用户信息，便捷方式</span><br><span class="line">const user = &#123; id: 5, username: &#x27;bbb&#x27;,  password: &#x27;111&#x27;&#125;</span><br><span class="line">const sqlStr1 = &#x27;update users set ? where id=?&#x27;</span><br><span class="line"></span><br><span class="line">db.query(sqlStr1, [user, user.id], (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line">  if(results.affectedRows === 1) &#123;</span><br><span class="line">    console.log(&#x27;更新数据成功&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 删除id为5的数据</span><br><span class="line">const sqlStr1 = &#x27;delete from users where id=?&#x27;</span><br><span class="line"></span><br><span class="line">db.query(sqlStr1, 5, (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line">  if(results.affectedRows === 1) &#123;</span><br><span class="line">    console.log(&#x27;删除数据成功&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>标记删除</p><p>使用delete语句，会真正的把数据从表中删除，为了保险起见，推荐使用标记删除的形式，来模拟删除的动作。所谓标记删除，就是在表中设置类似于status这样的状态字段，来标记当前这条数据是否被删除。</p><p>当用户执行了删除的动作时，我们并没有执行delete语句把数据删除掉，而是执行了update语句将这条数据对应的status字段标记为删除即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const sqlStr1 = &#x27;update users set status=? where id=?&#x27;</span><br><span class="line">db.query(sqlStr1, [1, 4], (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line">  if (results.affectedRows === 1) &#123;</span><br><span class="line">    console.log(&#x27;标记删除成功&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="前后端的身份验证"><a href="#前后端的身份验证" class="headerlink" title="前后端的身份验证"></a>前后端的身份验证</h2><h3 id="Web开发模式"><a href="#Web开发模式" class="headerlink" title="Web开发模式"></a>Web开发模式</h3><h3 id="服务端渲染的Web开发模式"><a href="#服务端渲染的Web开发模式" class="headerlink" title="服务端渲染的Web开发模式"></a>服务端渲染的Web开发模式</h3><ul><li>  服务端渲染的概念：服务器发送给客户端的HTML页面，是在服务器通过字符串的拼接，动态生成的，因此，客户端不需要使用Ajax.js这样的技术额外请求页面的数据</li></ul><h3 id="服务端渲染的优缺点"><a href="#服务端渲染的优缺点" class="headerlink" title="服务端渲染的优缺点"></a>服务端渲染的优缺点</h3><p>优点</p><ul><li>  前端耗时少，因为服务器端负责动态生成HTML内容，浏览器只需要直接渲染页面即可，尤其是移动端，更省电。</li><li>  有利于SEO，因为服务器端响应的是完整的HTML页面内容，所以爬虫更加容易获取信息，更有利于SEO。</li></ul><p>缺点</p><ul><li>  占用服务器端资源，即服务器完成HTML页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。</li><li>  不利于前后端分离，开发效率低，使用服务器渲染，则无法进行分工合作，尤其对前端复杂度高的项目，不利于项目高效开发。</li></ul><h3 id="前后端分离的Web开发模式"><a href="#前后端分离的Web开发模式" class="headerlink" title="前后端分离的Web开发模式"></a>前后端分离的Web开发模式</h3><p>前后端分离的概念：前后端分离的开发模式，依赖于Ajax技术的广泛应用，前后端分离的Web开发模式，就是后端只负责提供API接口，前端使用Ajax调用接口的开发模式。</p><h3 id="前后端分离的优缺点"><a href="#前后端分离的优缺点" class="headerlink" title="前后端分离的优缺点"></a>前后端分离的优缺点</h3><p>优点：</p><ul><li>  开发体验好，前端专注于UI页面的开发，后端专注于api的开发，且前端会有更多的选择性</li><li>  用户体验好，Ajax技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新</li><li>  减轻了服务器的渲染压力，因为页面最终是在每个用户的浏览器中生成的</li></ul><p>缺点：</p><ul><li>  不利于SEO，因为完整的HTML页面需要在客户端动态拼接完成，所以爬虫无法爬取页面的有效信息</li></ul><h3 id="如何选择web开发模式"><a href="#如何选择web开发模式" class="headerlink" title="如何选择web开发模式"></a>如何选择web开发模式</h3><p>不谈业务场景而盲目选择使用何种开发模式都是耍流氓</p><ul><li>  比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的SEO，则这时我们就需要使用服务器渲染</li><li>  而类似后台管理项目，交互性比较强，不需要考虑SEO，那么就可以使用前后端分离的开发模式，</li></ul><p>另外，具体使用何种开发模式并不是绝对的，为了同时兼顾首页的渲染速度和前后端分离的开发效率，一些网站采用了首屏服务器渲染+其他页面前后端分离的开发模式。</p><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><p>目的：为了确认当前所声称为某种身份的用户，确实是所声称的用户</p><h4 id="不同开发模式下的身份认证"><a href="#不同开发模式下的身份认证" class="headerlink" title="不同开发模式下的身份认证"></a>不同开发模式下的身份认证</h4><p>对于服务器渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案：</p><ol><li> 服务器渲染推荐使用Session认证机制</li><li> 前后端分离推荐使用JWT认证机制</li></ol><h4 id="Session认证机制"><a href="#Session认证机制" class="headerlink" title="Session认证机制"></a>Session认证机制</h4><h5 id="HTTP协议的无状态性"><a href="#HTTP协议的无状态性" class="headerlink" title="HTTP协议的无状态性"></a>HTTP协议的无状态性</h5><p>HTTP协议的无状态性，指的是客户端的每次HTTP请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次HTTP请求的状态</p><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>cookie是存储在用户浏览器中的一段不超过4KB的字符串，它由一个名称（Name），一个值(Value)和其他几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。</p><p>不同域名下的Cookie各自独立，每当客户端发起请求的时，会自动把当前域名下所有未过期的Cookie一同发送到服务器</p><p>Cookie的几大特性：</p><ul><li>  自动发送</li><li>  域名独立</li><li>  过期限制</li><li>  4KB限制</li></ul><h5 id="Cookie在身份认证中的作用"><a href="#Cookie在身份认证中的作用" class="headerlink" title="Cookie在身份认证中的作用"></a>Cookie在身份认证中的作用</h5><p>客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的Cookie，客户端会自动将Cookie保存在浏览器中。</p><p>随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的Cookie，通过请求头的形式发送给服务器，服务器即可验明客户端的身份。</p><p><img src=""></p><h5 id="Cookie不具有安全性"><a href="#Cookie不具有安全性" class="headerlink" title="Cookie不具有安全性"></a>Cookie不具有安全性</h5><p>由于Cookie时存储在浏览器中的，而且浏览器也提供了读写Cookie的API，因此Cookie很容易被伪造，不具有安全性，因此不建议服务器将重要的隐私数据通过Cookie的形式发送给浏览器</p><h5 id="Session的工作原理"><a href="#Session的工作原理" class="headerlink" title="Session的工作原理"></a>Session的工作原理</h5><p><img src=""></p><h4 id="在Express中使用Session认证"><a href="#在Express中使用Session认证" class="headerlink" title="在Express中使用Session认证"></a>在Express中使用Session认证</h4><p>配置express-session中间件</p><p>express-session中间件安装成功后，需要通过app.use()来注册session中间件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> const app = express()</span><br><span class="line"></span><br><span class="line">const session =require(&#x27;express-session&#x27;)</span><br><span class="line">app.use(</span><br><span class="line">  session(&#123;</span><br><span class="line">    secret: &#x27;itheima&#x27;,</span><br><span class="line">    resave: false,</span><br><span class="line">    saveUninitialized: true,</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>向session中存数据</p><p>当express-session中间件配置成功后，即可通过req.session来访问和使用session对象，从而存储用户的关键信息</p><h4 id="JWT认证机制"><a href="#JWT认证机制" class="headerlink" title="JWT认证机制"></a>JWT认证机制</h4><p>session认证机制需要配合Cookie才能实现，由于Cookie默认不支持跨域访问，所以，当涉及到当前跨域请求后端接口的时候，需要很多额外的配置，才能实现跨域session认证。</p><p>注意：</p><ul><li>  当前端请求后端接口不存在跨域问题的时候，推荐使用Session身份认证机制</li><li>  当前端需要跨域请求后端接口的时候，不推荐使用Session身份认证机制，推荐使用JWT认证机制</li></ul><h5 id="JWT工作原理"><a href="#JWT工作原理" class="headerlink" title="JWT工作原理"></a>JWT工作原理</h5><p><img src=""></p><p>总结：用户的信息通过Token字符串的形式，保存在客户端浏览器中，服务器通过还原Token字符串的形式来认证用户的身份</p><h5 id="JWT的组成部分"><a href="#JWT的组成部分" class="headerlink" title="JWT的组成部分"></a>JWT的组成部分</h5><p>JWT通常由三部分组成，分别是Header（头部）、Payload（有效荷载）、Signature（签名）</p><p>三者之间使用英文的”.”分割</p><h5 id="JWT的三个部分各自代表的含义"><a href="#JWT的三个部分各自代表的含义" class="headerlink" title="JWT的三个部分各自代表的含义"></a>JWT的三个部分各自代表的含义</h5><p>JWT的三个部分，从前到后分别时Header、Payload、Signature</p><p>其中：</p><ul><li>  Payload部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串</li><li>  Header和Signature是安全性相关的部分，只是为了保证Token的安全性</li></ul><h5 id="JWT使用方式"><a href="#JWT使用方式" class="headerlink" title="JWT使用方式"></a>JWT使用方式</h5><p>客户端收到服务器放回的JWT之后，通常会将它存储在localStorage或sessionStorage中</p><p>此后，客户端每次与服务器通信，都要带上这个JWT的字符串，从而进行身份认证，推荐的做法是把JWT放在HTTP请求头的Authorization字段中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><h4 id="在Express中使用JWT"><a href="#在Express中使用JWT" class="headerlink" title="在Express中使用JWT"></a>在Express中使用JWT</h4><h5 id="安装JWT相关的包"><a href="#安装JWT相关的包" class="headerlink" title="安装JWT相关的包"></a>安装JWT相关的包</h5><p><code>npm install jsonwebtoken express-jwt</code></p><p>其中：</p><ul><li>  jsonwebtoken用于生成JWT字符串</li><li>  express-jwt用于将JWT字符串解析还原成JSON对象</li></ul><h5 id="导入JWT相关的包"><a href="#导入JWT相关的包" class="headerlink" title="导入JWT相关的包"></a>导入JWT相关的包</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cosnt jwt = require(&#x27;jsonwebtoken&#x27;)</span><br><span class="line"></span><br><span class="line">const expressJWT = require(’express-jwt&#x27;)</span><br></pre></td></tr></table></figure><h5 id="定义secret密钥"><a href="#定义secret密钥" class="headerlink" title="定义secret密钥"></a>定义secret密钥</h5><p>为了保证JWT字符串的安全性，防止JWT字符串在网络传输过程中被别人破解，我们需要定义一个用于加密和解密的secret密钥：</p><ol><li> 当生成JWT字符串的时候，需要使用secret密钥对用户的信息进行加密，最终得到加密好的JWT字符串</li><li> 当把JWT字符串解析还原成JSON对象的时候，需要使用secret密钥进行解密</li></ol><p><code>const secretKey = &#39;itheima No1 ^_^&#39;</code></p><h5 id="在登录成果后生成JWT字符串"><a href="#在登录成果后生成JWT字符串" class="headerlink" title="在登录成果后生成JWT字符串"></a>在登录成果后生成JWT字符串</h5><p>调用jsonwebtoken包提供的sign()方法，将用户的信息加密成JWT字符串，响应给客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.post(&#x27;api/login&#x27;, function(req, res) &#123;</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    status: 200,</span><br><span class="line">    message: &#x27;登录成功&#x27;,</span><br><span class="line">    token: jwt.sign(&#123; username: userinfo.username &#125;, secretKey, &#123; expiresIn: &#x27;30s&#x27;&#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="将JWT字符串还原为JSON对象"><a href="#将JWT字符串还原为JSON对象" class="headerlink" title="将JWT字符串还原为JSON对象"></a>将JWT字符串还原为JSON对象</h5><p>客户端每次在访问那些有权限接口的时候，都需要主动通过请求头中的Authorization字段，将Token字符串发送到服务器进行身份认证</p><p>此时服务器可以通过<strong>express-jwt</strong>这个中间件，自动将客户端发送过来的Token解析还原成JSON对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用app.use()来注册中间件</span><br><span class="line">// expressJWT(&#123; secret: secretKey &#125;) 就是用来解析Token的中间件</span><br><span class="line">// .unless(&#123; path: [/^/api//]&#125;) 用来指定哪些接口不需要访问权限</span><br><span class="line">app.use(expressJWT(&#123; secret: secretKey &#125;).unless(&#123; path: [/^/api//]&#125;))</span><br></pre></td></tr></table></figure><h5 id="使用req-user获取用户信息"><a href="#使用req-user获取用户信息" class="headerlink" title="使用req.user获取用户信息"></a>使用req.user获取用户信息</h5><p>当express-jwt这个中间件配置成功之后，即可在那些有权限的接口中，使用req.user对象，来访问从JWT字符串中解析出来的用户信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;/admin/getinfo&#x27;, function(req, res) &#123;</span><br><span class="line">  console.log(req.user)</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    status: 200,</span><br><span class="line">    message: &#x27;获取用户信息成功！&#x27;,</span><br><span class="line">    data: req.user</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="捕获解析JWT失败后产生的错误"><a href="#捕获解析JWT失败后产生的错误" class="headerlink" title="捕获解析JWT失败后产生的错误"></a>捕获解析JWT失败后产生的错误</h5><p>当使用express-jwt解析Token字符串时，如果客户端发送过来的Token字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行，我们可以通过Express的错误中间件，捕获这个错误并进行相关的处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.use((err, req, res, next) =&gt; &#123;</span><br><span class="line">  // token解析失败导致的错误</span><br><span class="line">  if(err.name === &#x27;UnauthorizedError&#x27;) &#123;</span><br><span class="line">    return res.send(&#123; status: 401, message: &#x27;无效的token&#x27;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 其他原因导致的错误</span><br><span class="line">  res.send(&#123; status: 500, message: &#x27;未知错误&#x27;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></script></p>]]></content>
      
      
      
        <tags>
            
            <tag> node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo学习</title>
      <link href="/2022/09/27/Hexo%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/09/27/Hexo%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a></p><h1 id="1-初识Hexo"><a href="#1-初识Hexo" class="headerlink" title="1.初识Hexo"></a>1.初识Hexo</h1><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页</p><h2 id="1-1-安装Hexo"><a href="#1-1-安装Hexo" class="headerlink" title="1.1 安装Hexo"></a>1.1 安装Hexo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**npm install -g hexo-cli**</span><br></pre></td></tr></table></figure><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm server</span><br></pre></td></tr></table></figure><h2 id="1-2-目录结构"><a href="#1-2-目录结构" class="headerlink" title="1.2 目录结构"></a>1.2 目录结构</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27188772/1664181986671-6cc3ea7d-2e2e-4007-ad9c-107a0baa1a63.png" alt="img"></p><h2 id="1-3-generate（生成静态网址）"><a href="#1-3-generate（生成静态网址）" class="headerlink" title="1.3 generate（生成静态网址）"></a>1.3 generate（生成静态网址）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**hexo generate**</span><br></pre></td></tr></table></figure><p>生成静态文件。</p><table><thead><tr><th><strong>选项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>-d, –deploy</td><td>文件生成后立即部署网站</td></tr><tr><td>-w, –watch</td><td>监视文件变动</td></tr><tr><td>-b, –bail</td><td>生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td>-f, –force</td><td>强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。 使用该参数的效果接近 hexo clean &amp;&amp; hexo generate</td></tr><tr><td>-c, –concurrency</td><td>最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>ps：生成好的public文件夹可以直接当成静态网站进行部署</p><h1 id="2-Hexo博客主题的安装与推荐"><a href="#2-Hexo博客主题的安装与推荐" class="headerlink" title="2. Hexo博客主题的安装与推荐"></a>2. Hexo博客主题的安装与推荐</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27188772/1664185687883-f65df138-f1a7-4524-ac46-8d607065f212.png" alt="img"></p><h1 id="3-文档编辑写"><a href="#3-文档编辑写" class="headerlink" title="3. 文档编辑写"></a>3. 文档编辑写</h1><p> 你可以执行下列命令来创建一篇新文章或者新的页面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。</p><h2 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h2><p>Hexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。</p><table><thead><tr><th><strong>布局</strong></th><th><strong>路径</strong></th></tr></thead><tbody><tr><td>post</td><td>source/_posts</td></tr><tr><td>page</td><td>source</td></tr><tr><td>draft</td><td>source/_drafts</td></tr></tbody></table><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--- title: Hello World date: 2022/9/27 12:00:00 ---</span><br></pre></td></tr></table></figure><p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td><td align="left"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td><td align="left">文章的文件名</td></tr><tr><td align="left"><code>date</code></td><td align="left">建立日期</td><td align="left">文件建立日期</td></tr><tr><td align="left"><code>updated</code></td><td align="left">更新日期</td><td align="left">文件更新日期</td></tr><tr><td align="left"><code>comments</code></td><td align="left">开启文章的评论功能</td><td align="left">true</td></tr><tr><td align="left"><code>tags</code></td><td align="left">标签（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>categories</code></td><td align="left">分类（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">覆盖文章网址</td><td align="left"></td></tr><tr><td align="left"><code>excerpt</code></td><td align="left">Page excerpt in plain text. Use <a href="https://hexo.io/docs/tag-plugins#Post-Excerpt">this plugin</a> to format the text</td><td align="left"></td></tr><tr><td align="left"><code>disableNunjucks</code></td><td align="left">Disable rendering of Nunjucks tag <code>&#123;&#123; &#125;&#125;</code>/<code>&#123;% %&#125;</code> and <a href="https://hexo.io/docs/tag-plugins">tag plugins</a> when enabled</td><td align="left"></td></tr><tr><td align="left"><code>lang</code></td><td align="left">Set the language to override <a href="https://hexo.io/docs/internationalization#Path">auto-detection</a></td><td align="left">Inherited from <code>_config.yml</code></td></tr></tbody></table><h2 id="Hexo插入图片"><a href="#Hexo插入图片" class="headerlink" title="Hexo插入图片"></a>Hexo插入图片</h2><p>版本：Hexo5.0.2（Hexo3以上即可）</p><p>解决方案如下：</p><p>修改配置文件</p><ul><li>  在根目录下配置文件_config.yml 中有 post_asset_folder:false改为true。</li><li>  这样在建立文件时，Hexo会自动建立一个与文章同名的文件夹，这样就可以把与该文章相关的所有资源（图片）都放到那个文件夹里方便后面引用</li><li>  我这里放的图片是：vite.jpg</li><li>  安装插件：hexo-asset-image</li></ul><p><code>npm install https://github.com/7ym0n/hexo-asset-image --save（使用cnpm速度相当会快点，当然npm也可以滴）</code></p><ul><li>  使用这个插件来引入图片，而不是网上那些方法里说的用传统md语法相对路径的方法。</li><li>  插入图片时用这种方式：</li></ul><p><code>&#123;% asset_img vite.jpg This is an test image %&#125;</code></p><ul><li>  其中vite.jpg就是你要引用的图片，我这里就是vite.jpg，后面的This is an test image是图片描述，可以自己修改。</li></ul><h1 id="4-部署到GitHub"><a href="#4-部署到GitHub" class="headerlink" title="4. 部署到GitHub"></a>4. 部署到GitHub</h1><p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deploy:  type: git</span><br></pre></td></tr></table></figure><p>您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deploy: - type: git  repo: - type: heroku  repo:</span><br></pre></td></tr></table></figure><p>Refer to the <a href="https://hexo.io/plugins/">Plugins</a> list for more deployment plugins.</p><p><strong>缩进</strong></p><p>YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ol><li>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ol><li>修改配置。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deploy:  type: git  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io  branch: [branch]  message: [message]</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th><th><strong>默认</strong></th></tr></thead><tbody><tr><td>repo</td><td>库（Repository）地址</td><td></td></tr><tr><td>branch</td><td>分支名称</td><td>gh-pages (GitHub) coding-pages (Coding.net) master (others)</td></tr><tr><td>message</td><td>自定义提交信息</td><td>Site updated: <code>&#123;&#123;` now('YYYY-MM-DD HH:mm:ss') `&#125;&#125;</code>)</td></tr><tr><td>token</td><td>Optional token value to authenticate with the repo. Prefix with $ to read token from environment variable</td><td></td></tr></tbody></table><ol><li>生成站点文件并推送至远程库。执行 hexo clean &amp;&amp; hexo deploy。</li></ol><ul><li>You will be prompted with username and password of the target repository, unless you authenticate with a token or ssh key.</li><li>hexo-deployer-git does not store your username and password. Use <a href="https://git-scm.com/docs/git-credential-cache">git-credential-cache</a> to store them temporarily.</li></ul><ol><li>登入 Github/BitBucket/Gitlab，请在库设置（Repository Settings）中将默认分支设置为_config.yml配置中的分支名称。稍等片刻，您的站点就会显示在您的Github Pages中。</li></ol><h2 id="GitHub项目创建"><a href="#GitHub项目创建" class="headerlink" title="GitHub项目创建"></a>GitHub项目创建</h2><p>注意：项目文件名必须是 &lt;用户名&gt;.github.io</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27188772/1664271440539-12f83f73-d804-4dce-b0be-d769b07527c5.png" alt="img"></p><p>代码上传到GitHub仓库后就可以通过访问<a href="https://pokemonfeng.github.io/%E6%9D%A5%E6%9F%A5%E7%9C%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2">https://pokemonfeng.github.io/来查看自己的博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub代码提交失败</title>
      <link href="/2022/09/27/GitHub%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E5%A4%B1%E8%B4%A5/"/>
      <url>/2022/09/27/GitHub%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.choupangxia.com/2021/05/18/git-error/">参考文章</a></p><h2 id="Git操作失败场景"><a href="#Git操作失败场景" class="headerlink" title="Git操作失败场景"></a>Git操作失败场景</h2><p>原来项目中使用Git是正常的，无论是GitHub的项目还是码云的项目，都是可以正常pull和push的。但当将Mac Book的操作系统升级之后，发现Git无法执行pull和push操作，add和commit操作都还是正常的。</p><h2 id="网络上的状况和解决方案"><a href="#网络上的状况和解决方案" class="headerlink" title="网络上的状况和解决方案"></a>网络上的状况和解决方案</h2><p>如果你不是因为升级操作系统导致的git失效，你可以先尝试一下网络上的解决方案。</p><h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p>在命令行执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关GitHub无法访问问题</title>
      <link href="/2022/09/27/%E6%9C%89%E5%85%B3GitHub%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/27/%E6%9C%89%E5%85%B3GitHub%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_27415615/article/details/124791034?ops_request_misc=&request_id=&biz_id=102&utm_term=github%E5%AE%98%E7%BD%91%E8%BF%9B%E4%B8%8D%E5%8E%BB&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-124791034.nonecase&spm=1018.2226.3001.4187">参考资料</a></p><p>用<a href="https://tool.chinaz.com/dns?type=1">IP地址查找工具1</a>或者<a href="https://www.ipaddress.com/">IP地址查找工具2</a>将查找的ip地址通过<a href="http://www.electronjs.org/apps/switchhosts">switchhosts（hosts切换工具）</a>更改本地hosts的方式</p><h1 id="第一步：ping一下Github的官网，测试网络连通性"><a href="#第一步：ping一下Github的官网，测试网络连通性" class="headerlink" title="第一步：ping一下Github的官网，测试网络连通性"></a>第一步：ping一下Github的官网，测试网络连通性</h1><p>如果进不去Github官网的话，当你用ping工具执行ping github.com命令时，显示的TTL很高或者提示“请求超时”，我的是请求超时</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27188772/1664210519497-5dfabb33-f342-468b-b1e2-4ef3e48aad41.png" alt="img"></p><p>如果当你通过第一步发现ping giithub.com的网速显示请求超时的时候，接下来进行第二步；</p><h1 id="第二步：修改hosts文件（用hosts切换工具方便一点，前言里有）"><a href="#第二步：修改hosts文件（用hosts切换工具方便一点，前言里有）" class="headerlink" title="第二步：修改hosts文件（用hosts切换工具方便一点，前言里有）"></a>第二步：修改hosts文件（用hosts切换工具方便一点，前言里有）</h1><p>没有hosts切换工具的，在如下位置找到hosts并手动修改（直接保存可能存在权限问题，百度一下解决）</p><hr><p>Windows 系统位于 C:\Windows\System32\drivers\etc<br>Android（安卓）系统hosts位于 /etc/<br>Mac（苹果电脑）系统hosts位于 /etc/<br>iPhone（iOS）系统hosts位于 /etc/<br>Linux系统hosts位于 /etc/<br>绝大多数Unix系统都是在 /etc/</p><p>在hosts文件最后加上以下内容（一般以追加的方式修改）</p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/26/hello-world/"/>
      <url>/2022/09/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
