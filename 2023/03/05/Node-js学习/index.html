<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <title>
    Node.js学习 | pika的博客空间
  </title>
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta name="theme-color" content="#4184f3">
  
  
  <link href="https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143023.png" rel="icon" />
  

  
<link rel="stylesheet" href="/css/highlight.light.css">

  
<link rel="stylesheet" href="/css/prism-customize.css">

  
<link rel="stylesheet" href="/css/nav-icon.css">

  
<link rel="stylesheet" href="/css/waves.min.css">

  
<link rel="stylesheet" href="/css/jquery.tocify.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/nav-indicator.css">

  
<link rel="stylesheet" href="/css/twikoo.css">

  
<link rel="stylesheet" href="/css/search.css">

  
  

  

  </meta>
  </meta>
  <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js"></script>
  
<script src="/js/comment.js"></script>

  
<script src="/js/copy.js"></script>

<meta name="generator" content="Hexo 5.4.2"></head>

	<body>
		<header>
			<!-- cover image or sth. -->
		</header>
		<div id="main" class="m-scene">
			
<div class="nav-wrapper" id="header">

    <div class="container">
        <nav>
            
            
            <div class="logo wave">
                <a href="/" id="logo">
                    pika的博客空间
                </a>
            </div>

            

            <div class="nav-toggle-icon" >
                <div class="material-hamburger">
                    <span>
                    </span>
                    <span>
                    </span>
                    <span>
                    </span>
                </div>
            </div>

            <div class="menu-wrapper">
                <div class="nav-indicator">
                </div>
                <ul class="menus">
                    
                     
                        <li>
                            <a class="wave " href="/">
                                首页
                            </a>
                        </li>
                     
                        <li>
                            <a class="wave " href="/archives">
                                归档
                            </a>
                        </li>
                     
                        <li>
                            <a class="wave " href="/about">
                                关于
                            </a>
                        </li>
                     
                        <li>
                            <a class="wave " href="/message">
                                留言
                            </a>
                        </li>
                     
                        <li>
                            <a class="wave " href="/search">
                                搜索
                            </a>
                        </li>
                     
                    
                   
                </ul>
            </div>

        </nav>
    </div>
</div>


				<div class="container content">
					<div class="scene_element scene_element--fadein">
						<div class="row">
  <div class="main main-article">
    <article>

      
        <header class="post-header no-cover">
      
        </header>

      <!-- 标题 -->
      <h1 class="post-title">
        Node.js学习
      </h1>

      <section class="post-info post-info-bottom">

        <!-- 发布时间 -->
        <span class="post-date">
          <span class="post-date-text">
            发布于: 2023-03-05
          </span>
        </span>
        
        <!-- 分类 -->
        

        <!-- 标签 -->
        
          <span class="post-tags">
            <ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li></ul>
          </span>
        

        <!-- 阅读量统计 -->
        

      </section>

      <!-- 正文 -->
      <section class="post-content">
        <h1 id="Node-js基础"><a href="#Node-js基础" class="headerlink" title="Node.js基础"></a>Node.js基础</h1><h2 id="初识-Nodejs"><a href="#初识-Nodejs" class="headerlink" title="初识 Nodejs"></a>初识 Nodejs</h2><p><strong>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine</strong></p>
<p><strong>Node.js® 是一个基于 Chrome V8 引擎 的 JavaScript 运行时环境</strong></p>
<ul>
<li>  基于 <a target="_blank" rel="noopener" href="http://www.expressjs.com.cn/">Express 框架(opens new window)</a>，可以快速构建 Web 应用</li>
<li>  基于 <a target="_blank" rel="noopener" href="https://electronjs.org/">Electron 框架(opens new window)</a>，可以构建跨平台的桌面应用</li>
<li>  基于 <a target="_blank" rel="noopener" href="http://restify.com/">restify 框架(opens new window)</a>，可以快速构建 API 接口项目</li>
<li>  读写和操作数据库、创建实用的命令行工具辅助前端开发、etc…</li>
</ul>
<h2 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer 缓冲区"></a>Buffer 缓冲区</h2><p><a target="_blank" rel="noopener" href="http://nodejs.cn/api/buffer.html">Buffer 缓冲区文档(opens new window)</a></p>
<ul>
<li>  Buffer 的结构与数组类似，操作方法也与数组类似</li>
<li>  数组不能存储二进制文件，Buffer 是专门存储二进制数据的</li>
<li>  Buffer 存储的是二进制数据，显示时以 16 进制的形式显示</li>
<li>  Buffer 每一个元素范围是 00<del>ff，即 0</del>255、00000000~11111111</li>
<li>  每一个元素占用一个字节内存</li>
<li>  Buffer 是对底层内存的直接操作，因此大小一旦确定就不能修改</li>
</ul>
<p>Buffer 常用方法：</p>
<ul>
<li>  Buffer.from(str[, encoding])：将一个字符串转换为 Buffer</li>
<li>  Buffer.alloc(size)：创建指定大小的 Buffer</li>
<li>  Buffer.alloUnsafe(size)：创建指定大小的 Buffer，可能包含敏感数据（分配内存时不会清除内存残留的数据）</li>
<li>  buf.toString()：将 Buffer 数据转为字符串</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;Hello前端&#x27;</span><br><span class="line"></span><br><span class="line">var buf = Buffer.from(str)</span><br><span class="line"></span><br><span class="line">// 占用内存的大小，一个汉字3字节 13</span><br><span class="line">console.log(buf.length)</span><br><span class="line">// 字符串的长度 7</span><br><span class="line">console.log(str.length)</span><br><span class="line">// 8进制输出第一个元素 145</span><br><span class="line">console.log(buf[1].toString(8))</span><br><span class="line"></span><br><span class="line">//创建一个10个字节的buffer</span><br><span class="line">var buf2 = Buffer.alloc(10)</span><br><span class="line">//通过索引，来操作buf中的元素</span><br><span class="line">buf2[0] = 88</span><br><span class="line">buf2[1] = 255</span><br><span class="line">buf2[2] = 0xaa</span><br><span class="line">buf2[3] = 255</span><br><span class="line"></span><br><span class="line">var buf3 = Buffer.allocUnsafe(10)</span><br><span class="line">console.log(buf3)</span><br></pre></td></tr></table></figure>

<h2 id="fs-文件系统模块"><a href="#fs-文件系统模块" class="headerlink" title="fs 文件系统模块"></a>fs 文件系统模块</h2><ul>
<li>  fs 模块中所有的操作都有两种形式可供选择:同步和异步</li>
<li>  同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码</li>
<li>  异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回</li>
<li>  实际开发很少用同步方式，因此只介绍异步方式</li>
</ul>
<p>打开模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>读取文件，文件不存在抛异常</td>
</tr>
<tr>
<td>r+</td>
<td>读写文件，文件不存在抛异常</td>
</tr>
<tr>
<td>rs</td>
<td>同步模式下打开文件用于读取</td>
</tr>
<tr>
<td>rs+</td>
<td>同步模式下打开文件用于读写</td>
</tr>
<tr>
<td>w</td>
<td>写文件，不存在则创建，存在则覆盖原有内容</td>
</tr>
<tr>
<td>wx</td>
<td>写文件，文件存在打开失败</td>
</tr>
<tr>
<td>w+</td>
<td>读写文件，不存在创建，存在截断</td>
</tr>
<tr>
<td>wx+</td>
<td>读写，存在打开失败</td>
</tr>
<tr>
<td>a</td>
<td>追加，不存在创建</td>
</tr>
<tr>
<td>ax</td>
<td>追加，存在失败</td>
</tr>
<tr>
<td>a+</td>
<td>追加和读取，不存在创建</td>
</tr>
<tr>
<td>ax+</td>
<td>追加和读取，存在失败</td>
</tr>
</tbody></table>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><h4 id="简单文件读取"><a href="#简单文件读取" class="headerlink" title="简单文件读取"></a>简单文件读取</h4><p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(path[, options], callback)</span><br></pre></td></tr></table></figure>

<ul>
<li>  path：文件路径</li>
<li>  options：配置选项，若是字符串则指定编码格式</li>
</ul>
<!---->

<ul>
<li><ul>
<li>  encoding：编码格式</li>
<li>  flag：打开方式</li>
</ul>
</li>
</ul>
<!---->

<ul>
<li>  callback：回调函数</li>
</ul>
<!---->

<ul>
<li><ul>
<li>  err：错误信息</li>
<li>  data：读取的数据，如果未指定编码格式则返回一个 Buffer</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">fs.readFile(&#x27;./files/1.txt&#x27;, &#x27;utf-8&#x27;, function(err, data) =&gt; &#123;</span><br><span class="line">  if(err) &#123;</span><br><span class="line">    return console.log(&#x27;failed!&#x27; + err.message)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#x27;content:&#x27; + data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 复制文件内容</span><br><span class="line">fs.readFile(&quot;C:/Users/笔记.mp3&quot;, function(err, data) &#123;</span><br><span class="line">	if(!err) &#123;</span><br><span class="line">		console.log(data);</span><br><span class="line">		// 将data写入到文件中</span><br><span class="line">		fs.writeFile(&quot;C:/Users/hello.jpg&quot;, data, function(err)&#123;</span><br><span class="line">			if(!err)&#123;</span><br><span class="line">				console.log(&quot;文件写入成功&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="流式文件读取"><a href="#流式文件读取" class="headerlink" title="流式文件读取"></a>流式文件读取</h4><ul>
<li>  简单文件读取的方式会一次性读取文件内容到内存中，若文件较大，会占用过多内存影响系统性能，且读取速度慢</li>
<li>  大文件适合用流式文件读取，它会分多次将文件读取到内存中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">// 创建一个可读流</span><br><span class="line">var rs = fs.createReadStream(&#x27;C:/Users/笔记.mp3&#x27;)</span><br><span class="line">// 创建一个可写流</span><br><span class="line">var ws = fs.createWriteStream(&#x27;a.mp3&#x27;)</span><br><span class="line"></span><br><span class="line">// 监听流的开启和关闭</span><br><span class="line">// 这几个监听不是必须的</span><br><span class="line">rs.once(&#x27;open&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;可读流打开了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.once(&#x27;close&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;可读流关闭了~~&#x27;)</span><br><span class="line">  //数据读取完毕，关闭可写流</span><br><span class="line">  ws.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&#x27;open&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;可写流打开了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&#x27;close&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;可写流关闭了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//要读取一个可读流中的数据，要为可读流绑定一个data事件，data事件绑定完毕自动开始读取数据</span><br><span class="line">rs.on(&#x27;data&#x27;, function (data) &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">  //将读取到的数据写入到可写流中</span><br><span class="line">  ws.write(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>简便方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">var rs = fs.createReadStream(&#x27;C:/Users/lilichao/Desktop/笔记.mp3&#x27;)</span><br><span class="line">var ws = fs.createWriteStream(&#x27;b.mp3&#x27;)</span><br><span class="line"></span><br><span class="line">// pipe()可以将可读流中的内容，直接输出到可写流中</span><br><span class="line">rs.pipe(ws)</span><br></pre></td></tr></table></figure>

<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><h4 id="简单文件写入"><a href="#简单文件写入" class="headerlink" title="简单文件写入"></a>简单文件写入</h4><p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(file, data[, options], callback) </span><br></pre></td></tr></table></figure>

<ul>
<li>  file：文件路径</li>
<li>  data：写入内容</li>
<li>  options：配置选项，包含 encoding, mode, flag；若是字符串则指定编码格式</li>
<li>  callback：回调函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">fs.writeFile(&#x27;./files/2.txt&#x27;, &#x27;Hello Nodejs&#x27;, function (err) &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    return console.log(&#x27;failed!&#x27; + err.message)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#x27;success!&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.writeFile(&#x27;C:/Users/hello.txt&#x27;, &#x27;通过 writeFile 写入的内容&#x27;, &#123; flag: &#x27;w&#x27; &#125;, function (err) &#123;</span><br><span class="line">  if (!err) &#123;</span><br><span class="line">    console.log(&#x27;写入成功！&#x27;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="流式文件写入"><a href="#流式文件写入" class="headerlink" title="流式文件写入"></a>流式文件写入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 同步、异步、简单文件的写入都不适合大文件的写入，性能较差，容易导致内存溢出</span><br><span class="line">var fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">// 创建一个可写流</span><br><span class="line">var ws = fs.createWriteStream(&#x27;hello3.txt&#x27;)</span><br><span class="line"></span><br><span class="line">ws.once(&#x27;open&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;流打开了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&#x27;close&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;流关闭了~~&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 通过ws向文件中输出内容</span><br><span class="line">ws.write(&#x27;通过可写流写入文件的内容&#x27;)</span><br><span class="line">ws.write(&#x27;1&#x27;)</span><br><span class="line">ws.write(&#x27;2&#x27;)</span><br><span class="line">ws.write(&#x27;3&#x27;)</span><br><span class="line">ws.write(&#x27;4&#x27;)</span><br><span class="line"></span><br><span class="line">// 关闭流</span><br><span class="line">ws.end()</span><br></pre></td></tr></table></figure>

<h3 id="路径动态拼接问题-dirname"><a href="#路径动态拼接问题-dirname" class="headerlink" title="路径动态拼接问题 __dirname"></a>路径动态拼接问题 __dirname</h3><ul>
<li>  在使用 fs 模块操作文件时，如果提供的操作路径是以 ./ 或 ../ 开头的相对路径时，容易出现路径动态拼接错误的问题</li>
<li>  原因：代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径</li>
<li>  解决方案：在使用 fs 模块操作文件时，直接提供完整的路径，从而防止路径动态拼接的问题</li>
<li>  __dirname 获取文件所处的绝对路径</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(__dirname + &#x27;/files/1.txt&#x27;, &#x27;utf8&#x27;, function(err, data) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h3><p>验证路径是否存在：</p>
<ul>
<li>  fs.exists(path, callback)</li>
<li>  fs.existsSync(path)</li>
</ul>
<p>获取文件信息：</p>
<ul>
<li>  fs.stat(path, callback)</li>
<li>  fs.stat(path)</li>
</ul>
<p>删除文件：</p>
<ul>
<li>  fs.unlink(path, callback)</li>
<li>  fs.unlinkSync(path)</li>
</ul>
<p>列出文件：</p>
<ul>
<li>  fs.readdir(path[,options], callback)</li>
<li>  fs.readdirSync(path[, options])</li>
</ul>
<p>截断文件：</p>
<ul>
<li>  fs.truncate(path, len, callback)</li>
<li>  fs.truncateSync(path, len)</li>
</ul>
<p>建立目录：</p>
<ul>
<li>  fs.mkdir(path[, mode], callback)</li>
<li>  fs.mkdirSync(path[, mode])</li>
</ul>
<p>删除目录：</p>
<ul>
<li>  fs.rmdir(path, callback)</li>
<li>  fs.rmdirSync(path)</li>
</ul>
<p>重命名文件和目录：</p>
<ul>
<li>  fs.rename(oldPath, newPath, callback)</li>
<li>  fs.renameSync(oldPath, newPath)</li>
</ul>
<p>监视文件更改：</p>
<ul>
<li>  fs.watchFile(filename[, options], listener)</li>
</ul>
<h2 id="path-路径模块"><a href="#path-路径模块" class="headerlink" title="path 路径模块"></a>path 路径模块</h2><p>path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。</p>
<h3 id="路径拼接-path-join"><a href="#路径拼接-path-join" class="headerlink" title="路径拼接 path.join()"></a>路径拼接 path.join()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">// 注意 ../ 会抵消前面的路径</span><br><span class="line">// ./ 会被忽略</span><br><span class="line">const pathStr = path.join(&#x27;/a&#x27;, &#x27;/b/c&#x27;, &#x27;../../&#x27;, &#x27;./d&#x27;, &#x27;e&#x27;)</span><br><span class="line">console.log(pathStr) // \a\d\e</span><br><span class="line"></span><br><span class="line">fs.readFile(path.join(__dirname, &#x27;./files/1.txt&#x27;), &#x27;utf8&#x27;, function (err, dataStr) &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    return console.log(err.message)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="获取路径中文件名-path-basename"><a href="#获取路径中文件名-path-basename" class="headerlink" title="获取路径中文件名 path.basename()"></a>获取路径中文件名 path.basename()</h3><p>使用 path.basename() 方法，可以获取路径中的最后一部分，常通过该方法获取路径中的文件名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.basename(path[, ext])</span><br></pre></td></tr></table></figure>

<ul>
<li>  path: 文件路径</li>
<li>  ext: 文件扩展名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">// 定义文件的存放路径</span><br><span class="line">const fpath = &#x27;/a/b/c/index.html&#x27;</span><br><span class="line"></span><br><span class="line">const fullName = path.basename(fpath)</span><br><span class="line">console.log(fullName) // index.html</span><br><span class="line"></span><br><span class="line">const nameWithoutExt = path.basename(fpath, &#x27;.html&#x27;)</span><br><span class="line">console.log(nameWithoutExt) // index</span><br></pre></td></tr></table></figure>

<h3 id="获取路径中文件扩展名-path-extname"><a href="#获取路径中文件扩展名-path-extname" class="headerlink" title="获取路径中文件扩展名 path.extname()"></a>获取路径中文件扩展名 path.extname()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">const fpath = &#x27;/a/b/c/index.html&#x27;</span><br><span class="line"></span><br><span class="line">const fext = path.extname(fpath)</span><br><span class="line">console.log(fext) // .html</span><br></pre></td></tr></table></figure>

<h2 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h2><p>http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。</p>
<h3 id="创建基本-Web-服务器"><a href="#创建基本-Web-服务器" class="headerlink" title="创建基本 Web 服务器"></a>创建基本 Web 服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;)</span><br><span class="line"></span><br><span class="line">// 创建 web 服务器实例</span><br><span class="line">const server = http.createServer()</span><br><span class="line"></span><br><span class="line">// 为服务器实例绑定 request 事件，监听客户端的请求</span><br><span class="line">server.on(&#x27;request&#x27;, function (req, res) &#123;</span><br><span class="line">  const url = req.url</span><br><span class="line">  const method = req.method</span><br><span class="line">  const str = `Your request url is $&#123;url&#125;, and request method is $&#123;method&#125;`</span><br><span class="line">  console.log(str)</span><br><span class="line"></span><br><span class="line">  // 设置 Content-Type 响应头，解决中文乱码的问题</span><br><span class="line">  res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;)</span><br><span class="line">  // 向客户端响应内容</span><br><span class="line">  res.end(str)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(8080, function () &#123;</span><br><span class="line">  console.log(&#x27;server running at http://127.0.0.1:8080&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="实现简陋路由效果"><a href="#实现简陋路由效果" class="headerlink" title="实现简陋路由效果"></a>实现简陋路由效果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;)</span><br><span class="line">const server = http.createServer()</span><br><span class="line"></span><br><span class="line">server.on(&#x27;request&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  const url = req.url</span><br><span class="line">  // 设置默认的响应内容为 404 Not found</span><br><span class="line">  let content = &#x27;&lt;h1&gt;404 Not found!&lt;/h1&gt;&#x27;</span><br><span class="line">  // 判断用户请求的是否为 / 或 /index.html 首页</span><br><span class="line">  // 判断用户请求的是否为 /about.html 关于页面</span><br><span class="line">  if (url === &#x27;/&#x27; || url === &#x27;/index.html&#x27;) &#123;</span><br><span class="line">    content = &#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27;</span><br><span class="line">  &#125; else if (url === &#x27;/about.html&#x27;) &#123;</span><br><span class="line">    content = &#x27;&lt;h1&gt;关于页面&lt;/h1&gt;&#x27;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;)</span><br><span class="line">  res.end(content)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(80, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;server running at http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="模块化概念"><a href="#模块化概念" class="headerlink" title="模块化概念"></a>模块化概念</h3><ul>
<li>  模块化是指解决一个复杂问题时，自顶向下逐层把系统划分为若干模块的过程，模块是可组合、分解和更换的单元。</li>
<li>  模块化可提高代码的复用性和可维护性，实现按需加载。</li>
<li>  模块化规范是对代码进行模块化拆分和组合时需要遵守的规则，如使用何种语法格式引用模块和向外暴露成员。</li>
</ul>
<h3 id="Node-js-中模块的分类"><a href="#Node-js-中模块的分类" class="headerlink" title="Node.js 中模块的分类"></a>Node.js 中模块的分类</h3><ul>
<li>  内置模块</li>
<li>  自定义模块</li>
<li>  第三方模块</li>
</ul>
<h3 id="Node-js-中的模块作用域"><a href="#Node-js-中的模块作用域" class="headerlink" title="Node.js 中的模块作用域"></a>Node.js 中的模块作用域</h3><ul>
<li>  和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域</li>
<li>  防止全局变量污染</li>
</ul>
<h3 id="模块作用域的成员"><a href="#模块作用域的成员" class="headerlink" title="模块作用域的成员"></a>模块作用域的成员</h3><ul>
<li>  自定义模块中都有一个 module 对象，存储了和当前模块有关的信息</li>
<li>  在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。导入自定义模块时，得到的就是 module.exports 指向的对象。</li>
<li>  默认情况下，exports 和 module.exports 指向同一个对象。最终共享的结果，以 module.exports 指向的对象为准。</li>
</ul>
<h3 id="CommonJS-模块化规范"><a href="#CommonJS-模块化规范" class="headerlink" title="CommonJS 模块化规范"></a>CommonJS 模块化规范</h3><ul>
<li>  每个模块内部，module 变量代表当前模块</li>
<li>  module 变量是一个对象，module.exports 是对外的接口</li>
<li>  加载某个模块即加载该模块的 module.exports 属性</li>
</ul>
<h3 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h3><p>模块第一次加载后会被缓存，即多次调用 require() 不会导致模块的代码被执行多次，提高模块加载效率。</p>
<h4 id="内置模块加载"><a href="#内置模块加载" class="headerlink" title="内置模块加载"></a>内置模块加载</h4><p>内置模块加载优先级最高。</p>
<h4 id="自定义模块加载"><a href="#自定义模块加载" class="headerlink" title="自定义模块加载"></a>自定义模块加载</h4><p>加载自定义模块时，路径要以 ./ 或 ../ 开头，否则会作为内置模块或第三方模块加载。</p>
<p>导入自定义模块时，若省略文件扩展名，则 Node.js 会按顺序尝试加载文件：</p>
<ul>
<li>  按确切的文件名加载</li>
<li>  补全 .js 扩展名加载</li>
<li>  补全 .json 扩展名加载</li>
<li>  补全 .node 扩展名加载</li>
<li>  加载失败，终端报错</li>
</ul>
<h4 id="第三方模块加载"><a href="#第三方模块加载" class="headerlink" title="第三方模块加载"></a>第三方模块加载</h4><ul>
<li>  若导入第三方模块， Node.js 会从<strong>当前模块的父目录</strong>开始，尝试从 /node_modules 文件夹中加载第三方模块。</li>
<li>  如果没有找到对应的第三方模块，则移动到再<strong>上一层父目录</strong>中，进行加载，直到<strong>文件系统的根目录</strong>。</li>
</ul>
<p>例如，假设在 C:\Users\itchen\project\foo.js 文件里调用了 require(‘tools’)，则 Node.js 会按以下顺序查找：</p>
<ul>
<li>  C:\Users\itchen\project\node_modules\tools</li>
<li>  C:\Users\itchen\node_modules\tools</li>
<li>  C:\Users\node_modules\tools</li>
<li>  C:\node_modules\tools</li>
</ul>
<h4 id="目录作为模块加载"><a href="#目录作为模块加载" class="headerlink" title="目录作为模块加载"></a>目录作为模块加载</h4><p>当把目录作为模块标识符进行加载的时候，有三种加载方式：</p>
<ul>
<li>  在被加载的目录下查找 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口</li>
<li>  如果没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。</li>
<li>如果以上两步都失败了，则Node.js会在终端打印错误消息，报告模板的缺失：Error: Cannot find module ‘xxx</li>
</ul>
<h2 id="3-Node-js与包"><a href="#3-Node-js与包" class="headerlink" title="3. Node.js与包"></a>3. Node.js与包</h2><h3 id="解决包下载速度慢的问题"><a href="#解决包下载速度慢的问题" class="headerlink" title="解决包下载速度慢的问题"></a>解决包下载速度慢的问题</h3><h4 id="1-nrm"><a href="#1-nrm" class="headerlink" title="1. nrm"></a>1. nrm</h4><p>为了更方便的切换下包的镜像资源，我们可以安装nrm这个小工具，利用nrm提供的终端命令，可以快速查看和切换下包的镜像资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 下载包</span><br><span class="line">npm i nrm -g</span><br><span class="line">// 查看所有可用的镜像资源</span><br><span class="line">nrm ls</span><br><span class="line">// 讲下包的镜像资源切换为taobao镜像</span><br><span class="line">nrm use taobao</span><br></pre></td></tr></table></figure>

<h3 id="开发属于自己的包"><a href="#开发属于自己的包" class="headerlink" title="开发属于自己的包"></a>开发属于自己的包</h3><h4 id="1-初始化包的基本结构"><a href="#1-初始化包的基本结构" class="headerlink" title="1. 初始化包的基本结构"></a>1. 初始化包的基本结构</h4><ol>
<li> 新建itfeng-tools文件夹，作为包的根目录</li>
<li> 在itfeng-tools文件夹中，新建如下三个文件</li>
</ol>
<ul>
<li>  package.json（包管理配置文件）</li>
<li>  index.js （包的入口文件）</li>
<li>  RWADME.md （包的说明文档）</li>
</ul>
<h4 id="2-初始化package-json"><a href="#2-初始化package-json" class="headerlink" title="2.初始化package.json"></a>2.初始化package.json</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;itfengzi-tools&quot;, // 包名称 注意包名不能与已经存在的报名重复</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,	// 版本</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;, // 入口文件</span><br><span class="line">  &quot;description&quot;: &quot;提供了格式化时间，HTMLEscape相关的功能&quot;, // 包的介绍信息</span><br><span class="line">  &quot;keywords&quot;: [ // 搜索关键字</span><br><span class="line">    &quot;itfengzi&quot;,</span><br><span class="line">    &quot;dateFormat&quot;,</span><br><span class="line">    &quot;escape&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot; // 包遵循的许可协议</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h3><h4 id="1-注册npm账号"><a href="#1-注册npm账号" class="headerlink" title="1. 注册npm账号"></a>1. 注册npm账号</h4><ol>
<li> 访问<a target="_blank" rel="noopener" href="https://www.npmjs.com/">https://www.npmjs.com/</a>网站，点击sign up按钮，进入注册用户界面</li>
<li> 填写账号相关信息：Full Name、Public Email、Username、Password</li>
<li> 点击Create an Account按钮，注册账号</li>
<li> 登录邮箱，点击验证链接，进行账号的验证</li>
</ol>
<h4 id="2-登录npm账号"><a href="#2-登录npm账号" class="headerlink" title="2.登录npm账号"></a>2.登录npm账号</h4><p>npm账号注册完成后，可以在终端中执行<code>npm login</code>命令，依次输入用户名、密码、邮箱后，即可登录成功</p>
<ul>
<li>  注意：在运行npm login命令之前，必须先把下包的服务器地址切换为npm的官方服务器，否则会导致发布包失败</li>
<li>  可以使用nrm工具切换下包服务器</li>
</ul>
<p><code>nrm use npm</code></p>
<h4 id="3-把包发布到npm上"><a href="#3-把包发布到npm上" class="headerlink" title="3.把包发布到npm上"></a>3.把包发布到npm上</h4><p>将终端切换到包的根目录之后，运行<code>npm publish</code>命令，即可将包发布到npm上</p>
<h4 id="4-删除已发布的包"><a href="#4-删除已发布的包" class="headerlink" title="4.删除已发布的包"></a>4.删除已发布的包</h4><p>运行<code>npm unpublish 包名 --force</code>命令，即可从npm删除已发布的包</p>
<p>注意：</p>
<ul>
<li>  npm unpublish 命令只能删除72小时以内发布的包</li>
<li>  npm unpublish 删除的包，在24小时内不允许重复发布</li>
<li>  发布包的时候要慎重，尽量不要发布没有意义的包</li>
</ul>
<h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><p><a target="_blank" rel="noopener" href="https://www.expressjs.com.cn/">官网传送门(opens new window)</a></p>
<p><strong>基于 Node.js 平台，快速、开放、极简的 Web 开发框架</strong></p>
<p>Express 是用于快速创建服务器的第三方模块。</p>
<p>Express的本质：就是一个npm上的第三方包，提供了快速创建Web服务器的便捷方法</p>
<p>对于前端程序员来说，最常见的两种服务器，分别是：</p>
<ul>
<li>  Web网站服务器：专门对外提供Web网页资源的服务器</li>
<li>  API接口服务器：专门对外提供API接口的服务区</li>
</ul>
<p>使用Express，我们可以方便、快速的创建Web网站的服务器或API接口的服务器</p>
<h2 id="Express-初体验"><a href="#Express-初体验" class="headerlink" title="Express 初体验"></a>Express 初体验</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装 Express：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure>

<p>创建服务器，监听客户端请求，并返回内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">// 创建 web 服务器</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">// 监听客户端的 GET 和 POST 请求，并向客户端响应具体的内容</span><br><span class="line">app.get(&#x27;/user&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#123; name: &#x27;zs&#x27;, age: 20, gender: &#x27;男&#x27; &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.post(&#x27;/user&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;请求成功&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  // 通过 req.query 可以获取到客户端发送过来的查询参数</span><br><span class="line">  console.log(req.query)</span><br><span class="line">  res.send(req.query)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 这里的 :id 是一个动态的参数</span><br><span class="line">app.get(&#x27;/user/:ids/:username&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  // req.params 是动态匹配到的 URL 参数，默认是一个空对象</span><br><span class="line">  console.log(req.params)</span><br><span class="line">  res.send(req.params)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(80, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;express server running at http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h3><ul>
<li>  通过 express.static() 方法可创建静态资源服务器，向外开放访问静态资源。</li>
<li>  Express 在指定的静态目录中查找文件，并对外提供资源的访问路径，存放静态文件的目录名不会出现在 URL 中</li>
<li>  访问静态资源时，会根据托管顺序查找文件</li>
<li>  可为静态资源访问路径添加前缀</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(&#x27;public&#x27;))</span><br><span class="line">app.use(express.static(&#x27;files&#x27;))</span><br><span class="line">// 挂载路劲前缀</span><br><span class="line">app.use(&#x27;/bruce&#x27;, express.static(&#x27;bruce&#x27;))</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">可直接访问 public, files 目录下的静态资源</span><br><span class="line">http://localhost:3000/images/bg.jpg</span><br><span class="line">http://localhost:3000/css/style.css</span><br><span class="line">http://localhost:3000/js/login.js</span><br><span class="line"></span><br><span class="line">通过带有 /bruce 前缀的地址访问 bruce 目录下的文件</span><br><span class="line">http://localhost:8080/bruce/images/logo.png</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h3><p>安装nodemon</p>
<p><code>npm install -g nodemon</code></p>
<p>可以间node命令替换为nodemon命令，使用nodemon app.js来启动项目，这样启动之后代码被修改之后，会被nodemon监听到，从而实现自动重启项目的效果</p>
<h2 id="Express-路由"><a href="#Express-路由" class="headerlink" title="Express 路由"></a>Express 路由</h2><p>在express中，路由指的是客户端的请求与服务器处理函数之间的映射关系</p>
<p>Express中的路由分3部分组成，分别是请求的类型，请求的URL地址、处理函数</p>
<p><code>app.METHOD(PATH, HANDLER)</code></p>
<h3 id="路由的概念"><a href="#路由的概念" class="headerlink" title="路由的概念"></a>路由的概念</h3><h4 id="路由的匹配过程"><a href="#路由的匹配过程" class="headerlink" title="路由的匹配过程"></a>路由的匹配过程</h4><p>每当一个请求到服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数</p>
<p>在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的URL同时匹配成功，则Express会将这次请求，转交给对应的function函数进行处理</p>
<ul>
<li>  按照定义的先后顺序进行匹配</li>
<li>  请求类型和请求的URL同时匹配成功才会调用对应的处理函数</li>
</ul>
<h3 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h3><h4 id="路由基本使用"><a href="#路由基本使用" class="headerlink" title="路由基本使用"></a>路由基本使用</h4><p>创建路由模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">// 挂载路由</span><br><span class="line">app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;hello world&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.post(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;Post Request&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(81, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;express server running at http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="模块化路由"><a href="#模块化路由" class="headerlink" title="模块化路由"></a>模块化路由</h4><p>为了方便对路由进行模块化管理，Express不建议将路由直接挂载到app上，而是推荐将路由抽离为单独的模块；</p>
<ol>
<li> 创建路由模块对应的.js文件</li>
<li> 调用exoress.Router()函数创建路由对象</li>
<li> 向路由对象上挂载具体路由</li>
<li> 使用module.exports向外共享路由对象</li>
<li> 使用app.use()函数注册路由模块</li>
</ol>
<p>创建路由模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// router.js</span><br><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">// 创建路由对象</span><br><span class="line">const router = express.Router()</span><br><span class="line"></span><br><span class="line">// 挂载具体路由</span><br><span class="line">router.get(&#x27;/user/list&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;Get user list.&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">router.post(&#x27;/user/add&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;Add new user.&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 向外导出路由对象</span><br><span class="line">module.exports = router</span><br></pre></td></tr></table></figure>

<p>注册路由模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const router = require(&#x27;./router&#x27;)</span><br><span class="line"></span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">// 注册路由模块，添加访问前缀</span><br><span class="line">app.use(&#x27;/api&#x27;, router)</span><br><span class="line"></span><br><span class="line">app.listen(80, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Express-中间件"><a href="#Express-中间件" class="headerlink" title="Express 中间件"></a>Express 中间件</h2><ul>
<li>  中间件是指流程的中间处理环节</li>
<li>  服务器收到请求后，可先调用中间件进行预处理</li>
<li>  中间件是一个函数，包含 req, res, next 三个参数，next() 参数把流转关系转交给下一个中间件或路由</li>
</ul>
<p>中间件注意事项；</p>
<ul>
<li>  在注册路由之前注册中间件（错误级别中间件除外）</li>
<li>  当一个请求到达Express的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理</li>
<li>  中间件函数的形参列表中，必须包含next参数，而路由处理函数中只包含req和res</li>
<li>  为了防止代码逻辑混乱，调用next()函数数后不再写额外的代码</li>
<li>  多个中间件共享同一份 req、 res对象，基于这样的特性，我们可以在上游的中间件中，统一为req或res对象添加自定义属性或方法，供下游的中间件或路由进行使用</li>
</ul>
<h3 id="全局中间件"><a href="#全局中间件" class="headerlink" title="全局中间件"></a>全局中间件</h3><p>客户端发起的任何请求。到达服务器之后，都会触发的中间件，叫全局生效的中间件</p>
<ul>
<li>  通过 app.use() 定义的中间件为全局中间件</li>
<li>  可以连续定义多个全局中间件，客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">// 定义第一个全局中间件</span><br><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;调用了第1个全局中间件&#x27;)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line">// 定义第二个全局中间件</span><br><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;调用了第2个全局中间件&#x27;)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/user&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;User page.&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(80, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="局部中间件"><a href="#局部中间件" class="headerlink" title="局部中间件"></a>局部中间件</h3><p>不使用app.use()定义的中间件，叫做局部失效的中间件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">// 定义中间件函数</span><br><span class="line">const mw1 = (req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;调用了第一个局部生效的中间件&#x27;)</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mw2 = (req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;调用了第二个局部生效的中间件&#x27;)</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 两种定义局部中间件的方式</span><br><span class="line">app.get(&#x27;/hello&#x27;, mw2, mw1, (req, res) =&gt; res.send(&#x27;hello page.&#x27;))</span><br><span class="line">app.get(&#x27;/about&#x27;, [mw1, mw2], (req, res) =&gt; res.send(&#x27;about page.&#x27;))</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/user&#x27;, (req, res) =&gt; res.send(&#x27;User page.&#x27;))</span><br><span class="line"></span><br><span class="line">app.listen(80, function () &#123;</span><br><span class="line">  console.log(&#x27;Express server running at http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="中间件分类"><a href="#中间件分类" class="headerlink" title="中间件分类"></a>中间件分类</h3><h4 id="应用级别的中间件"><a href="#应用级别的中间件" class="headerlink" title="应用级别的中间件"></a>应用级别的中间件</h4><ul>
<li>  通过 app.use() 或 app.get() 或 app.post() ，绑定到 app 实例上的中间件</li>
</ul>
<h4 id="路由级别的中间件"><a href="#路由级别的中间件" class="headerlink" title="路由级别的中间件"></a>路由级别的中间件</h4><ul>
<li>  绑定到 express.Router() 实例上的中间件，叫做路由级别的中间件。用法和应用级别中间件没有区别。应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到 router 实例上。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const app = express()</span><br><span class="line">const router = express.Router()</span><br><span class="line"></span><br><span class="line">router.use(function (req, res, next) &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(&#x27;/&#x27;, router)</span><br></pre></td></tr></table></figure>

<h4 id="错误级别的中间件"><a href="#错误级别的中间件" class="headerlink" title="错误级别的中间件"></a>错误级别的中间件</h4><ul>
<li>  用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题</li>
<li>  错误级别中间件的处理函数中，必须有 4 个形参，形参顺序从前到后分别是 (err, req, res, next) 。</li>
<li>  错误级别的中间件必须注册在所有路由之后</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  throw new Error(&#x27;服务器内部发生了错误！&#x27;)</span><br><span class="line">  res.send(&#x27;Home page.&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 定义错误级别的中间件，捕获整个项目的异常错误，从而防止程序的崩溃</span><br><span class="line">app.use((err, req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;发生了错误！&#x27; + err.message)</span><br><span class="line">  res.send(&#x27;Error：&#x27; + err.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(80, function () &#123;</span><br><span class="line">  console.log(&#x27;Express server running at http://127.0.0.1&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Express-内置中间件"><a href="#Express-内置中间件" class="headerlink" title="Express 内置中间件"></a>Express 内置中间件</h4><p>自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验：</p>
<ul>
<li>  express.static 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）</li>
<li>  express.json 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li>
<li>  express.urlencoded 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.json())</span><br><span class="line">app.use(express.urlencoded(&#123; extended: false &#125;))</span><br></pre></td></tr></table></figure>

<h4 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h4><p>非Express官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件，在项目中，可以按需下载并配置第三方中间件，从而提高开发效率；</p>
<ul>
<li>  运行<code>npm install body-parser</code>安装中间件</li>
<li>  使用require导入中间件</li>
<li>  调用app.use()注册并使用中间件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">const parser = require(&#x27;body-parser&#x27;)</span><br><span class="line"></span><br><span class="line">app.use(parser.urlencoded(&#123; extended: false &#125;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#x27;Home page&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">app.post(&#x27;/user&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  console.log(req.body);</span><br><span class="line">  res.send(&#x27;User page&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(81, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;http://127.0.0.1:81&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h3><p>自定义一个类似express.urlencoded这样的中间件，来解析post提交到服务器的表单数据</p>
<p>实现步骤：</p>
<ol>
<li> 定义中间件</li>
<li> 监听req的data事件</li>
<li> 监听req的end事件</li>
<li> 使用querystring模块解析请求体数据</li>
<li> 将解析出来的数据对象挂载为req.body</li>
<li> 将自定义中间件封装为模块</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 导入express模块</span><br><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">// 创建express的服务器实例</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">const customBodyParser = require(&#x27;./10.custom-body-parser&#x27;)</span><br><span class="line"></span><br><span class="line">// 这是解析表单数据的中间件</span><br><span class="line">app.use(customBodyParser)</span><br><span class="line"></span><br><span class="line">app.post(&#x27;/user&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  console.log(req.body);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 调用app.listen方法,指定端口号并启动web服务器</span><br><span class="line">app.listen(81, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;http://127.0.0.1:81&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 导入处理querystring的Node.js内置模块</span><br><span class="line">const qs = require(&#x27;querystring&#x27;)</span><br><span class="line"></span><br><span class="line">// 调用qs.parse()方法，把查询字符串解析为对象</span><br><span class="line">const bodyParser = (req, res, next) =&gt; &#123;</span><br><span class="line">  // 定义一个str字符串，专门用来储存客户端发送过来的请求体数据</span><br><span class="line">  let str = &#x27;&#x27;</span><br><span class="line">  // 监听req的data事件</span><br><span class="line">  req.on(&#x27;data&#x27;, (chunk) =&gt; &#123;</span><br><span class="line">    str += chunk</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // 监听req的end事件</span><br><span class="line">  req.on(&#x27;end&#x27;, () =&gt; &#123;</span><br><span class="line">    // 调用qs.parse()方法，把查询字符串解析为对象</span><br><span class="line">    const body = qs.parse(str)</span><br><span class="line">    // 将解析出来的请求体对象，挂载为req.body属性</span><br><span class="line">    req.body = body</span><br><span class="line">    // 最后调用next()函数。执行后续的业务逻辑</span><br><span class="line">    next()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = bodyParser</span><br></pre></td></tr></table></figure>

<h2 id="使用Express写接口"><a href="#使用Express写接口" class="headerlink" title="使用Express写接口"></a>使用Express写接口</h2><h3 id="创建基本服务器"><a href="#创建基本服务器" class="headerlink" title="创建基本服务器"></a>创建基本服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">const router = require(&#x27;./12.apiRouter&#x27;)</span><br><span class="line"></span><br><span class="line">app.use(&#x27;/api&#x27;, router)</span><br><span class="line"></span><br><span class="line">app.listen(81, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;http://127.0.0.1:81&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="创建API路由模块"><a href="#创建API路由模块" class="headerlink" title="创建API路由模块"></a>创建API路由模块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const router = express.Router()</span><br><span class="line"></span><br><span class="line">module.express = router</span><br></pre></td></tr></table></figure>

<h3 id="编写GET接口"><a href="#编写GET接口" class="headerlink" title="编写GET接口"></a>编写GET接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">router.get(&#x27;/get&#x27;, (req, res) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  const query = req.query</span><br><span class="line">  // 调用res.send()方法，向客户端响应结果</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    status: 0, // 0表示处理成功，1表示处理失败</span><br><span class="line">    msg: &#x27;GET 请求成功！&#x27;, // 状态描述</span><br><span class="line">    data: query // 需要响应给客户端的数据</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="编写POST接口"><a href="#编写POST接口" class="headerlink" title="编写POST接口"></a>编写POST接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定义POST接口</span><br><span class="line">router.post(&#x27;/post&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  // 通过req.body获取请求体中包含的url-encoded格式的数据</span><br><span class="line">  const body = req.body</span><br><span class="line">  // 调用res.send()方法，向客户端响应结果</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    status: 0,</span><br><span class="line">    msg: &#x27;POST请求成功&#x27;,</span><br><span class="line">    data: body</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS 跨域资源共享"></a>CORS 跨域资源共享</h3><h4 id="接口的跨域问题"><a href="#接口的跨域问题" class="headerlink" title="接口的跨域问题"></a>接口的跨域问题</h4><p>解决接口跨域的问题的方案主要有两种</p>
<ul>
<li>  CORS（主流的解决方案，推荐使用）</li>
<li>  JSONP（有缺陷的解决方案，只支持GET请求）</li>
</ul>
<h4 id="cors-中间件解决跨域"><a href="#cors-中间件解决跨域" class="headerlink" title="cors 中间件解决跨域"></a>cors 中间件解决跨域</h4><ul>
<li>  安装中间件：<code>npm install cors</code></li>
<li>  导入中间件：const cors = require(‘cors’)</li>
<li>  配置中间件：app.use(cors())</li>
</ul>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><ul>
<li>  CORS（Cross-Origin Resource Sharing，跨域资源共享）解决跨域，是通过 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获取资源</li>
<li>  浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头，就可解除浏览器端的跨域访问限制</li>
<li>  CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。</li>
<li>  CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。</li>
</ul>
<h4 id="CORS-常见响应头"><a href="#CORS-常见响应头" class="headerlink" title="CORS 常见响应头"></a>CORS 常见响应头</h4><ul>
<li>  Access-Control-Allow-Origin：制定了允许访问资源的外域 URL</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;http://bruceblog.io&#x27;)</span><br><span class="line">res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;)</span><br></pre></td></tr></table></figure>

<ul>
<li>  Access-Control-Allow-Headers</li>
<li>  默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一）</li>
<li>  如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;Content-Type, X-Custom-Header&#x27;)</span><br></pre></td></tr></table></figure>

<ul>
<li>  Access-Control-Allow-Methods</li>
<li>  默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods 来指明实际请求所允许使用的 HTTP 方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;POST, GET, DELETE, HEAD&#x27;)</span><br><span class="line">res.setHEader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;*&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="CORS-请求分类"><a href="#CORS-请求分类" class="headerlink" title="CORS 请求分类"></a>CORS 请求分类</h3><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><ul>
<li>  请求方式：GET、POST、HEAD 三者之一</li>
<li>  HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值 application/x-www-formurlencoded、multipart/form-data、text/plain）</li>
</ul>
<h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><ul>
<li>  请求方式为 GET、POST、HEAD 之外的请求 Method 类型</li>
<li>  请求头中包含自定义头部字段</li>
<li>  向服务器发送了 application/json 格式的数据</li>
</ul>
<p>在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据</p>
<h4 id="简单请求和预检请求"><a href="#简单请求和预检请求" class="headerlink" title="简单请求和预检请求"></a>简单请求和预检请求</h4><ul>
<li>  简单请求的特点：客户端与服务器之间只会发送一次请求</li>
<li>  预检请求的特点：客户端与服务器之间会发送两次请求，OPTION预检请求成功之后，才会发起真正的请求</li>
</ul>
<h3 id="JSONP接口"><a href="#JSONP接口" class="headerlink" title="JSONP接口"></a>JSONP接口</h3><h4 id="回顾JSONP的概念与特点"><a href="#回顾JSONP的概念与特点" class="headerlink" title="回顾JSONP的概念与特点"></a>回顾JSONP的概念与特点</h4><p>概念：浏览器端通过<script>标签的src属性，请求服务器上的数据，同时，服务器放回一个函数的调用，这种请求数据的方式叫做JSONP</p>
<p>特点：</p>
<ul>
<li>  JSONP不属于真正的Ajax请求，因为她没有使用XMLHttpRequest这个对象</li>
<li>  JSONP仅支持GTE请求，不支持POST、PUT、DELETE等请求</li>
</ul>
<h4 id="创建JSONP接口的注意事项"><a href="#创建JSONP接口的注意事项" class="headerlink" title="创建JSONP接口的注意事项"></a>创建JSONP接口的注意事项</h4><p>如果项目中已经配置了CORS的跨域资源共享，为了防止冲突，必须在配置CORS中间件之前声明JSONP的接口，否则JSONP接口会被处理成开启了CORS的接口</p>
<h4 id="实现JSONP接口的步骤"><a href="#实现JSONP接口的步骤" class="headerlink" title="实现JSONP接口的步骤"></a>实现JSONP接口的步骤</h4><ol>
<li> 获取客户端发送过来的回调函数的名字</li>
<li> 得到要通过JSONP形式发送给客户端的数据</li>
<li> 根据前两步得到的数据，拼接主一个函数调用的字符串</li>
<li> 把上一步拼接得到的字符串，响应给客户端的<script>标签进行解析执行</li>
</ol>
<h4 id="实现JSONP接口的具体代码"><a href="#实现JSONP接口的具体代码" class="headerlink" title="实现JSONP接口的具体代码"></a>实现JSONP接口的具体代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 必须在配置cors前配置JSONP接口</span><br><span class="line">app.get(&#x27;/api/jsonp&#x27;,(req, res) =&gt; &#123; </span><br><span class="line">  // 得到函数的名称</span><br><span class="line">  const funcName = req.query.callback</span><br><span class="line">  // 定义要发送到客户端的数据对象</span><br><span class="line">  const data = &#123; name: &#x27;czf&#x27;, age: 21&#125;</span><br><span class="line">  // 把拼接的字符串，响应给客户端</span><br><span class="line">  const scriptStr = `$&#123;funcName&#125;($&#123;JSON.stringify(data)&#125;)`</span><br><span class="line">  // 把拼接的字符串响应给客户端</span><br><span class="line">  res.send(scriptStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(&#x27;#btnJsonp&#x27;).on(&#x27;click&#x27;, function() &#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    type: &#x27;GET&#x27;,</span><br><span class="line">    url: &#x27;http://127.0.0.1:81/api/jsonp&#x27;,</span><br><span class="line">    dataType: &#x27;jsonp&#x27;,</span><br><span class="line">    success: function (res) &#123;</span><br><span class="line">      console.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h2><p>数据库（database）是用来组织、存储和管理数据的仓库</p>
<h3 id="常见的数据库及分类"><a href="#常见的数据库及分类" class="headerlink" title="常见的数据库及分类"></a>常见的数据库及分类</h3><p>市面上的数据库有很多种，最常见的数据库有如下几个</p>
<ul>
<li>  MySQL数据库（目前使用最广泛、流行度最高的开源免费数据库；Community + Enterprise）</li>
<li>  Oracle数据库</li>
<li>  SQL Server数据库里</li>
<li>  Mongodb数据库</li>
</ul>
<p>其中MySQL、Oracle、SQL Server 属于传统型数据库（又叫做:关系型数据库或SQL数据库），这三者的设计理念相同、用法比较类似</p>
<p>而Mongodb属于新型数据库（又叫做:非关系型数据库或NoSQL数据库），它在一定程度上弥补了传统型数据库的缺陷</p>
<h3 id="传统型数据库的数据组织结构"><a href="#传统型数据库的数据组织结构" class="headerlink" title="传统型数据库的数据组织结构"></a>传统型数据库的数据组织结构</h3><p>在传统型数据库中，数据的结构分为数据库（database）、数据表（table）、数据行（row）、字段（field）这四大部分组成</p>
<ul>
<li>  数据库类似与Excel的工作薄</li>
<li>  数据表类似于Excel的工作表</li>
<li>  数据行类似于excel的没一行数据</li>
<li>  字段类似于Excel的列</li>
<li>  每个字段都有对应的数据类型</li>
</ul>
<h2 id="MySQL的基本使用"><a href="#MySQL的基本使用" class="headerlink" title="MySQL的基本使用"></a>MySQL的基本使用</h2><p>DataType数据类型</p>
<ul>
<li>  int 整数</li>
<li>  varchar(len) 字符串</li>
<li>  tinyint(1) 布尔值</li>
</ul>
<p>字段的特殊标识：</p>
<ul>
<li>  PK（Primary Key） 主键、唯一标识</li>
<li>  NN（Not Null） 值不允许为空</li>
<li>  UQ（Unique） 值唯一</li>
<li>  AI（Auto Increment） 值自动增长</li>
</ul>
<h2 id="使用SQL管理数据库"><a href="#使用SQL管理数据库" class="headerlink" title="使用SQL管理数据库"></a>使用SQL管理数据库</h2><p>SQL全称（Structured Query Language）是结构化查询语言，专门用来访问和处理数据库的编程语言，能够让我们以编程的形式，操作数据库里的数据</p>
<ul>
<li>  SQL是一门数据库编程语言</li>
<li>  使用SQL语言编写出来的代码，叫做SQL语句</li>
<li>  SQL语言只能在关系型数据库中使用</li>
</ul>
<h3 id="sql能做什么"><a href="#sql能做什么" class="headerlink" title="sql能做什么"></a>sql能做什么</h3><ul>
<li>  增(insert into)删(delete)查(select)改(update )</li>
<li>  创建数据库</li>
<li>  创建新表</li>
<li>  创建存储过程、视图</li>
<li>  etc…</li>
</ul>
<h2 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h2><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p><code>select */列 from 表名</code></p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>INSERT INTO 语句用于向数据表中插入新的数据行</p>
<p><code>insert into table_name(列1， 列2) values(值1，值2)</code></p>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>UPDATE：更新某一行中的一个列</p>
<p><code>update table_name set 列=&#39;&#39; where 行 = ?</code></p>
<p>UPDATE：更新某一行中的若干列·</p>
<p><code>updata table_name set 列=&#39;&#39;, 列=&#39;&#39; where 行= ?</code></p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>DELETE语句用于删除表中的行</p>
<p><code>delete from table_name where 行= ?</code></p>
<h4 id="WHERE语句"><a href="#WHERE语句" class="headerlink" title="WHERE语句"></a>WHERE语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询语句中的WHERE条件</span><br><span class="line">select 列名称 from 表名称 where 列 运算符 值</span><br><span class="line">update 表名称 set 列=值 where 列 运算符 值</span><br><span class="line">delete from 表名称 where 列 运算符 值</span><br></pre></td></tr></table></figure>

<h4 id="AND和OR运算符"><a href="#AND和OR运算符" class="headerlink" title="AND和OR运算符"></a>AND和OR运算符</h4><p>and和or可在where子句中把两个或多个条件结合起来</p>
<p>and表示必须同时满足多个条件，相当于Javascript中的&amp;&amp;运算符</p>
<p>or表示只要满足任意一个条件即可，相当于JavaScript中的||运算符</p>
<h4 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h4><p>ORDER BY语句用于根据指定的列对结果进行排序</p>
<p>ORDER BY语句默认按照升序对记录进行升序排序（asc）</p>
<p>如果希望按照降序对记录进行排序，可以使用DESC关键字</p>
<p><code>select * from table_name order by 字段</code></p>
<p><code>select * from table_name order by 字段 desc</code></p>
<p><strong>多重排序</strong></p>
<p>例子：对users表中的数据，先按照status字段进行降序排序，再按照username的字母顺序，进行升序排序</p>
<p><code>select * from users order by status desc, username asc</code></p>
<h4 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT(*)"></a>COUNT(*)</h4><p>COUNT(*) 函数用于返回查询结果的总数据条数</p>
<p><code>select count(*) from 表名称</code></p>
<h4 id="AS"><a href="#AS" class="headerlink" title="AS"></a>AS</h4><p>使用AS为列设置别名</p>
<p><code>select * as 别名 from 表名称</code></p>
<h2 id="在项目中操作MySQL"><a href="#在项目中操作MySQL" class="headerlink" title="在项目中操作MySQL"></a>在项目中操作MySQL</h2><ol>
<li> 安装操作MySQL数据库的第三方模块（mysql）</li>
<li> 通过mysql模块链接到MySQL数据库</li>
<li> 通过mysql模块执行SQL语句</li>
</ol>
<h3 id="安装mysql模块"><a href="#安装mysql模块" class="headerlink" title="安装mysql模块"></a>安装mysql模块</h3><p>mysql模块是托管于npm上的第三方模块，它提供了在Node.js项目中链接和操作MySQL数据库的能力</p>
<p><code>npm install mysql</code></p>
<h3 id="配置mysql模块"><a href="#配置mysql模块" class="headerlink" title="配置mysql模块"></a>配置mysql模块</h3><p>在使用mysql模块操作MySQL数据库之前，必须先度mysql模块进行必要的配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 导入mysql模块</span><br><span class="line">const mysql = require(&#x27;mysql&#x27;)</span><br><span class="line">// 建立于MySQL数据库的连接关系</span><br><span class="line">const db = mysql.createPool(&#123;</span><br><span class="line">  host: &#x27;127.0.0.1&#x27;, // 数据库的IP地址</span><br><span class="line">  user: &#x27;root&#x27;, // 登录数据库的账号</span><br><span class="line">  password: &#x27;123456&#x27;, // 登录数据库的密码</span><br><span class="line">  database: &#x27;my_db_01&#x27; // 指定要操作哪个数据库</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 查询</span><br><span class="line">const sqlStr = &#x27;select * from users&#x27;</span><br><span class="line">db.query(sqlStr, (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line"></span><br><span class="line">  console.log(results)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 插入</span><br><span class="line">const user = &#123; username: &#x27;lhw&#x27;,  password: &#x27;lhw123&#x27;&#125;</span><br><span class="line">const sqlStr1 = &#x27;insert into users(username, password) values(?, ?)&#x27;</span><br><span class="line"></span><br><span class="line">db.query(sqlStr1, [user.username, user.password], (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line">  if(results.affectedRows === 1) &#123;</span><br><span class="line">    console.log(&#x27;插入数据成功&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>向表中新增数据是，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速插入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123; username: &#x27;xjc&#x27;,  password: &#x27;xjc123&#x27;&#125;</span><br><span class="line">const sqlStr1 = &#x27;insert into users set ?&#x27;</span><br><span class="line"></span><br><span class="line">db.query(sqlStr1, user, (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line">  if(results.affectedRows === 1) &#123;</span><br><span class="line">    console.log(&#x27;插入数据成功&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123; id: 5, username: &#x27;aaa&#x27;,  password: &#x27;000&#x27;&#125;</span><br><span class="line">const sqlStr1 = &#x27;update users set username=?, password=? where id=?&#x27;</span><br><span class="line"></span><br><span class="line">db.query(sqlStr1, [user.username, user.password, user.id], (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line">  if(results.affectedRows === 1) &#123;</span><br><span class="line">    console.log(&#x27;更新数据成功&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 更新用户信息，便捷方式</span><br><span class="line">const user = &#123; id: 5, username: &#x27;bbb&#x27;,  password: &#x27;111&#x27;&#125;</span><br><span class="line">const sqlStr1 = &#x27;update users set ? where id=?&#x27;</span><br><span class="line"></span><br><span class="line">db.query(sqlStr1, [user, user.id], (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line">  if(results.affectedRows === 1) &#123;</span><br><span class="line">    console.log(&#x27;更新数据成功&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 删除id为5的数据</span><br><span class="line">const sqlStr1 = &#x27;delete from users where id=?&#x27;</span><br><span class="line"></span><br><span class="line">db.query(sqlStr1, 5, (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line">  if(results.affectedRows === 1) &#123;</span><br><span class="line">    console.log(&#x27;删除数据成功&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>标记删除</p>
<p>使用delete语句，会真正的把数据从表中删除，为了保险起见，推荐使用标记删除的形式，来模拟删除的动作。所谓标记删除，就是在表中设置类似于status这样的状态字段，来标记当前这条数据是否被删除。</p>
<p>当用户执行了删除的动作时，我们并没有执行delete语句把数据删除掉，而是执行了update语句将这条数据对应的status字段标记为删除即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const sqlStr1 = &#x27;update users set status=? where id=?&#x27;</span><br><span class="line">db.query(sqlStr1, [1, 4], (err, results) =&gt; &#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line">  if (results.affectedRows === 1) &#123;</span><br><span class="line">    console.log(&#x27;标记删除成功&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="前后端的身份验证"><a href="#前后端的身份验证" class="headerlink" title="前后端的身份验证"></a>前后端的身份验证</h2><h3 id="Web开发模式"><a href="#Web开发模式" class="headerlink" title="Web开发模式"></a>Web开发模式</h3><h3 id="服务端渲染的Web开发模式"><a href="#服务端渲染的Web开发模式" class="headerlink" title="服务端渲染的Web开发模式"></a>服务端渲染的Web开发模式</h3><ul>
<li>  服务端渲染的概念：服务器发送给客户端的HTML页面，是在服务器通过字符串的拼接，动态生成的，因此，客户端不需要使用Ajax.js这样的技术额外请求页面的数据</li>
</ul>
<h3 id="服务端渲染的优缺点"><a href="#服务端渲染的优缺点" class="headerlink" title="服务端渲染的优缺点"></a>服务端渲染的优缺点</h3><p>优点</p>
<ul>
<li>  前端耗时少，因为服务器端负责动态生成HTML内容，浏览器只需要直接渲染页面即可，尤其是移动端，更省电。</li>
<li>  有利于SEO，因为服务器端响应的是完整的HTML页面内容，所以爬虫更加容易获取信息，更有利于SEO。</li>
</ul>
<p>缺点</p>
<ul>
<li>  占用服务器端资源，即服务器完成HTML页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。</li>
<li>  不利于前后端分离，开发效率低，使用服务器渲染，则无法进行分工合作，尤其对前端复杂度高的项目，不利于项目高效开发。</li>
</ul>
<h3 id="前后端分离的Web开发模式"><a href="#前后端分离的Web开发模式" class="headerlink" title="前后端分离的Web开发模式"></a>前后端分离的Web开发模式</h3><p>前后端分离的概念：前后端分离的开发模式，依赖于Ajax技术的广泛应用，前后端分离的Web开发模式，就是后端只负责提供API接口，前端使用Ajax调用接口的开发模式。</p>
<h3 id="前后端分离的优缺点"><a href="#前后端分离的优缺点" class="headerlink" title="前后端分离的优缺点"></a>前后端分离的优缺点</h3><p>优点：</p>
<ul>
<li>  开发体验好，前端专注于UI页面的开发，后端专注于api的开发，且前端会有更多的选择性</li>
<li>  用户体验好，Ajax技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新</li>
<li>  减轻了服务器的渲染压力，因为页面最终是在每个用户的浏览器中生成的</li>
</ul>
<p>缺点：</p>
<ul>
<li>  不利于SEO，因为完整的HTML页面需要在客户端动态拼接完成，所以爬虫无法爬取页面的有效信息</li>
</ul>
<h3 id="如何选择web开发模式"><a href="#如何选择web开发模式" class="headerlink" title="如何选择web开发模式"></a>如何选择web开发模式</h3><p>不谈业务场景而盲目选择使用何种开发模式都是耍流氓</p>
<ul>
<li>  比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的SEO，则这时我们就需要使用服务器渲染</li>
<li>  而类似后台管理项目，交互性比较强，不需要考虑SEO，那么就可以使用前后端分离的开发模式，</li>
</ul>
<p>另外，具体使用何种开发模式并不是绝对的，为了同时兼顾首页的渲染速度和前后端分离的开发效率，一些网站采用了首屏服务器渲染+其他页面前后端分离的开发模式。</p>
<h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><p>目的：为了确认当前所声称为某种身份的用户，确实是所声称的用户</p>
<h4 id="不同开发模式下的身份认证"><a href="#不同开发模式下的身份认证" class="headerlink" title="不同开发模式下的身份认证"></a>不同开发模式下的身份认证</h4><p>对于服务器渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案：</p>
<ol>
<li> 服务器渲染推荐使用Session认证机制</li>
<li> 前后端分离推荐使用JWT认证机制</li>
</ol>
<h4 id="Session认证机制"><a href="#Session认证机制" class="headerlink" title="Session认证机制"></a>Session认证机制</h4><h5 id="HTTP协议的无状态性"><a href="#HTTP协议的无状态性" class="headerlink" title="HTTP协议的无状态性"></a>HTTP协议的无状态性</h5><p>HTTP协议的无状态性，指的是客户端的每次HTTP请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次HTTP请求的状态</p>
<h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>cookie是存储在用户浏览器中的一段不超过4KB的字符串，它由一个名称（Name），一个值(Value)和其他几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。</p>
<p>不同域名下的Cookie各自独立，每当客户端发起请求的时，会自动把当前域名下所有未过期的Cookie一同发送到服务器</p>
<p>Cookie的几大特性：</p>
<ul>
<li>  自动发送</li>
<li>  域名独立</li>
<li>  过期限制</li>
<li>  4KB限制</li>
</ul>
<h5 id="Cookie在身份认证中的作用"><a href="#Cookie在身份认证中的作用" class="headerlink" title="Cookie在身份认证中的作用"></a>Cookie在身份认证中的作用</h5><p>客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的Cookie，客户端会自动将Cookie保存在浏览器中。</p>
<p>随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的Cookie，通过请求头的形式发送给服务器，服务器即可验明客户端的身份。</p>
<p><img src=""></p>
<h5 id="Cookie不具有安全性"><a href="#Cookie不具有安全性" class="headerlink" title="Cookie不具有安全性"></a>Cookie不具有安全性</h5><p>由于Cookie时存储在浏览器中的，而且浏览器也提供了读写Cookie的API，因此Cookie很容易被伪造，不具有安全性，因此不建议服务器将重要的隐私数据通过Cookie的形式发送给浏览器</p>
<h5 id="Session的工作原理"><a href="#Session的工作原理" class="headerlink" title="Session的工作原理"></a>Session的工作原理</h5><p><img src=""></p>
<h4 id="在Express中使用Session认证"><a href="#在Express中使用Session认证" class="headerlink" title="在Express中使用Session认证"></a>在Express中使用Session认证</h4><p>配置express-session中间件</p>
<p>express-session中间件安装成功后，需要通过app.use()来注册session中间件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> const app = express()</span><br><span class="line"></span><br><span class="line">const session =require(&#x27;express-session&#x27;)</span><br><span class="line">app.use(</span><br><span class="line">  session(&#123;</span><br><span class="line">    secret: &#x27;itheima&#x27;,</span><br><span class="line">    resave: false,</span><br><span class="line">    saveUninitialized: true,</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>向session中存数据</p>
<p>当express-session中间件配置成功后，即可通过req.session来访问和使用session对象，从而存储用户的关键信息</p>
<h4 id="JWT认证机制"><a href="#JWT认证机制" class="headerlink" title="JWT认证机制"></a>JWT认证机制</h4><p>session认证机制需要配合Cookie才能实现，由于Cookie默认不支持跨域访问，所以，当涉及到当前跨域请求后端接口的时候，需要很多额外的配置，才能实现跨域session认证。</p>
<p>注意：</p>
<ul>
<li>  当前端请求后端接口不存在跨域问题的时候，推荐使用Session身份认证机制</li>
<li>  当前端需要跨域请求后端接口的时候，不推荐使用Session身份认证机制，推荐使用JWT认证机制</li>
</ul>
<h5 id="JWT工作原理"><a href="#JWT工作原理" class="headerlink" title="JWT工作原理"></a>JWT工作原理</h5><p><img src=""></p>
<p>总结：用户的信息通过Token字符串的形式，保存在客户端浏览器中，服务器通过还原Token字符串的形式来认证用户的身份</p>
<h5 id="JWT的组成部分"><a href="#JWT的组成部分" class="headerlink" title="JWT的组成部分"></a>JWT的组成部分</h5><p>JWT通常由三部分组成，分别是Header（头部）、Payload（有效荷载）、Signature（签名）</p>
<p>三者之间使用英文的”.”分割</p>
<h5 id="JWT的三个部分各自代表的含义"><a href="#JWT的三个部分各自代表的含义" class="headerlink" title="JWT的三个部分各自代表的含义"></a>JWT的三个部分各自代表的含义</h5><p>JWT的三个部分，从前到后分别时Header、Payload、Signature</p>
<p>其中：</p>
<ul>
<li>  Payload部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串</li>
<li>  Header和Signature是安全性相关的部分，只是为了保证Token的安全性</li>
</ul>
<h5 id="JWT使用方式"><a href="#JWT使用方式" class="headerlink" title="JWT使用方式"></a>JWT使用方式</h5><p>客户端收到服务器放回的JWT之后，通常会将它存储在localStorage或sessionStorage中</p>
<p>此后，客户端每次与服务器通信，都要带上这个JWT的字符串，从而进行身份认证，推荐的做法是把JWT放在HTTP请求头的Authorization字段中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure>

<h4 id="在Express中使用JWT"><a href="#在Express中使用JWT" class="headerlink" title="在Express中使用JWT"></a>在Express中使用JWT</h4><h5 id="安装JWT相关的包"><a href="#安装JWT相关的包" class="headerlink" title="安装JWT相关的包"></a>安装JWT相关的包</h5><p><code>npm install jsonwebtoken express-jwt</code></p>
<p>其中：</p>
<ul>
<li>  jsonwebtoken用于生成JWT字符串</li>
<li>  express-jwt用于将JWT字符串解析还原成JSON对象</li>
</ul>
<h5 id="导入JWT相关的包"><a href="#导入JWT相关的包" class="headerlink" title="导入JWT相关的包"></a>导入JWT相关的包</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cosnt jwt = require(&#x27;jsonwebtoken&#x27;)</span><br><span class="line"></span><br><span class="line">const expressJWT = require(’express-jwt&#x27;)</span><br></pre></td></tr></table></figure>

<h5 id="定义secret密钥"><a href="#定义secret密钥" class="headerlink" title="定义secret密钥"></a>定义secret密钥</h5><p>为了保证JWT字符串的安全性，防止JWT字符串在网络传输过程中被别人破解，我们需要定义一个用于加密和解密的secret密钥：</p>
<ol>
<li> 当生成JWT字符串的时候，需要使用secret密钥对用户的信息进行加密，最终得到加密好的JWT字符串</li>
<li> 当把JWT字符串解析还原成JSON对象的时候，需要使用secret密钥进行解密</li>
</ol>
<p><code>const secretKey = &#39;itheima No1 ^_^&#39;</code></p>
<h5 id="在登录成果后生成JWT字符串"><a href="#在登录成果后生成JWT字符串" class="headerlink" title="在登录成果后生成JWT字符串"></a>在登录成果后生成JWT字符串</h5><p>调用jsonwebtoken包提供的sign()方法，将用户的信息加密成JWT字符串，响应给客户端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.post(&#x27;api/login&#x27;, function(req, res) &#123;</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    status: 200,</span><br><span class="line">    message: &#x27;登录成功&#x27;,</span><br><span class="line">    token: jwt.sign(&#123; username: userinfo.username &#125;, secretKey, &#123; expiresIn: &#x27;30s&#x27;&#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="将JWT字符串还原为JSON对象"><a href="#将JWT字符串还原为JSON对象" class="headerlink" title="将JWT字符串还原为JSON对象"></a>将JWT字符串还原为JSON对象</h5><p>客户端每次在访问那些有权限接口的时候，都需要主动通过请求头中的Authorization字段，将Token字符串发送到服务器进行身份认证</p>
<p>此时服务器可以通过<strong>express-jwt</strong>这个中间件，自动将客户端发送过来的Token解析还原成JSON对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用app.use()来注册中间件</span><br><span class="line">// expressJWT(&#123; secret: secretKey &#125;) 就是用来解析Token的中间件</span><br><span class="line">// .unless(&#123; path: [/^/api//]&#125;) 用来指定哪些接口不需要访问权限</span><br><span class="line">app.use(expressJWT(&#123; secret: secretKey &#125;).unless(&#123; path: [/^/api//]&#125;))</span><br></pre></td></tr></table></figure>

<h5 id="使用req-user获取用户信息"><a href="#使用req-user获取用户信息" class="headerlink" title="使用req.user获取用户信息"></a>使用req.user获取用户信息</h5><p>当express-jwt这个中间件配置成功之后，即可在那些有权限的接口中，使用req.user对象，来访问从JWT字符串中解析出来的用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;/admin/getinfo&#x27;, function(req, res) &#123;</span><br><span class="line">  console.log(req.user)</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    status: 200,</span><br><span class="line">    message: &#x27;获取用户信息成功！&#x27;,</span><br><span class="line">    data: req.user</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="捕获解析JWT失败后产生的错误"><a href="#捕获解析JWT失败后产生的错误" class="headerlink" title="捕获解析JWT失败后产生的错误"></a>捕获解析JWT失败后产生的错误</h5><p>当使用express-jwt解析Token字符串时，如果客户端发送过来的Token字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行，我们可以通过Express的错误中间件，捕获这个错误并进行相关的处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.use((err, req, res, next) =&gt; &#123;</span><br><span class="line">  // token解析失败导致的错误</span><br><span class="line">  if(err.name === &#x27;UnauthorizedError&#x27;) &#123;</span><br><span class="line">    return res.send(&#123; status: 401, message: &#x27;无效的token&#x27;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 其他原因导致的错误</span><br><span class="line">  res.send(&#123; status: 500, message: &#x27;未知错误&#x27;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></script></p>
      </section>

    </article>
    
    


    <!-- 版权声明 -->
    <div class="post-copyright">
	<div>
		<strong>本文作者：</strong>
		<span>
			ChenZF
		</span>
	</div>
	<div>
		<strong>本文链接：</strong>
		<a href="http://example.com/Node-js学习">
			http://example.com/post/Node-js学习
		</a>
	</div>
	<div>
		<span>欢迎任何形式的转载，但请务必注明出处。</span>
	</div>
	<div>
		<span>由于笔者水平有限，如果文章或代码有表述不当之处，还请不吝赐教。</span>
	</div>
</div>


<style>
	.post-copyright {
		background-color: #fff;
		/* box-shadow: 0px 0px 1px 1px rgba(0, 0, 0, 0.05); */
		box-shadow: 0 6px 30px -10px rgba(0, 0, 0, 0.1);
		display: block;
		margin: 20px auto;
		margin-bottom: 15px;
		padding: 10px;
		font-size: 15px;
		color: #2e2d2d;
		word-break: break-all;
		line-height: 1.8;
	}


	.post-copyright a {
		color: #2e2d2d;
		border-bottom: 1px solid #999;
	}

	.post-copyright a:hover {
		color: #2e2d2d;
		border-bottom: 1px solid #000;
	}
</style>

    <!-- comments -->
    <div class="comments">
    <h3 id="commenttitle" style="margin-top: 20px;margin-left: 10px;">评论区</h3>
    <div id="tcomment"></div>
</div>
<script src="https://cdn.jsdelivr.net/npm/twikoo@1.0.0/dist/twikoo.all.min.js"></script>
<script>twikoo.init({ envId: 'shuxhan-2gcz5b7m7f845ec3', el: '#tcomment' })</script>

    <div class="right-icon">
      <div id="to-valine" class="right-icon-item">
        <a href="#commenttitle">评论</a>
      </div>
    </div>

  </div>


  <aside>
    <div class="aside-wrap">
    
        <section class="widget-wrap">
    <h3 class="widget-title">简介</h3>
    <div class="widget">
        <div class="notice">
            <img class="notice-img" src="http://riukjvybq.hn-bkt.clouddn.com/%E5%A4%B4%E5%83%8F.jpg">
            <p>一个前端程序员的<br>编程笔记和生活记录！</p>
            
            <p class="notice-item">
                <!-- github -->
                <span><a target="_blank" href="https://github.com/Pokemonfeng"><img src="http://riukjvybq.hn-bkt.clouddn.com/github.46c47564.png" alt="Github"></a></span>
                <!-- juejin -->
                <span><a target="_blank" href="https://juejin.cn/user/2243476206137950"><img src="http://riukjvybq.hn-bkt.clouddn.com/favicon.ico" alt="掘金社区"></a></span>
                <!-- zhihu -->
                <!-- <span><a target="_blank" href=""><img src="https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108172745.ico" alt="知乎"></a></span> -->
                <!-- csdn -->
                <span><a target="_blank" href="https://blog.csdn.net/weixin_47017046"><img src="http://riukjvybq.hn-bkt.clouddn.com/csdn.9c2b2075.png" alt="CSDN"></a></span>
            </p>

            <ul class="statistics">
                <li>
                    <span>文章</span>
                    <a href="./archives">8</a>
                </li>
                <li>
                    <span>字数</span>
                    <a>20.3k</a>
                </li>
                <li>
                    <span>访客</span>
                    <a id="busuanzi_value_site_uv"></a>
                </li>
                
                
            </ul>

            <div id="follow" class="button">
                <a target="_blank" href="https://github.com/Pokemonfeng">关注</a>
            </div>
        </div>
    </div>
</section>

    
        

    
        
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitHub/" rel="tag">GitHub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Neilify/" rel="tag">Neilify</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li></ul>
    </div>
  </div>


    
        
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul class="recent-posts">
        
          <li>
            <a href="/2023/03/07/Netlify%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/">Netlify前端自动化部署服务</a>
          </li>
        
          <li>
            <a href="/2023/03/06/Webpack%E5%AD%A6%E4%B9%A0/">Webpack学习</a>
          </li>
        
          <li>
            <a href="/2023/03/06/Vue3%E5%88%9D%E5%AD%A6%E4%B9%A0/">Vue3初学习</a>
          </li>
        
          <li>
            <a href="/2023/03/05/Node-js%E5%AD%A6%E4%B9%A0/">Node.js学习</a>
          </li>
        
          <li>
            <a href="/2022/09/27/Hexo%E5%AD%A6%E4%B9%A0/">Hexo学习</a>
          </li>
        
      </ul>
    </div>
  </div>

    
        
  <section class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li></ul>
    </div>
  </section>


    
        <!-- 
  <section class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div>
      <ul class="widget-links">
          
          <li>
              <a target="_blank" rel="noopener" href="https://pokemonfeng.github.io/" title="">
                  pika的博客空间
              </a>
          </li>
          
      </ul>
    </div>
  </section>


<style>
  .widget-links {
    list-style: none;
    padding-left: 10px;
  }
  .widget-links >li > a:hover {
    color: #f40;
    text-decoration: underline;
  }
</style> -->
    
    
</div>


    <!-- 目录 -->
    
  </aside>
  
</div>

					</div>
				</div>

				<!-- 返回顶部按钮 -->
				<div class="right-icon">
					<div id="to-top" class="right-icon-item">
						<a>
							<span class="top-left"></span>
							<span class="top-right"></span>
						</a>
					</div>
				</div>
		</div>
		<footer class="footer">

    <div class="copyright-wrap">
      <span>&copy; 2022-2023 ChenZF</span>
      <span id="timeDate">载入天数...</span><span id="busuanzi_container_site_pv">
      总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    
</div>
    
    
    <!-- <span id="busuanzi_container_site_uv">
      ，本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span> -->
    
</footer>

<script>
    var now = new Date();
    function createtime() {
      var grt = new Date("09/27/2022 11:00:00");//此处修改你的建站时间或者网站上线时间 
      now.setTime(now.getTime() + 250);
      days = (now - grt) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
      document.getElementById("timeDate").innerHTML = "本站已安全运行 " + dnum + " 天 ";
    }
    setInterval("createtime()", 1000);
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/lib/jquery.js"></script>


<script src="/lib/waves.js"></script>


<script src="/lib/jquery-ui.js"></script>


<script src="/lib/jquery.tocify.js"></script>


<script src="/js/main.js"></script>


			
<style>
  .copy-btn {
    display: inline-block;
    padding: 6px 12px;
    font-size: 13px;
    font-weight: 500;
    line-height: 20px;
    color: rgb(206, 206, 206);
    white-space: nowrap;
    vertical-align: middle;
    cursor: pointer;
    border-radius: 3px;
    user-select: none;
    outline: 0;
  }

  .copy-btn:hover {
    color: #888
  }

  .highlight-wrap .copy-btn {
    padding: 2px 6px;
    position: absolute;
    right: 10px;
    top: 1px;
    z-index: 1;
  }



  .highlight-wrap {
    position: relative;
  }

  #copysuccess {
    width: 200px;
    height: 75px;
    position: fixed;
    right: 50%;
    margin-right: -100px;
    top: 40%;
    margin-top: -40px;
    color: #fff;
    font-weight: 600;
    background: #444444d8;
    display: none;
    z-index: 99999;
    border-radius: 10px;
    text-align: center;
    line-height: 30px;
    padding-top: 10px;
    user-select: none;
  }
</style>

<script>
  addLoadEvent(() => {
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<div>').addClass('copy-btn').append('复制代码').on('click', function (e) {
        var copysuccess = document.getElementById('copysuccess');
        copysuccess.style.display = 'block'
        setTimeout(function () {
          copysuccess.style.display = 'none'
        }, 2000)
        var code = $(this).parent().find(".code")[0].innerText
          
                var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
          
                  if (result) $(this).text('复制成功')
            else $(this).text('复制失败')
              
                $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制代码')
        }, 1000)
      }).append(e)
    })
  })
</script>

				<div id="copysuccess">复制成功<br>欢迎阅读文章~</div>
	</body>

</html>

<script>
	$('#to-top').click(function () { $('html,body').animate({ scrollTop: '0px' }, 500); return false; });
</script>